/**
 * This file loads (most) of the backbone views.
 *
 * @author David Aguilera <david.aguilera@neliosoftware.com>
 * @since  1.0.0
 */
(function( $ ) {
	'use strict';

	// --------------------------------------------------------------------------
	// Social Message Editor Views
	// --------------------------------------------------------------------------

	/**
	 * This view allows the user to edit a social message.
	 *
	 * It's designed as a container view that holds references to a set of
	 * subviews:
	 *
	 *  * Actual Editor: a textarea that allows the user to actually modify the
	 *    message.
	 *  * Profile Selector: a component that allows the user to select the
	 *    social profile(s) in which the message will be shared.
	 *  * Preview: a component that previews the message using the look and feel
	 *    of the currently-selected profile.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SocialMessageEditor = Backbone.View.extend({
	
		/**
		 * Whether this view has already been rendered or not.
		 */
		_rendered: false,
	
		/**
		 * The subviews managed by this parent view:
		 *
		 *  * `actualEditor`: a textarea that allows the user to actually modify the
		 *    message.
		 *  * `profileSelector: a component that allows the user to select the social
		 *    profile(s) in which the message will be shared.
		 *  * `preview`: a component that previews the message using the look and
		 *    feel of the currently-selected profile.
		 */
		_views: {
			actualEditor: undefined,
			profileSelector: undefined,
			dateSelector: undefined,
			timeSelector: undefined,
			preview: undefined
		},
	
		/**
		 * Whether the preview is visible or not.
		 */
		_isPreviewVisible: true,
	
		/**
		 * A reference to the browser's window.
		 */
		_$window: undefined,
	
		/**
		 * A reference to the save button in the dialog.
		 */
		_$saveButton: undefined,
	
		/**
		 * Whether this view should be destroyed on dialog closing or not.
		 */
		_closeAndDestroy: true,
	
		/**
		 * The underscore template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-social-message-editor' ).innerHTML ) ),
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add some global vars.
			this._$window = $( window );
	
			// Add some bindings.
			this.render = _.bind( this.render, this );
			this._onDialogSave = _.bind( this._onDialogSave, this );
			this._onDialogCancel = _.bind( this._onDialogCancel, this );
			this._onDialogDelete = _.bind( this._onDialogDelete, this );
	
			// Initialize all child views.
			this._views.actualEditor = new NelioContent.views.SocialMessageActualEditor({
				model: this.model
			});
			this.listenTo( this._views.actualEditor, 'nc:click:preview', this._togglePreviewVisibility );
			this.listenTo( this._views.actualEditor, 'nc:click:addImage', this._addImage );
			this._views.actualEditor.isPreviewVisible( this._isPreviewVisible );
	
			this._views.dateSelector = new NelioContent.views.DateSelector({ model : this.model });
	
			this._views.timeSelector = new NelioContent.views.TimeSelector({ model : this.model });
	
			if ( this.model.isNew() ) {
	
				if ( NelioContent.profiles.length > 1 ) {
	
					this._views.profileSelector = new NelioContent.views.MultipleProfileSelector({
						model: this.model
					});
	
				} else if ( NelioContent.profiles.at( 0 ).allowsMultiTargets() ) {
	
					this._views.profileSelector = new NelioContent.views.MultipleProfileSelector({
						model: this.model
					});
	
				} else {
	
					this._views.profileSelector = new NelioContent.views.SingleProfileSelector({
						model: this.model
					});
	
				}//end if
	
			} else {
	
				this._views.profileSelector = new NelioContent.views.SingleProfileSelector({
					model: this.model
				});
	
			}//end if
	
			this._isPreviewVisible = ( 'visible' === store.get( 'nc-preview', 'visible' ) );
			if ( this._isPreviewVisible ) {
				this._selectAppropriatePreviewView();
			}//end if
	
			// Convert the editor into a dialog.
			this._convertToDialog();
	
			// Add listeners.
			this.listenTo( this.model, 'change:network', this._selectAppropriatePreviewView );
			this.listenTo( this.model, 'change', this._maybeEnableSaveButton );
	
			this.listenTo( this.model, 'nc:load:post', this.render );
			this.listenTo( this.model, 'nc:error:post', this._unableToLoadPost );
	
		},//end initialize()
	
		/**
		 * Renders this view just one time. If the function is called again and the
		 * view was already rendered, old HTML content is returned.
		 *
		 * @return {SocialMessageActualEditor} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			if ( this.model.get( 'postId' ) > 0 && 0 === this.model.post.get( 'id' ) ) {
				this.model.loadPost();
				this.el.innerHTML = '<div class="nc-social-message-editor"><div class="nc-loading-container"><span class="spinner is-active"></span><div class="nc-loading">' + NelioContent.i18n.feedback.loadingNoSpinner + '</div></div></div>';
				var $saveButton = this.$el.parent().find( 'button.nc-save-button' );
				$saveButton.addClass( 'button-disabled' );
				return this;
			}//end if
	
			// We make sure that the view is rendered only once.
			if ( this._rendered ) {
				return this;
			}//end if
	
			this._rendered = true;
	
			var json = this.model.toJSON();
	
			// Render the base component.
			this.el.innerHTML = this.template( json );
	
			// Render the actual editor.
			this.$( '.nc-editor' ).html( this._views.actualEditor.render().$el );
	
			// Render profile(s) selector.
			if ( typeof this._views.profileSelector !== 'undefined' ) {
				this.$( '.nc-profile-selector' ).html( this._views.profileSelector.render().$el );
			}//end if
	
			// Render date and time selector.
			this.$( '.nc-date' ).html( this._views.dateSelector.render().$el );
			this.$( '.nc-time' ).html( this._views.timeSelector.render().$el );
	
			// And disable them if the user is not subscribed to one of our plans.
			if ( 'none' === NelioContent.subscriptionPlan ) {
				this._views.dateSelector.lock();
				this._views.timeSelector.lock();
			}//end if
	
			// Fix profile selector classes.
			if ( this.model.isNew() ) {
	
				if ( NelioContent.profiles.length > 1 ) {
					this.$( '.nc-profile-selector' ).addClass( 'nc-multiple' );
				} else if ( NelioContent.profiles.at( 0 ).allowsMultiTargets() ) {
					this.$( '.nc-profile-selector' ).addClass( 'nc-multiple' );
				} else {
					this.$( '.nc-profile-selector' ).addClass( 'nc-single' );
					this.$( '.nc-profile-selector' ).addClass( 'nc-profile-hidden' );
				}//end if
	
			} else if ( 1 === NelioContent.profiles.length || 'none' === NelioContent.subscriptionPlan ) {
	
				this.$( '.nc-profile-selector' ).addClass( 'nc-single' );
				this.$( '.nc-profile-selector' ).addClass( 'nc-profile-hidden' );
	
			} else {
	
				this.$( '.nc-profile-selector' ).addClass( 'nc-single' );
	
			}//end if
	
			// Render preview block.
			if ( this._isPreviewVisible ) {
				this._addPreview();
			}//end if
	
			// Finally, make sure this element is rendered (and opened) as a dialog.
			this._maybeEnableSaveButton();
	
			return this;
	
		},//end render()
	
		/**
		 * This function disables the given profiles, so that the user can't select
		 * them for scheduling new social messages.
		 *
		 * @param profileIds array List of profiles that can no longer be used.
		 *
		 * @since 1.0.0
		 */
		disableProfiles: function( profileIds ) {
	
			if ( typeof this._views.profileSelector.disableProfiles !== 'function' ) {
				return;
			}//end if
	
			this._views.profileSelector.disableProfiles( profileIds );
	
		},//end disableProfiles()
	
		/**
		 * Locks all inputs, so that the user cannot interact with the view
		 * (presumably, whilst saving).
		 *
		 * @since 1.0.0
		 */
		_lock: function() {
	
			this.$el.addClass( 'nc-locked' );
	
			this._views.actualEditor.lock();
			this._views.profileSelector.lock();
			this._views.dateSelector.lock();
			this._views.timeSelector.lock();
	
		},//end _lock()
	
		/**
		 * Selects the appropriate preview class (assuming the message preview is
		 * visible) based on the nework of the currently-selected social profile.
		 *
		 * @since 1.0.0
		 */
		_selectAppropriatePreviewView: function() {
	
			// Previews are only useful if they're visible.
			if ( ! this._isPreviewVisible ) {
				return;
			}//end if
	
			// Find the currently active profile.
			var currentProfile = NelioContent.profiles.get( this.model.get( 'profileId' ) );
			if ( typeof currentProfile === 'undefined' ) {
				currentProfile = NelioContent.profiles.at( 0 );
				this.model.set( 'profileId', currentProfile.get( 'id' ) );
			}//end if
	
			// We now need to load the proper view class based on the network
			// associated to the current profile.
			var networkMeta = _.findWhere( NelioContent.networkMetas, {
				id: currentProfile.get( 'network' )
			});
			if ( typeof networkMeta === 'undefined' ) {
				networkMeta = NelioContent.networkMetas[0];
			}//end if
	
			var viewClass = NelioContent.views[networkMeta.previewClassName];
	
			// Close the old view.
			this._removePreview();
	
			// Create the new preview view and include it in this parent view.
			this._views.preview = new viewClass({
				model: this.model
			});
			this._addPreview();
	
		},//end _selectAppropriatePreviewView()
	
		/**
		 * Adds the preview class in the appropriate location (i.e. the
		 * `.social-profile` element).
		 *
		 * @since 1.0.0
		 */
		_addPreview: function() {
	
			this.$( '.nc-social-preview' ).html( this._views.preview.render().$el );
	
		},//end _addPreview()
	
		/**
		 * Closes the preview instance and "removes" it.
		 *
		 * @since 1.0.0
		 */
		_removePreview: function() {
	
			if ( typeof this._views.preview === 'object' ) {
	
				this._views.preview.close();
				this._views.preview = false;
	
			}//end if
	
		},//end _removePreview()
	
		/**
		 * Hides or shows the message preview.
		 *
		 * @since 1.0.0
		 */
		_togglePreviewVisibility: function() {
	
			// Toggle visibility value.
			this._isPreviewVisible = ! this._isPreviewVisible;
			if ( this._isPreviewVisible ) {
				store.set( 'nc-preview', 'visible' );
			} else {
				store.set( 'nc-preview', 'hidden' );
			}//end if
	
			// Make sure we re-render the actual editor, so that the action button
			// looks fine.
			this._views.actualEditor.isPreviewVisible( this._isPreviewVisible );
			this._views.actualEditor.render();
	
			if ( this._isPreviewVisible ) {
	
				// Create and add a preview view.
				this._selectAppropriatePreviewView();
				this._addPreview();
	
			} else {
	
				this._removePreview();
	
			}//end if
	
		},//end _togglePreviewVisibility()
	
		/**
		 * Converts this view in a jQuery dialog.
		 *
		 * @since 1.0.0
		 */
		_convertToDialog: function() {
	
			// Create buttons.
			var buttons = [];
			buttons.push(
				NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.cancel )
			);
			buttons.push(
				NelioContent.helpers.makeDialogSaveButton( this, NelioContent.i18n.actions.save )
			);
			if ( ! this.model.isNew() ) {
				buttons.push(
					NelioContent.helpers.makeDialogDeleteButton( this, NelioContent.i18n.actions.delLabel )
				);
			}//end if
	
			// Prepare dialog.
			var view = this;
			this.$el.dialogS2({
	
				title: ( view.model.isNew() ) ?
					NelioContent.i18n.titles.newMessage : NelioContent.i18n.titles.editMessage,
	
				buttons: buttons,
				draggable: false,
				modal: true,
				resizable: false,
				width: Math.min( 600, view._$window.width() - 40 ),
	
				position: {
					my: 'center top',
					at: 'center top+60'
				},
	
				/**
				 * Opens the dialog and listens to the events triggered by its buttons.
				 *
				 * @since 1.0.0
				 */
				open: function() {
	
					// Listen to dialog button events.
					view.listenTo( view, 'nc:click:dialog:save', view._onDialogSave );
					view.listenTo( view, 'nc:click:dialog:cancel', view._onDialogCancel );
					view.listenTo( view, 'nc:click:dialog:delete', view._onDialogDelete );
	
					// Prepare beautiful tooltips for save button.
					view._$saveButton = view.$el.parent().find( 'button.nc-save-button' );
					NelioContent.helpers.makeWarningTooltip( view._$saveButton );
	
					// Make sure the delete button is not focused by default.
					var $deleteButton = view.$el.parent().find( 'button.nc-delete-button' );
					if ( $deleteButton.length > 0 ) {
						$deleteButton.blur();
					}//end if
	
				},//end open()
	
				/**
				 * Destroys the dialog and triggers the `nc:close:dialog` event.
				 *
				 * @since 1.0.0
				 */
				close: function() {
	
					// Stop listening to dialog buttons, now that the dialog is about to be closed.
					view.stopListening( view, 'nc:click:dialog:save', view._onDialogSave );
					view.stopListening( view, 'nc:click:dialog:cancel', view._onDialogCancel );
					view.stopListening( view, 'nc:click:dialog:delete', view._onDialogDelete );
	
					// Remove beautiful tooltips for save button.
					view._$saveButton.tooltip( 'destroy' );
					view._$saveButton = undefined;
	
					// If necessary, destroy the dialog.
					if ( view._closeAndDestroy ) {
						view.$el.dialogS2( 'destroy' );
						view.trigger( 'nc:close:dialog' );
					}//end if
	
				}//end close()
	
			});
	
		},//end _convertToDialog()
	
		/**
		 * A callback function that enables or disables the save social message
		 * button, depending on whether the model can be saved or not.
		 *
		 * @since 1.0.0
		 */
		_maybeEnableSaveButton: function() {
	
			if ( typeof this._$saveButton === 'undefined' ) {
				return;
			}//end if
	
			this._$saveButton.tooltip( 'close' );
	
			var missing = this.model.isSomethingMissing();
			if ( missing ) {
				this._$saveButton.addClass( 'button-disabled', true );
				this._$saveButton.attr( 'title', _.escape( missing ) );
			} else {
				this._$saveButton.removeClass( 'button-disabled', false );
				this._$saveButton.attr( 'title', '' );
			}//end if
	
		},//end _maybeEnableSaveButton()
	
		/**
		 * Callback function that opens a dialog for selecting the image that should
		 * be attached to this view's social message.
		 *
		 * @since 1.0.0
		 */
		_addImage: function() {
	
			this._closeAndDestroy = false;
			this.$el.dialogS2( 'close' );
	
			// Choose the image that has to be selected in the selector.
			// If the post already included an image, we probably need to use
			// that one. Otherwise, post's featured image is the best alternative.
			var image;
			if ( this.model.get( 'imageId' ) > 0 ) {
				image = this.model.get( 'imageId' );
			} else if ( this.model.post.get( 'imageId' ) > 0 ) {
				image = this.model.post.get( 'imageId' );
			}//end if
	
			var view = this;
			NelioContent.helpers.selectImage({
	
				/**
				 * Image selected by default.
				 */
				image: image,
	
				/**
				 * Callback function that will be called upon image selection. It
				 * modifies adds said image in the current model.
				 *
				 * @param image {object} the selected image (as returned by wp.media).
				 *
				 * @since 1.0.0
				 */
				onSelection: function( image ) {
	
					// Update the model.
					view.model.set( 'type', 'image' );
					view.model.set( 'image', image.url );
					view.model.set( 'imageId', image.id );
					view.model.set( 'imageSource', 'WordPress' );
	
					// Close media dialog.
					this.onClose();
	
				},
	
				/**
				 * Callback function that will be called upon closing the dialog.
				 *
				 * It re-opens the social message editor dialog.
				 *
				 * @since 1.0.0
				 */
				onClose: function() {
	
					// Reopen the dialog.
					view.$el.dialogS2( 'open' );
					view._closeAndDestroy = true;
	
				}//end onClose()
	
			});
	
		},//end _addImage()
	
		/**
		 * Callback function that saves the social messages and closes the dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogSave: function() {
	
			if ( this.model.isSomethingMissing() ) {
				return;
			}//end if
	
			var $dialog = this.$el.parent();
			var $saveButton = $dialog.find( '.ui-dialog-buttonpane button.button-primary' );
			var $otherButtons = $dialog.find( '.ui-dialog-titlebar button, .ui-dialog-buttonpane button:not( .button-primary )' );
	
			// Disable all input fields and buttons.
			this._lock();
			this.$el.dialogS2( 'option', 'closeOnEscape', false );
			$saveButton.prop( 'disabled', true );
			$otherButtons.prop( 'disabled', true );
			$saveButton.html( NelioContent.i18n.feedback.saving );
	
			var view = this;
			this.model.save( undefined, {
	
				/**
				 * This function updates the values of the given model to the ones
				 * returned by our cloud and re-renders the list of editorial tasks.
				 *
				 * @param model    {object} The model we're saving.
				 * @param response {object} The response from our cloud.
				 *
				 * @since 1.0.0
				 */
				success: function( model, response ) {
	
					if ( view.model.isNew() ) {
						view.trigger( 'nc:add:messages', response );
					} else {
						view.trigger( 'nc:update:message', response );
					}//end if
	
					view.$el.dialogS2( 'close' );
	
				},//end success()
	
				/**
				 * XXX
				 *
				 * @param xhr {object} XXX.
				 *
				 * @since 1.0.0
				 */
				error: function( xhr ) {
	
					// TODO. Something to be done when things go wrong...
					view.$el.dialogS2( 'close' );
	
				},//end error()
	
			});
	
		},//end _onDialogSave()
	
		/**
		 * Callback function that discards all changes and closes the dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogCancel: function() {
	
			this.$el.dialogS2( 'close' );
	
		},//end _onDialogCancel()
	
		/**
		 * Callback function that deletes the social message and closes the dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogDelete: function() {
	
			var view = this;
			var $el = NelioContent.helpers.openDeletionConfirmationDialog(
				NelioContent.i18n.titles.delSocialMessage,
				NelioContent.i18n.dialogs.deleteSocialMessage,
				NelioContent.i18n.actions.doDeleteSocial,
				function() {
					var $dialog = $el.parent();
					$dialog.find( '.nc-super-delete-button' ).html( NelioContent.i18n.feedback.deleting );
					$dialog.find( 'button' ).prop( 'disabled', true );
					view.model.destroy({
	
						success: function( model, response ) {
							$el.dialog( 'destroy' );
							view.trigger( 'nc:delete:message', view.model );
							view.$el.dialogS2( 'close' );
						}//end success()
	
					});
	
				}
			);
	
		},//end _onDialogDelete()
	
		/**
		 * Callback function that tells the user we weren't able to load the related post.
		 *
		 * @param message {string} Description of the error.
		 *
		 * @since 1.0.0
		 */
		_unableToLoadPost: function( message ) {
	
			// Close this view.
			this.$el.dialogS2( 'close' );
			this.close();
	
			// Open a new dialog.
			var error = NelioContent.i18n.errors.socialMessage.unableToLoadPost;
			error = error.replace( '{error}', message );
			NelioContent.helpers.openErrorDialog( message );
	
		},//end _unableToLoadPost()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Remove child views.
			for ( var viewName in this._views ) {
	
				if ( this._views.hasOwnProperty( viewName ) ) {
	
					var view = this._views[ viewName ];
					if ( typeof view === 'object' ) {
						view.close();
					}//end if
	
				}//end if
	
			}//end for
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SocialMessageEditor
	
	
	/**
	 * This view allows the user to edit a social message.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SocialMessageActualEditor = Backbone.View.extend({
	
		/**
		 * Whether this subview is locked or not.
		 */
		_isLocked: false,
	
		/**
		 * Whether the preview is visible or not.
		 *
		 * This variable is a "copy" of the same variable in the SocialMessageEditor
		 * class. We need it here to paint the preview button properly.
		 */
		_isPreviewVisible: undefined,
	
		/**
		 * Whether we're waiting for the user to confirm (or cancel) the deletion
		 * of the image related to this social message.
		 */
		_awaitingImageDeletionConfirmation: false,
	
		/**
		 * Whether the related post selector has to be shown or not.
		 */
		_relatedPostMode: 'hide-related-post',
	
		/**
		 * A jQuery div that contains the related post selector.
		 */
		_$postSelectorDiv: undefined,
	
		/**
		 * The underscore template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-social-message-actual-editor' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
	
			'click .nc-action.nc-preview': '_triggerPreviewEvent',
	
			'click .nc-action.nc-add.nc-image': '_addImage',
			'click .nc-action.nc-remove.nc-image': '_removeImage',
			'click .nc-do-remove': '_doRemoveImage',
			'click .nc-cancel-remove': '_hideRemoveConfirmation',
	
			'click .nc-post-selector a': '_createRelatedPostSelector',
	
			'change textarea': '_changeText',
			'keyup  textarea': '_changeText'
	
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.render = _.bind( this.render, this );
			this.listenTo( this, 'nc:render', this.render );
	
			this.listenTo( this.model, 'change:type', this.render );
			this.listenTo( this.model, 'change:postId', this.render );
	
			this.listenTo( this.model, 'change:network', this._updateCharCount );
			this.listenTo( this.model, 'change:profiles', this._updateCharCount );
	
			this._awaitingImageDeletionConfirmation = false;
	
			if ( this.model.isNew() ) {
	
				if ( 0 === this.model.get( 'postId' ) &&
						typeof NelioContent.lastPublishedPost !== 'undefined' ) {
					this._relatedPostMode = 'show-post-selector-action';
				} else {
					this._relatedPostMode = 'hide-related-post';
				}//end if
	
			} else if ( 0 === this.model.get( 'postId' ) ) {
	
				this._relatedPostMode = 'no-related-post';
	
			} else {
	
				// TODO. This should depend on the page we're in.
				this._relatedPostMode = 'show-related-post';
	
			}//end if
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {SocialMessageActualEditor} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Detach selector (if existed).
			if ( typeof this._$postSelectorDiv !== 'undefined' ) {
				this._$postSelectorDiv.detach();
			}//end if
	
			var json = this.model.toJSON();
			json.isPreviewVisible = this._isPreviewVisible;
			json.awaitingDeletionConfirmation = this._awaitingImageDeletionConfirmation;
			json.relatedPostMode = this._relatedPostMode;
	
			json.postEditLink = this.model.post.get( 'editLink' );
			json.postTitleFormatted = this.model.post.get( 'titleFormatted' );
	
			this.el.innerHTML = this.template( json );
			this._updateCharCount();
	
			if ( 'show-post-selector' === this._relatedPostMode ) {
	
				this.$( '.nc-post-selector-container' ).html( this._$postSelectorDiv );
	
			}//end if
	
			return this;
	
		},//end render()
	
		/**
		 * This callback triggers a `nc:click:preview` event.
		 *
		 * In principle, this view is contained in the Social Message Editor view,
		 * which is the view that's responsible of showing/hiding the actual
		 * preview.
		 *
		 * @since 1.0.0
		 */
		isPreviewVisible: function( isPreviewVisible ) {
	
			this._isPreviewVisible = isPreviewVisible;
	
		},//end isPreviewVisible()
	
		/**
		 * This function locks all inputs in this view.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
			this.$( 'textarea' ).prop( 'disabled', true );
	
		},//end lock();
	
		/**
		 * This callback triggers a `nc:click:preview` event.
		 *
		 * In principle, this view is contained in the Social Message Editor view,
		 * which is the view that's responsible of showing/hiding the actual
		 * preview.
		 *
		 * @since 1.0.0
		 */
		_triggerPreviewEvent: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			this.trigger( 'nc:click:preview' );
	
		},//end _triggerPreviewEvent()
	
		/**
		 * This callback changes the `text` attribute of the model that's related to
		 * this view.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_changeText: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this.stopListening( this.model, 'change', this.render );
			this.model.set( 'text', NelioContent.helpers.trim( $el.val() ) );
			this.listenTo( this.model, 'change', this.render );
	
			this._updateCharCount();
	
		},//end _changeText()
	
		/**
		 * This callback updates the char count of the current message.
		 *
		 * Note the following:
		 *
		 *  * If the message is too long, an `overflow` class is added.  This class
		 *    helps us highlight this fact and hence warn the user.
		 *  * If the textarea container uses a scrollbar, a `scrollbar-is-visible`
		 *    class is added. This class helps us "move" the `char-count` element
		 *    so that it doesn't hover the scrollbar.
		 *
		 * @since 1.0.0
		 */
		_updateCharCount: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			var $charCount = this.$( '.nc-char-count' );
			var availableChars = this.model.getMaxTextLength() - this.model.getTextLength();
	
			// Warn if message's length is too much.
			if ( this.model.isTextTooLong() ) {
				$charCount.addClass( 'nc-overflow' );
				$charCount.html( '<span class="nc-dashicons nc-dashicons-warning"></span> ' + availableChars );
			} else {
				$charCount.removeClass( 'nc-overflow' );
				$charCount.html( availableChars );
			}//end if
	
			// If there's a scroll bar, move the number a little bit.
			var textarea = this.$( 'textarea' )[0];
			if ( typeof textarea !== 'undefined' && textarea.clientHeight < textarea.scrollHeight) {
				$charCount.css( 'right', NelioContent.helpers.getScrollbarWidth() + 2 );
			} else {
				$charCount.css( 'right', '' );
			}//end if
	
		},//end _updateCharCount()
	
		/**
		 * Callback invoked when the user clicks on the `add-image` link.
		 *
		 * It triggers the `nc:click:add-image` event.
		 *
		 * @since 1.0.0
		 */
		_addImage: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			this.trigger( 'nc:click:addImage' );
	
		},//end _addImage()
	
		/**
		 * Callback function for deleting the image attached to this social message.
		 *
		 * This function doesn't delete the image, but shows the confirmation message
		 * instead.
		 *
		 * @since 1.0.0
		 */
		_removeImage: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			this._awaitingImageDeletionConfirmation = true;
			this.trigger( 'nc:render' );
	
		},//end _removeImage()
	
		/**
		 * Callback function for actually removing the attached image.
		 *
		 * @since 1.0.0
		 */
		_doRemoveImage: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			// Update model.
			this.model.set( 'type', 'text' );
			this.model.set( 'image', '' );
			this.model.set( 'imageId', 0 );
			this.model.set( 'imageSource', 'none' );
	
			// Refresh view.
			this._hideRemoveConfirmation();
	
		},//end _doRemoveImage()
	
		/**
		 * Callback function for hiding the message deletion confirmation message.
		 *
		 * @since 1.0.0
		 */
		_hideRemoveConfirmation: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			this._awaitingImageDeletionConfirmation = false;
			this.trigger( 'nc:render' );
	
		},//end _hideRemoveConfirmation()
	
		/**
		 * This helper function creates a ncselect2 instance for the post selector.
		 *
		 * This instance is prepared to:
		 *
		 *  * Retrieve posts from the WordPress backend.
		 *  * Format the result set so that it includes the featured image, author,
		 *    and so on.
		 *
		 * @since 1.0.0
		 */
		_createRelatedPostSelector: function() {
	
			// Create the select component.
			var $select =  $( '<select></select>' );
			this._$postSelectorDiv = $( '<div></div>' );
			this._$postSelectorDiv.html( $select );
			this.$( '.nc-post-selector-container' ).html( this._$postSelectorDiv );
	
			var defaultValue = NelioContent.lastPublishedPost.toJSON();
			defaultValue.text = defaultValue.titleFormatted;
	
			// Initialize ncselect2.
			var view = this;
			var postResultTemplate = _.template( NelioContent.helpers.trim( document.getElementById( '_nc-post-result' ).innerHTML ) );
			$select.ncselect2({
	
				// Define some styles for this ncselect2 component.
				width: '70%',
				dropdownCssClass: 'nc-ncselect2-above-jquery-dialog nc-post-selector-in-message-editor',
	
				data: [ defaultValue ],
	
				// Post information is loaded using AJAX.
				ajax: {
	
					url: ajaxurl,
					dataType: 'json',
					delay: 250,
	
					// Send the params our PHP WordPress callback needs/expects.
					data: function( params ) {
	
						var query = {
							action: 'nelio_content_get_posts',
							term:   params.term,
							page:   params.page,
							status: 'publish'
						};
						return query;
	
					},//end data()
	
					// Return the results with the format expected by ncselect2.
					processResults: function( data, params ) {
	
						params.page = params.page || 1;
	
						for ( var i = 0; i < data.items.length; ++i ) {
	
							data.items[i].title = NelioContent.helpers.decodeHTMLEntities( data.items[i].titleFormatted );
							data.items[i].excerpt = NelioContent.helpers.decodeHTMLEntities( data.items[i].excerptFormatted );
	
							data.items[i].titleFormatted = _.escape( data.items[i].title );
							data.items[i].excerptFormatted = _.escape( data.items[i].excerpt );
							data.items[i].authorNameFormatted = _.escape( data.items[i].authorName );
	
							data.items[i].text = data.items[i].titleFormatted;
	
						}//end for
	
						return {
							results: data.items,
							pagination: { more : data.more }
						};
	
					},//end processResults()
	
					cache: false
	
				},//end processResults()
	
				// Style the results in the dropdown list.
				templateResult: function( post ) {
	
					if ( typeof post.titleFormatted === 'undefined' ) {
						return post.text;
					}//end if
					return $( postResultTemplate( post ) );
	
				},//end templateResult()
	
				// Style the selected option.
				templateSelection: function( selection ) {
	
					if ( typeof selection.titleFormatted !== 'undefined' ) {
	
						var post = new NelioContent.models.Post({
							id: selection.id,
							author: selection.author,
							date: selection.date,
							excerptFormatted: selection.excerptFormatted,
							image: selection.image,
							imageId: selection.imageId,
							permalink: selection.permalink,
							editLink: selection.editLink,
							status: selection.status,
							titleFormatted: selection.titleFormatted
						});
	
						view.stopListening( view.model, 'change:postId', view.render );
						view.model.setPost( post );
						view.listenTo( view.model, 'change:postId', view.render );
	
					}//end if
	
					return selection.text;
	
				}//end templateSelection
	
			});
	
			this._relatedPostMode = 'show-post-selector';
	
			this.trigger( 'nc:render' );
	
			return false;
	
		},//end _createRelatedPostSelector()
	
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SocialMessageActualEditor
	
	
	/**
	 * Dialog for selecting targets.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.TargetSelector = Backbone.View.extend({
	
		/**
		 * Meta information related to the given
		 */
		_networkMeta: undefined,
	
		/**
		 * List of available targets.
		 */
		_targets: [],
	
		/**
		 * The targets that were selected when this selector was first opened.
		 */
		_originalSelection: undefined,
	
		/**
		 * Whether the list of targets for the current profile is being loaded or not.
		 */
		_loadingTargets: true,
	
		/**
		 * A reference to the browser's window.
		 */
		_$window: undefined,
	
		/**
		 * Template for rendering a single target in the target selector.
		 */
		_targetTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-profile-target' ).innerHTML ) ),
	
		/**
		 * The underscore template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-target-selector' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'click .nc-profile-target.nc-selectable': '_toggleTargetSelection'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add some global vars.
			this._$window = $( window );
	
			// Add some bindings.
			this.render = _.bind( this.render, this );
			this._onDialogSave = _.bind( this._onDialogSave, this );
			this._onDialogCancel = _.bind( this._onDialogCancel, this );
	
			this._networkMeta = _.findWhere( NelioContent.networkMetas, {
				id: this.model.get( 'network' )
			});
	
			this._originalSelection = [];
	
			// Add listeners.
			this.listenTo( this, 'nc:render', this.render );
			this.listenToOnce( this, 'nc:load:targets', this._onTargetsLoaded );
			this.listenToOnce( this, 'nc:load:targets', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view just one time. If the function is called again and the
		 * view was already rendered, old HTML content is returned.
		 *
		 * @return {SocialMessageActualEditor} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Prepare data for rendering.
			var data = {
				loadingLabel: this._networkMeta.multiTargetLabels.loading,
				loadingTargets: this._loadingTargets,
				explanation: this._networkMeta.multiTargetLabels.explanation
			};
	
			// Render the whole view.
			this.el.innerHTML = this.template( data );
	
			// Render each individual target.
			var targetContainer = this.$( '.nc-targets' )[0];
			_.each( this._targets, function( target ) {
				targetContainer.innerHTML += this._targetTemplate( target );
			}, this );
	
			return this;
	
		},//end render()
	
		/**
		 * Sets the original selection to the given names.
		 *
		 * @param targetNames {array} Set of targets that were selected when this dialog was created.
		 *
		 * @since 1.0.0
		 */
		setOriginalSelection: function( targetNames ) {
	
			this._originalSelection = targetNames;
	
		},//end setOriginalSelectionrender()
	
		/**
		 * Converts this view in a jQuery dialog.
		 *
		 * @since 1.0.0
		 */
		openDialog: function() {
	
			this.trigger( 'nc:render' );
	
			// Create buttons.
			var buttons = [];
			buttons.push(
				NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.cancel )
			);
			buttons.push(
				NelioContent.helpers.makeDialogSaveButton( this, NelioContent.i18n.actions.save )
			);
	
			// Prepare dialog.
			var view = this;
			this.$el.dialogS2({
	
				title: view._networkMeta.multiTargetLabels.title,
	
				buttons: buttons,
				draggable: false,
				modal: true,
				resizable: false,
				width: Math.min( 560, view._$window.width() - 80 ),
	
				position: {
					my: 'center top',
					at: 'center top+60'
				},
	
				/**
				 * Opens the dialog and listens to the events triggered by its buttons.
				 *
				 * @since 1.0.0
				 */
				open: function() {
	
					// Listen to dialog button events.
					view.listenTo( view, 'nc:click:dialog:save', view._onDialogSave );
					view.listenTo( view, 'nc:click:dialog:cancel', view._onDialogCancel );
	
					// Make sure the delete button is not focused by default.
					var $deleteButton = view.$el.parent().find( 'button.nc-delete-button' );
					if ( $deleteButton.length > 0 ) {
						$deleteButton.blur();
					}//end if
	
				},//end open()
	
				/**
				 * Destroys the dialog and triggers the `nc:close:dialog` event.
				 *
				 * @since 1.0.0
				 */
				close: function() {
	
					// Stop listening to dialog buttons, now that the dialog is about to be closed.
					view.stopListening( view, 'nc:click:dialog:save', view._onDialogSave );
					view.stopListening( view, 'nc:click:dialog:cancel', view._onDialogCancel );
	
					// If necessary, destroy the dialog.
					if ( view._closeAndDestroy ) {
						view.$el.dialogS2( 'destroy' );
						view.trigger( 'nc:close:dialog' );
					}//end if
	
				}//end close()
	
			});
	
			this.$el.parent().find( '.ui-dialog-titlebar button' ).prop( 'disabled', true );
			this.$el.parent().find( '.ui-dialog-buttonpane button' ).prop( 'disabled', true );
	
			this._loadTargets();
	
		},//end openDialog()
	
		/**
		 * Helper function that loads the list of targets related to this social
		 * profile asynchronously.
		 *
		 * When the targets have been loaded, the event `nc:load:targets` is
		 * triggered, along with the list of targets.
		 *
		 * See API call: /profile/{id}/targets
		 *
		 * @since 1.0.0
		 */
		_loadTargets: function() {
	
			var view = this;
			$.ajax({
	
				url: NelioContent.apiUri + '/profile/' + this.model.get( 'id' ) + '/targets',
				method: 'GET',
				headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },
	
				timeout: 30000,
	
				/**
				 * Triggers the `nc:load:targets` event with the list of targets found.
				 *
				 * @param result {object} List of targets.
				 *
				 * @since 1.0.0
				 */
				success: function( result ) {
	
					view.trigger( 'nc:load:targets', result );
	
				},//end success()
	
	
				/**
				 * XXX.
				 *
				 * @param xhr {object} XXX.
				 *
				 * @since 1.0.0
				 */
				error: function( xhr ) {
	
					view.$el.dialogS2( 'close' );
					NelioContent.helpers.openErrorDialog( xhr.responseJSON );
	
				}//end error()
	
			});
	
		},//end _loadTargets()
	
		/**
		 * Callback function that updates the selector with the given list of targets.
		 *
		 * @param targets {object} List of targets.
		 *
		 * @since 1.0.0
		 */
		_onTargetsLoaded: function( targets ) {
	
			// Save targets in this variable.
			this._targets = targets;
			_.each( this._targets, function( target ) {
				target.selected = _.contains( this._originalSelection, target.name );
			}, this );
	
			this._loadingTargets = false;
			this.$el.parent().find( '.ui-dialog-titlebar button' ).prop( 'disabled', false );
			this.$el.parent().find( '.ui-dialog-buttonpane button' ).prop( 'disabled', false );
	
		},//end _onTargetsLoaded()
	
		/**
		 * Toggles the selection of the target the user clicked on and re-renders the
		 * view.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback
		 *
		 * @since 1.0.0
		 */
		_toggleTargetSelection: function( ev ) {
	
			// Get the ID of the clicked target.
			var el = ev.target || ev.srcElement;
			var name = $( el ).closest( '.nc-selectable' ).data( 'target-name' );
	
			// Mark it as selected.
			var target = _.findWhere( this._targets, { name: name } );
			if ( typeof target === 'object' ) {
				target.selected = ! target.selected;
			}//end if
	
			// If we're not subscribed, we can select one target only.
			if ( 'none' === NelioContent.subscriptionPlan ) {
				_.each( this._targets, function( target ) {
					if ( target.name !== name ) {
						target.selected = false;
					}//end if
				});
			}//end if
	
			// Re-render.
			this.trigger( 'nc:render' );
	
		},//end _toggleTargetSelection()
	
		/**
		 * Callback function that saves the set of selected targets and closes the
		 * dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogSave: function() {
	
			if ( this._loadingTargets ) {
				return;
			}//end if
	
			// Define some variables.
			var $dialog = this.$el.parent();
			var $otherButtons = $dialog.find( '.ui-dialog-titlebar button, .ui-dialog-buttonpane button:not( .button-primary )' );
			var $saveButton = $dialog.find( '.ui-dialog-buttonpane button.button-primary' );
	
			// Disable all input fields and buttons.
			$saveButton.prop( 'disabled', true );
			$otherButtons.prop( 'disabled', true );
			$saveButton.html( NelioContent.i18n.feedback.saving );
	
			// Notify the parent view that a new set of targets has been selected.
			var selectedTargets = _.filter( this._targets, function( target ) {
				return target.selected;
			});
			this.trigger( 'nc:update:targets', selectedTargets );
			this.$el.dialogS2( 'close' );
	
		},//end _onDialogSave()
	
		/**
		 * Callback function that discards the changes and closes the dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogCancel: function() {
	
			if ( this._loadingTargets ) {
				return;
			}//end if
	
			this.$el.dialogS2( 'close' );
	
		},//end _onDialogCancel()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Remove child views.
			for ( var viewName in this._views ) {
	
				if ( this._views.hasOwnProperty( viewName ) ) {
	
					var view = this._views[ viewName ];
					if ( typeof view === 'object' ) {
						view.close();
					}//end if
	
				}//end if
	
			}//end for
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class TargetSelector
	
	

	// Profile Selectors
	// -----------------

	// User selector views might not be always available.
	if ( document.getElementById( '_nc-user-selector-option' ) ) {
		/**
		 * This class implements a ncselect2 component for selecting users.
		 *
		 * Note this view doesn't have a related model.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.UserSelector = Backbone.View.extend({
		
			/**
			 * This template is used for rendering a profile in the results list of a
			 * ncselect2 component.
			 */
			_userOptionTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-user-selector-option' ).innerHTML ) ),
		
			/**
			 * This template is used for rendering the selected profile in a ncselect2
			 * component.
			 */
			_selectedUserTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-user-selector-selected-option' ).innerHTML ) ),
		
			/**
			 * Whether this view has already been rendered or not.
			 */
			_rendered: false,
		
			/**
			 * User that has to be selected by default.
			 */
			_defaultValue: undefined,
		
			/**
			 * List of valid users.
			 */
			_single: false,
		
			/**
			 * Reference to the user select HTML element.
			 */
			_$select: undefined,
		
			/**
			 * List of events.
			 */
			events: {
				'change .nc-user-selector': '_onUserChange'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @param options {array} Optional. List of options for this view, including:
			 *              * `defaultValue`: ID of the user that has to be selected by default.
			 *
			 * @since 1.0.0
			 */
			initialize: function( options ) {
		
				// Default values.
				if ( typeof options === 'undefined' ) {
					options = {};
				}//end if
		
				if ( typeof options.defaultValue !== 'undefined' ) {
					this._defaultValue = options.defaultValue;
				}//end if
		
				if ( typeof options.single === 'boolean' ) {
					this._single = options.single;
				}//end if
		
				// Add listeners.
				this.render = _.bind( this.render, this );
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {UserSelector} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// We make sure that the view is rendered only once.
				if ( this._rendered ) {
					return this;
				} else {
					this._rendered = true;
				}
		
				// This view initializes a ncselect2 component that uses two templates:
				// The first one is used for rendering a profile in the dropdown list.
				var userOptionTemplate = this._userOptionTemplate;
		
				// The second one renders the selected profile (which looks like a select
				// component).
				var selectedUserTemplate = this._selectedUserTemplate;
		
				var arrWithDefaultValue = [];
				if ( typeof this._defaultValue !== 'undefined' ) {
					var defaultValue = NelioContent.users.getUser( this._defaultValue );
					if ( defaultValue.valid() ) {
						arrWithDefaultValue = [ defaultValue.toJSON() ];
					}//end if
				}//end if
		
				// We initialize the ncselect2 component.
				this._$select = jQuery( '<select class="nc-user-selector"></select>' );
				this.$el.html( this._$select );
				this._$select.ncselect2({
		
					data: arrWithDefaultValue,
					dropdownCssClass: 'nc-ncselect2-above-jquery-dialog',
					width: '100%',
		
					// Post information is loaded using AJAX.
					ajax: {
		
						url: ajaxurl,
						dataType: 'json',
						delay: 250,
		
						// Send the params our PHP WordPress callback needs/expects.
						data: function( params ) {
		
							var query = {
								action: 'nelio_content_get_authors',
								term:   params.term,
								page:   params.page
							};
							return query;
		
						},//end data()
		
						// Return the results with the format expected by ncselect2.
						processResults: function( data, params ) {
		
							params.page = params.page || 1;
		
							for ( var i = 0; i < data.items.length; ++i ) {
								NelioContent.users.add( data.items[ i ] );
								data.items[ i ] = NelioContent.users.get( data.items[ i ].id ).toJSON();
							}//end for
		
							return {
								results: data.items,
								pagination: { more : data.more }
							};
		
						},//end processResults()
		
						cache: false
		
					},//end processResults()
		
					templateResult: function( user ) {
		
						if ( typeof user.name === 'undefined' ) {
							return user.text;
						}
						return $( userOptionTemplate( user ) );
		
					},//end templateResult()
		
					templateSelection: function( user ) {
		
						user = NelioContent.users.getUser( user.id ).toJSON();
						return $( selectedUserTemplate( user ) );
		
					}//end templateSelection()
		
				});
				this.setValue( this._defaultValue );
		
				if ( this._single ) {
					this._$select.prop( 'disabled', true );
				}//end if
		
				return this;
		
			},//end render()
		
			/**
			 * Updates the value of the select to the given value.
			 *
			 * @param value {object} The new value of the user.
			 *
			 * @since 1.0.0
			 */
			setValue: function( value ) {
		
				// If someone is setting the value, but the element hasn't been rendered
				// yet, this value will be the "default" value.
				if ( ! this._rendered ) {
					this._defaultValue = value;
					return;
				}//end if
		
				if ( typeof value === 'undefined' ) {
					return;
				}//end if
		
				// Helper function to render the currently selected user.
				var view = this;
				function renderValue() {
					var currentValue = view._$select.val();
					if ( typeof currentValue === 'number' && value !== view._$select.val() ) {
						return;
					}//end if
					var user = NelioContent.users.getUser( value );
					var id = user.get( 'id' );
					var text = user.get( 'name' ) + ' (' + user.get( 'email' ) + ')';
					view.undelegateEvents();
					view._$select.empty().append( '<option value="' + id + '">' + text + '</option>' ).trigger( 'change' );
					view.delegateEvents();
				}//end renderValue()
		
				// Update the currently selected value and try to render the user (if it's already ready).
				this._$select.val( value );
				this.trigger( 'nc:change', value );
				var user = NelioContent.users.getUser( value );
				if ( user.isLoading() ) {
					this.listenToOnce( user, 'nc:load', renderValue );
				} else {
					renderValue();
				}//end if
		
			},//end setValue()
		
			/**
			 * Disables the user selector, so that the user cannot interact with it.
			 *
			 * @since 1.0.0
			 */
			lock: function() {
		
				this._$select.prop( 'disabled', true );
		
			},//end lock()
		
			/**
			 * Enables the user selector, so that the user can interact with it.
			 *
			 * @since 1.0.0
			 */
			unlock: function() {
		
				this._$select.prop( 'disabled', false );
		
			},//end unlock()
		
			/**
			 * Callback function that obtains the selected user and triggers an event with
			 * the new value.
			 *
			 * It triggers the `nc:change` event.
			 *
			 * @param ev {object} The JavaScript event that triggered the callback.
			 *
			 * @since 1.0.0
			 */
			_onUserChange: function( ev ) {
		
				var target = ev.target || ev.srcElement;
				var $el = $( target );
		
				this.trigger( 'nc:change', NelioContent.helpers.trim( $el.val() ) );
		
			},//end _onUserChange()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// Destroy ncselect2 component.
				if ( this._rendered ) {
					this._$select.ncselect2( 'destroy' );
				}//end if
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class UserSelector
		
		
	}//end if

	/**
	 * This view permits users to select the social profile that will be used for
	 * sharing the related social message. As a Single Profile selector, it's
	 * designed as a SELECT2 component.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @abstract
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SingleProfileSelector = Backbone.View.extend({
	
		/**
		 * This template is used for rendering a profile in the results list of a
		 * ncselect2 component.
		 */
		_profileTemplate: {
			default: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-profile' ).innerHTML ) ),
			selected: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-selected-profile' ).innerHTML ) )
		},
	
		/**
		 * This template is used for rendering a target in the results list of a
		 * ncselect2 component.
		 */
		_targetTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-target' ).innerHTML ) ),
	
		/**
		 * Helper variable that might contain the target name that was selected in
		 * the model related to this view.
		 */
		_previousTargetName: '',
	
		/**
		 * Whether the ncselect2 component for changing the target is ready or not.
		 */
		_targetDataLoader: undefined,
	
		/**
		 * Whether this view has already been rendered or not.
		 */
		_rendered: false,
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'change select.nc-profile': '_changeProfile',
			'change select.nc-target': '_changeTarget'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Prepare hooks.
			this.render = _.bind( this.render, this );
			this.listenTo( this.model, 'change:profileId', this._changeSelectedProfile );
			this.listenTo( this.model, 'change:profileId', this._fixTargetSelectorVisibility );
	
		},//end initialize()
	
		/**
		 * Renders this view just one time. If the function is called again and the
		 * view was already rendered, old HTML content is returned.
		 *
		 * @return {SocialMessagePreview} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// We make sure that the view is rendered only once.
			if ( this._rendered ) {
				return this;
			}//end if
	
			this._rendered = true;
	
			// We initialize the profile ncselect2 component.
			var $profileContainer = jQuery( '<div class="nc-profile-container"></div>' );
			var $profileSelector = jQuery( '<select class="nc-profile" name="profile"></select>' );
			$profileContainer.html( $profileSelector );
			this.$el.html( $profileContainer );
	
			var view = this;
			$profileSelector.ncselect2({
	
				dropdownCssClass: 'nc-ncselect2-above-jquery-dialog',
				data: NelioContent.profiles.toJSON(),
				width: '100%',
	
				matcher: function( term, profile ) {
					if ( typeof term !== 'object' || typeof term.term !== 'string' ) {
						return profile;
					}//end if
					term = term.term;
					var value = profile.displayName + ' ' + profile.username;
					if ( value.toLowerCase().indexOf( term.toLowerCase() ) !== -1 ) {
						profile = _( profile ).clone();
						profile.displayNameEscaped = NelioContent.helpers.strongify( _.escape( profile.displayName ), term );
						profile.usernameEscaped = NelioContent.helpers.strongify( _.escape( profile.username ), term );
						return profile;
					} else {
						return null;
					}//end if
				},
	
				templateResult: function( profile ) {
					if ( typeof profile.displayName === 'undefined' ) {
						return profile.text;
					}
					return $( view._profileTemplate.default( profile ) );
				},
	
				templateSelection: function( profile ) {
					return $( view._profileTemplate.selected( profile ) );
				}
	
			});
	
			$profileSelector.val( this.model.get( 'profileId' ) ).trigger( 'change' );
	
			// We initialize the target ncselect2 component.
			var $targetContainer = jQuery( '<div class="nc-target-container"></div>' );
			var $targetSelector = jQuery( '<select class="nc-target" name="target"></select>' );
			$targetContainer.html( $targetSelector );
	
			$targetSelector.hide();
			this.$el.append( $targetContainer );
			this._fixTargetSelectorVisibility();
	
			return this;
	
		},//end render()
	
		/**
		 * This function locks all inputs in this view.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
			this.$( 'select.nc-profile' ).prop( 'disabled', true );
			this.$( 'select.nc-target' ).prop( 'disabled', true );
	
		},//end lock()
	
		/**
		 * This callback changes the profile related to the social message.
		 *
		 * @since 1.0.0
		 */
		_changeProfile: function() {
	
			this.stopListening( this.model, 'change:profileId', this._changeSelectedProfile );
	
			// Find the profile and the network.
			var profile = NelioContent.profiles.get( NelioContent.helpers.trim( this.$( 'select.nc-profile' ).val() ) );
			if ( typeof profile !== 'undefined' ) {
				this.model.set( 'profileId', profile.get( 'id' ) );
			}//end if
	
			this.listenTo( this.model, 'change:profileId', this._changeSelectedProfile );
	
			this._maybeFixNewMessageInfo();
	
		},//end _changeProfile()
	
		/**
		 * This callback changes the concrete target in which the message will be shared,
		 * assuming the currently-selected profile has multiple targets.
		 *
		 * @since 1.0.0
		 */
		_changeTarget: function() {
	
			var $targetSelector = this.$( 'select.nc-target' );
	
			var selectedTarget = $targetSelector.val();
			var targets = $targetSelector.ncselect2( 'data' );
	
			var target = _.findWhere( targets, { id: selectedTarget } );
			if ( typeof target !== 'undefined' ) {
				this.model.set( 'targetName', target.name );
				this.model.set( 'targetDisplayName', target.displayName );
			} else {
				this.model.set( 'targetName', 'default' );
				this.model.set( 'targetDisplayName', '' );
			}//end if
	
			this._maybeFixNewMessageInfo();
	
		},//end _changeTarget()
	
		/**
		 * This callback "redraws" the ncselect2 component when the profile has been
		 * changed.
		 *
		 * @since 1.0.0
		 */
		_changeSelectedProfile: function() {
	
			this.stopListening( this.model, 'change:profileId', this._changeSelectedProfile );
			this.$( 'select' ).val( this.model.get( 'profileId' ) ).trigger( 'change' );
			this.listenTo( this.model, 'change:profileId', this._changeSelectedProfile );
	
		},//end _changeSelectedProfile()
	
		/**
		 * Callback function that shows or hides the target selector, depending on
		 * the currently-selected social profile.
		 *
		 * @since 1.0.0
		 */
		_fixTargetSelectorVisibility: function() {
	
			if ( ! this._rendered ) {
				return;
			}//end if
	
			// Destroy old selector.
			var $targetSelector = this.$( '.nc-target' );
			$targetSelector.ncselect2();
			$targetSelector.ncselect2( 'destroy' );
	
			// Cancel old requests.
			if ( typeof this._targetDataLoader !== 'undefined' ) {
	
				if ( typeof this._targetDataLoader.abort === 'function' ) {
					this._targetDataLoader.abort();
				}//end if
	
				this._targetDataLoader = undefined;
	
			}//end if
	
			// Create the new sleector if required.
			var profile = NelioContent.profiles.get( this.model.get( 'profileId' ) );
			if ( profile.allowsMultiTargets() ) {
	
				var networkMeta = _.findWhere( NelioContent.networkMetas, {
					id: this.model.get( 'network' )
				});
	
				var view = this;
	
				// Create the selector with no value, so that a "Loading" placeholder is shown.
				$targetSelector.val( '' );
				$targetSelector.ncselect2({
					placeholder: networkMeta.multiTargetLabels.loading,
					width: '100%'
				});
	
				// Run an AJAX request to load boards.
				this._targetDataLoader = $.ajax({
	
					url: NelioContent.apiUri + '/profile/' + profile.get( 'id' ) + '/targets',
					method: 'GET',
					headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },
	
					success: function( targets ) {
						view._buildTargetSelector( targets );
						view._targetDataLoader = undefined;
					},//end success()
	
					error: function() {
						view._targetDataLoader = undefined;
					}//end success()
	
				});
	
				// Leave the model as "incomplete", so that the "Save" button becomes disabled.
				this._previousTargetName = this.model.get( 'targetName' );
				this.model.set( 'targetName', '' );
				this.model.set( 'targetDisplayName', '' );
	
			} else {
	
				this.model.set( 'targetName', 'default' );
				this.model.set( 'targetDisplayName', '' );
	
			}//end if
	
		},//end _fixTargetSelectorVisibility()
	
		/**
		 * Helper function that builds a select2 component to select targets.
		 *
		 * @param targets {array} list of targets to "feed" the select2 component.
		 *
		 * @since 1.0.0
		 */
		_buildTargetSelector: function( targets ) {
	
			var $targetSelector = this.$( '.nc-target' );
			var that = this;
	
			$targetSelector.ncselect2({
	
				dropdownCssClass: 'nc-ncselect2-above-jquery-dialog',
				width: '100%',
				data: targets,
	
				matcher: function( term, target ) {
					if ( typeof term !== 'object' || typeof term.term !== 'string' ) {
						return target;
					}//end if
					term = term.term;
					if ( target.displayName.toLowerCase().indexOf( term.toLowerCase() ) !== -1 ) {
						target = _( target ).clone();
						target.displayNameEscaped = NelioContent.helpers.strongify( target.displayName, term );
						return target;
					} else {
						return null;
					}//end if
				},
	
				templateResult: function( target ) {
					if ( typeof target.displayName === 'undefined' ) {
						return target.text;
					}
					if ( typeof target.displayNameEscaped === 'undefined' ) {
						target.displayNameEscaped = _.escape( target.displayName );
					}//end if
					return $( that._targetTemplate( target ) );
				},
	
				templateSelection: function( target ) {
					if ( typeof target.displayName !== 'undefined' &&
					     typeof target.displayNamedEscaped === 'undefined' ) {
						target.displayNameEscaped = _.escape( target.displayName );
					}//end if
					return $( that._targetTemplate( target ) );
				}
	
			});
	
			if ( targets.length <= 0 ) {
				return;
			}//end if
	
			// Selector the default target (by default, the previously selected one).
			var defaultTarget = targets[0];
			var candidate = _.findWhere( targets, { name: this._previousTargetName } );
			if ( typeof candidate !== 'undefined' ) {
				defaultTarget = candidate;
			}//end if
	
			$targetSelector.val( defaultTarget.id ).trigger( 'change' );
	
			this._previousTargetName = '';
	
		},//end _buildTargetSelector()
	
		/**
		 * Updates the `profiles` attribute of the related model based on the current selection.
		 *
		 * In principle, single profile selectors are only used when editing existing
		 * social messages. However, they're also used when we're creating new social
		 * messages and the user configured one social profile only. In those "rare" cases,
		 * a target selector component might be added (depending on the social profile's
		 * network).
		 *
		 * @since 1.0.0
		 */
		_maybeFixNewMessageInfo: function() {
	
			if ( ! this.model.isNew() ) {
				return;
			}//end if
	
			this.model.set( 'profiles', [{
				id: this.model.get( 'profileId' ),
				targetName: this.model.get( 'targetName' ),
				targetDisplayName: this.model.get( 'targetDisplayName' )
			}]);
	
		},//end _maybeFixNewMessageInfo()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Destroy ncselect2 components.
			if ( this._rendered ) {
	
				this.$( 'select.nc-profile' ).ncselect2( 'destroy' );
	
				this.$( 'select.nc-target' ).ncselect2();
				this.$( 'select.nc-target' ).ncselect2( 'destroy' );
	
			}//end if
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SingleProfileSelector
	
	
	/**
	 * This view permits users to select the social profile that will be used for
	 * sharing the related social message. As a Single Profile selector, it's
	 * designed as a SELECT2 component.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @abstract
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SingleProfileSelector = Backbone.View.extend({
	
		/**
		 * This template is used for rendering a profile in the results list of a
		 * ncselect2 component.
		 */
		_profileTemplate: {
			default: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-profile' ).innerHTML ) ),
			selected: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-selected-profile' ).innerHTML ) )
		},
	
		/**
		 * This template is used for rendering a target in the results list of a
		 * ncselect2 component.
		 */
		_targetTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-target' ).innerHTML ) ),
	
		/**
		 * Helper variable that might contain the target name that was selected in
		 * the model related to this view.
		 */
		_previousTargetName: '',
	
		/**
		 * Whether the ncselect2 component for changing the target is ready or not.
		 */
		_targetDataLoader: undefined,
	
		/**
		 * Whether this view has already been rendered or not.
		 */
		_rendered: false,
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'change select.nc-profile': '_changeProfile',
			'change select.nc-target': '_changeTarget'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Prepare hooks.
			this.render = _.bind( this.render, this );
			this.listenTo( this.model, 'change:profileId', this._changeSelectedProfile );
			this.listenTo( this.model, 'change:profileId', this._fixTargetSelectorVisibility );
	
		},//end initialize()
	
		/**
		 * Renders this view just one time. If the function is called again and the
		 * view was already rendered, old HTML content is returned.
		 *
		 * @return {SocialMessagePreview} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// We make sure that the view is rendered only once.
			if ( this._rendered ) {
				return this;
			}//end if
	
			this._rendered = true;
	
			// We initialize the profile ncselect2 component.
			var $profileContainer = jQuery( '<div class="nc-profile-container"></div>' );
			var $profileSelector = jQuery( '<select class="nc-profile" name="profile"></select>' );
			$profileContainer.html( $profileSelector );
			this.$el.html( $profileContainer );
	
			var view = this;
			$profileSelector.ncselect2({
	
				dropdownCssClass: 'nc-ncselect2-above-jquery-dialog',
				data: NelioContent.profiles.toJSON(),
				width: '100%',
	
				matcher: function( term, profile ) {
					if ( typeof term !== 'object' || typeof term.term !== 'string' ) {
						return profile;
					}//end if
					term = term.term;
					var value = profile.displayName + ' ' + profile.username;
					if ( value.toLowerCase().indexOf( term.toLowerCase() ) !== -1 ) {
						profile = _( profile ).clone();
						profile.displayNameEscaped = NelioContent.helpers.strongify( _.escape( profile.displayName ), term );
						profile.usernameEscaped = NelioContent.helpers.strongify( _.escape( profile.username ), term );
						return profile;
					} else {
						return null;
					}//end if
				},
	
				templateResult: function( profile ) {
					if ( typeof profile.displayName === 'undefined' ) {
						return profile.text;
					}
					return $( view._profileTemplate.default( profile ) );
				},
	
				templateSelection: function( profile ) {
					return $( view._profileTemplate.selected( profile ) );
				}
	
			});
	
			$profileSelector.val( this.model.get( 'profileId' ) ).trigger( 'change' );
	
			// We initialize the target ncselect2 component.
			var $targetContainer = jQuery( '<div class="nc-target-container"></div>' );
			var $targetSelector = jQuery( '<select class="nc-target" name="target"></select>' );
			$targetContainer.html( $targetSelector );
	
			$targetSelector.hide();
			this.$el.append( $targetContainer );
			this._fixTargetSelectorVisibility();
	
			return this;
	
		},//end render()
	
		/**
		 * This function locks all inputs in this view.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
			this.$( 'select.nc-profile' ).prop( 'disabled', true );
			this.$( 'select.nc-target' ).prop( 'disabled', true );
	
		},//end lock()
	
		/**
		 * This callback changes the profile related to the social message.
		 *
		 * @since 1.0.0
		 */
		_changeProfile: function() {
	
			this.stopListening( this.model, 'change:profileId', this._changeSelectedProfile );
	
			// Find the profile and the network.
			var profile = NelioContent.profiles.get( NelioContent.helpers.trim( this.$( 'select.nc-profile' ).val() ) );
			if ( typeof profile !== 'undefined' ) {
				this.model.set( 'profileId', profile.get( 'id' ) );
			}//end if
	
			this.listenTo( this.model, 'change:profileId', this._changeSelectedProfile );
	
			this._maybeFixNewMessageInfo();
	
		},//end _changeProfile()
	
		/**
		 * This callback changes the concrete target in which the message will be shared,
		 * assuming the currently-selected profile has multiple targets.
		 *
		 * @since 1.0.0
		 */
		_changeTarget: function() {
	
			var $targetSelector = this.$( 'select.nc-target' );
	
			var selectedTarget = $targetSelector.val();
			var targets = $targetSelector.ncselect2( 'data' );
	
			var target = _.findWhere( targets, { id: selectedTarget } );
			if ( typeof target !== 'undefined' ) {
				this.model.set( 'targetName', target.name );
				this.model.set( 'targetDisplayName', target.displayName );
			} else {
				this.model.set( 'targetName', 'default' );
				this.model.set( 'targetDisplayName', '' );
			}//end if
	
			this._maybeFixNewMessageInfo();
	
		},//end _changeTarget()
	
		/**
		 * This callback "redraws" the ncselect2 component when the profile has been
		 * changed.
		 *
		 * @since 1.0.0
		 */
		_changeSelectedProfile: function() {
	
			this.stopListening( this.model, 'change:profileId', this._changeSelectedProfile );
			this.$( 'select' ).val( this.model.get( 'profileId' ) ).trigger( 'change' );
			this.listenTo( this.model, 'change:profileId', this._changeSelectedProfile );
	
		},//end _changeSelectedProfile()
	
		/**
		 * Callback function that shows or hides the target selector, depending on
		 * the currently-selected social profile.
		 *
		 * @since 1.0.0
		 */
		_fixTargetSelectorVisibility: function() {
	
			if ( ! this._rendered ) {
				return;
			}//end if
	
			// Destroy old selector.
			var $targetSelector = this.$( '.nc-target' );
			$targetSelector.ncselect2();
			$targetSelector.ncselect2( 'destroy' );
	
			// Cancel old requests.
			if ( typeof this._targetDataLoader !== 'undefined' ) {
	
				if ( typeof this._targetDataLoader.abort === 'function' ) {
					this._targetDataLoader.abort();
				}//end if
	
				this._targetDataLoader = undefined;
	
			}//end if
	
			// Create the new sleector if required.
			var profile = NelioContent.profiles.get( this.model.get( 'profileId' ) );
			if ( profile.allowsMultiTargets() ) {
	
				var networkMeta = _.findWhere( NelioContent.networkMetas, {
					id: this.model.get( 'network' )
				});
	
				var view = this;
	
				// Create the selector with no value, so that a "Loading" placeholder is shown.
				$targetSelector.val( '' );
				$targetSelector.ncselect2({
					placeholder: networkMeta.multiTargetLabels.loading,
					width: '100%'
				});
	
				// Run an AJAX request to load boards.
				this._targetDataLoader = $.ajax({
	
					url: NelioContent.apiUri + '/profile/' + profile.get( 'id' ) + '/targets',
					method: 'GET',
					headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },
	
					success: function( targets ) {
						view._buildTargetSelector( targets );
						view._targetDataLoader = undefined;
					},//end success()
	
					error: function() {
						view._targetDataLoader = undefined;
					}//end success()
	
				});
	
				// Leave the model as "incomplete", so that the "Save" button becomes disabled.
				this._previousTargetName = this.model.get( 'targetName' );
				this.model.set( 'targetName', '' );
				this.model.set( 'targetDisplayName', '' );
	
			} else {
	
				this.model.set( 'targetName', 'default' );
				this.model.set( 'targetDisplayName', '' );
	
			}//end if
	
		},//end _fixTargetSelectorVisibility()
	
		/**
		 * Helper function that builds a select2 component to select targets.
		 *
		 * @param targets {array} list of targets to "feed" the select2 component.
		 *
		 * @since 1.0.0
		 */
		_buildTargetSelector: function( targets ) {
	
			var $targetSelector = this.$( '.nc-target' );
			var that = this;
	
			$targetSelector.ncselect2({
	
				dropdownCssClass: 'nc-ncselect2-above-jquery-dialog',
				width: '100%',
				data: targets,
	
				matcher: function( term, target ) {
					if ( typeof term !== 'object' || typeof term.term !== 'string' ) {
						return target;
					}//end if
					term = term.term;
					if ( target.displayName.toLowerCase().indexOf( term.toLowerCase() ) !== -1 ) {
						target = _( target ).clone();
						target.displayNameEscaped = NelioContent.helpers.strongify( target.displayName, term );
						return target;
					} else {
						return null;
					}//end if
				},
	
				templateResult: function( target ) {
					if ( typeof target.displayName === 'undefined' ) {
						return target.text;
					}
					if ( typeof target.displayNameEscaped === 'undefined' ) {
						target.displayNameEscaped = _.escape( target.displayName );
					}//end if
					return $( that._targetTemplate( target ) );
				},
	
				templateSelection: function( target ) {
					if ( typeof target.displayName !== 'undefined' &&
					     typeof target.displayNamedEscaped === 'undefined' ) {
						target.displayNameEscaped = _.escape( target.displayName );
					}//end if
					return $( that._targetTemplate( target ) );
				}
	
			});
	
			if ( targets.length <= 0 ) {
				return;
			}//end if
	
			// Selector the default target (by default, the previously selected one).
			var defaultTarget = targets[0];
			var candidate = _.findWhere( targets, { name: this._previousTargetName } );
			if ( typeof candidate !== 'undefined' ) {
				defaultTarget = candidate;
			}//end if
	
			$targetSelector.val( defaultTarget.id ).trigger( 'change' );
	
			this._previousTargetName = '';
	
		},//end _buildTargetSelector()
	
		/**
		 * Updates the `profiles` attribute of the related model based on the current selection.
		 *
		 * In principle, single profile selectors are only used when editing existing
		 * social messages. However, they're also used when we're creating new social
		 * messages and the user configured one social profile only. In those "rare" cases,
		 * a target selector component might be added (depending on the social profile's
		 * network).
		 *
		 * @since 1.0.0
		 */
		_maybeFixNewMessageInfo: function() {
	
			if ( ! this.model.isNew() ) {
				return;
			}//end if
	
			this.model.set( 'profiles', [{
				id: this.model.get( 'profileId' ),
				targetName: this.model.get( 'targetName' ),
				targetDisplayName: this.model.get( 'targetDisplayName' )
			}]);
	
		},//end _maybeFixNewMessageInfo()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Destroy ncselect2 components.
			if ( this._rendered ) {
	
				this.$( 'select.nc-profile' ).ncselect2( 'destroy' );
	
				this.$( 'select.nc-target' ).ncselect2();
				this.$( 'select.nc-target' ).ncselect2( 'destroy' );
	
			}//end if
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SingleProfileSelector
	
	
	/**
	 * This view permits users to select multiple social profiles at the same time.
	 *
	 * In principle, it should only be used when creating new social messages, as it
	 * helps to create the same message for different profiles at the same time.
	 *
	 * When editing a social message, `SingleProfileSelector` should be used.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @abstract
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.MultipleProfileSelector = Backbone.View.extend({
	
		/**
		 * List of disabled profile IDs (that is, profiles the user can't select).
		 */
		_disabledProfileIds: [],
	
		/**
		 * Whether this subview is locked or not.
		 */
		_isLocked: false,
	
		/**
		 * An underscore template for rendering a single social profile in a given
		 * network.
		 */
		_profileTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-multiple-profile-selector-profile' ).innerHTML ) ),
	
		/**
		 * An array of key, value pairs, where each key is a network name (i.e.
		 * "twitter" or "facebook") and its value is the number of selected profiles
		 * in that network.
		 */
		_availableSocialNetworks: [],
	
		/**
		 * A string that specifies the currently-active network.
		 */
		_activeNetwork: 'none',
	
		/**
		 * Child view for selecting targets.
		 */
		_targetSelectorDialog: undefined,
	
		/**
		 * The underscore template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-multiple-profile-selector' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'click .nc-available-networks .nc-network': '_changeNetwork',
			'click .nc-profiles .nc-profile:not( .nc-disabled )': '_onProfileClicked'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function( options ) {
	
			// Prepare options object.
			if ( typeof options === 'undefined' ) {
				options = {};
			}//end if
	
			// Create a list of networks and highlight already selected networks.
			_.each( NelioContent.profiles.pluck( 'network' ), function( network ) {
				this._availableSocialNetworks[ network ] = 0;
			}, this );
	
			_.each( this.model.get( 'profiles' ), function( idAndTarget ) {
				var id = idAndTarget.id;
				var profile = NelioContent.profiles.get( id );
				if ( typeof profile === 'undefined' ) {
					return;
				}//end if
				if ( typeof this._availableSocialNetworks[ profile.get( 'network' ) ] === 'undefined' ) {
					this._availableSocialNetworks[ profile.get( 'network' ) ] = 0;
				}//end if
				this._availableSocialNetworks[ profile.get( 'network' ) ] += 1;
			}, this );
	
			// Decide which network has to be visible by default...
			this._activeNetwork = NelioContent.profiles.at( 0 ).get( 'network' );
			_.every( NelioContent.profiles.pluck( 'network' ), function( network ) {
	
				// If we found an "active" social network", don't look at the others.
				if ( this._availableSocialNetworks[ network ] > 0 ) {
					this._activeNetwork = network;
					return false;
				} else {
					return true;
				}//end if
	
			}, this );
	
			// ...and use one of its profiles for rendering.
			this.model.set( 'profileId', this._findBestProfileInNetwork( this._activeNetwork ).get( 'id' ) );
	
			// Prepare hooks.
			this.render = _.bind( this.render, this );
			this.listenTo( this, 'nc:change:selectedProfile', this.render );
			this.listenTo( this, 'nc:change:activeNetwork', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {SocialMessagePreview} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			this.$el.find( '.nc-profile.nc-disabled' ).tooltip( 'destroy' );
	
			this.el.innerHTML = this.template();
	
			// Create a list with available networks.
			var $availableNetworks = this.$( '.nc-available-networks' );
			for ( var network in this._availableSocialNetworks ) {
	
				if ( ! this._availableSocialNetworks.hasOwnProperty( network ) ) {
					continue;
				}//end if
	
				// Create the network node.
				var $network = $( '<div class="nc-network nc-status"></div>' );
				$network.data( 'network', network );
				$network.addClass( 'nc-' + network );
				$availableNetworks.append( $network );
	
				// Highlight this network if one of its profiles is selected.
				if ( this._availableSocialNetworks[ network ] > 0 ) {
					$network.addClass( 'nc-selected' );
				}//end if
	
				// Mark this network as active if necessary.
				if ( network === this._activeNetwork ) {
					$network.addClass( 'nc-active' );
				}//end if
	
			}//end for
	
			// Render each individual profile.
			var $profileHolder = this.$( '.nc-profiles' );
	
			// Render all profiles in the currently-active network.
			var disabledProfileIds = this._disabledProfileIds;
			var profiles = NelioContent.profiles.where({ network: this._activeNetwork });
	
			_.each( profiles, function( profile ) {
	
				var data = profile.toJSON();
				data.disabled = _.contains( disabledProfileIds, profile.get( 'id' ) );
				data.allowsMultiTargets = profile.allowsMultiTargets();
	
				// If the network allows multi targets, let's count how many targets are
				// already selected.
				if ( profile.allowsMultiTargets() ) {
	
					data.allowsMultiTargets = true;
					data.targetCount = _.filter(
						_.pluck( this.model.get( 'profiles' ), 'id' ),
						function ( id ) { return id === profile.get( 'id' ); }
					).length;
	
					if ( data.targetCount > 9 ) {
						data.targetCount = '9-plus';
					}//end if
	
					data.selected = ( data.targetCount > 0 );
	
				} else {
	
					data.selected = _.contains(
						_.pluck( this.model.get( 'profiles' ), 'id' ),
						profile.get( 'id' )
					);
	
				}//end if
	
				$profileHolder.append( $( this._profileTemplate( data ) ) );
	
			}, this );
	
			this.$el.find( '.nc-profile.nc-disabled' ).tooltip({
				position: { my: 'left bottom', at: 'right-5 top+5' },
				tooltipClass: 'nc_tooltip nc_warning_tooltip',
				show: false,
				hide: false
			});
	
			return this;
	
		},//end render()
	
		/**
		 * This function locks all inputs in this view.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
	
		},//end lock();
	
		/**
		 * This function disables the given profiles, so that the user can't select
		 * them for scheduling new social messages.
		 *
		 * @param profileIds array List of profiles that can no longer be used.
		 *
		 * @since 1.0.0
		 */
		disableProfiles: function( profileIds ) {
	
			this._disabledProfileIds = profileIds;
	
		},//end disableProfiles()
	
		/**
		 * This callback changes the currently-active network and, hence, the set of
		 * social profiles that are visible.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_changeNetwork: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			// Get the concrete tab the user clicked on.
			var target = ev.target || ev.srcElement;
			var $el = $( target ).closest( '.nc-network' );
	
			var network = $el.data( 'network' );
			if ( network !== this._activeNetwork ) {
	
				// Change active network.
				this._activeNetwork = network;
				this.trigger( 'nc:change:activeNetwork' );
	
				// Find a new profile to use in preview.
				var candidate = this._findBestProfileInNetwork( network );
				this.model.set( 'profileId', candidate.get( 'id' ) );
	
			}//end if
	
		},//end _changeNetwork
	
		/**
		 * This callback is called when the user clicks on a specific social profile.
		 *
		 * It's used for (un)selecting any given profile. If the clicked profile
		 * allows multiple targets, a dialog will be opened, so that the user can
		 * select which targets are enabled and which aren't. In these cases, profile
		 * selection will depend on the number of targets selected.
		 *
		 * Note that changing the profile to (un)selected may also change the
		 * profile that's used in the preview section.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onProfileClicked: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			// Get the concrete tab the user clicked on.
			var target = ev.target || ev.srcElement;
			var $el = $( target ).closest( '.nc-profile' );
	
			// Find the clicked profile.
			var profile = NelioContent.profiles.get( $el.data( 'profile' ) );
	
			// Check if it allows multi targets or not.
			if ( profile.allowsMultiTargets() ) {
				this._selectTargets( profile );
			} else {
				this._toggleProfileSelection( profile );
			}//end if
	
		},//end _onProfileClicked()
	
		/**
		 * Opens a dialog for selecting targets of the given social profile.
		 *
		 * The function also sets a couple of listeners to this dialog, so that the
		 * model can be updated with new targets when the dialog is closed.
		 *
		 * @param profile {SocialProfile} The social profile the user clicked on.
		 *
		 * @since 1.0.0
		 */
		_selectTargets: function( profile ) {
	
			// Create target selector view.
			this._targetSelectorDialog = new NelioContent.views.TargetSelector({
				model: profile
			});
	
			// Specify which targets are already selected in the given profile.
			var profilesWithTarget = _.where( this.model.get( 'profiles' ), { id: profile.get( 'id' ) } );
			this._targetSelectorDialog.setOriginalSelection( _.pluck( profilesWithTarget, 'targetName' ) );
	
			var view = this;
	
			// Update the list of selected profiles.
			this.listenTo( this._targetSelectorDialog, 'nc:update:targets', function( targets ) {
	
				var oldSelection = _( this.model.get( 'profiles' ) ).clone();
	
				// Remove references to old targets.
				var newSelection = [];
				_.each( oldSelection, function( el ) {
					if ( el.id !== profile.get( 'id' ) ) {
						newSelection.push( el );
					}//end if
				});
	
				// Add the new targets.
				_.each( targets, function( target ) {
					newSelection.push({
						id: profile.get( 'id' ),
						targetName: target.name,
						targetDisplayName: target.displayName
					});
				});
	
				// Finally, update the selected profile list and the preview element.
				view.model.set( 'profiles', newSelection );
				view._selectProfileForPreview( profile );
	
			});
	
			// Destroy the view when closing the dialog.
			this.listenTo( this._targetSelectorDialog, 'nc:close:dialog', function() {
				view.stopListening( view._targetSelectorDialog );
				view._targetSelectorDialog.close();
				view._targetSelectorDialog = undefined;
			});
	
			// Specify which targets are already selected in the given profile.
			this._targetSelectorDialog.openDialog();
	
		},//_selectTargets()
	
		/**
		 * This helper function toggles the selection of a given profile. We assume
		 * the profile does not allow multi targets.
		 *
		 * @param profile {SocialProfile} The social profile the user clicked on.
		 *
		 * @since 1.0.0
		 */
		_toggleProfileSelection: function( profile ) {
	
			// Toggle selection.
			var selectedProfileIds = _( this.model.get( 'profiles' ) ).clone();
			var selected = _.contains(
				_.pluck( selectedProfileIds, 'id' ),
				profile.get( 'id' )
			);
	
			if ( selected ) {
	
				var objectToRemove = _.filter( selectedProfileIds, function( o ) {
					return o.id === profile.get( 'id' );
				});
	
				if ( objectToRemove.length > 0 ) {
					objectToRemove = objectToRemove[0];
					selectedProfileIds = _.without( selectedProfileIds, objectToRemove );
				}//end if
	
			} else {
	
				selectedProfileIds.push({
					id: profile.get( 'id' ),
					targetName: 'default',
					targetDisplayName: ''
				});
	
			}//end if
	
			// Finally, update the selected profile list and the preview element.
			this.model.set( 'profiles', selectedProfileIds );
			this._selectProfileForPreview( profile );
	
		},//end _toggleProfileSelection()
	
	
		/**
		 * This helper function determines whether the clicked profile should be used
		 * in the preview or not.
		 *
		 *  * When selecting a new profile, this new profile is the one we use for
		 *    the preview.
		 *  * When deselecting the profile, if the deselected profile was the one
		 *    the social message had (and hence the one we used for previews), the
		 *    function looks for a new profile.
		 *
		 * @param profile {SocialProfile} The social profile the user has clicked.
		 *
		 * @since 1.0.0
		 */
		_selectProfileForPreview: function( profile ) {
	
			// Update available networks information.
			var selectedProfileIds = this.model.get( 'profiles' );
			var selectedProfilesInNetwork = NelioContent.profiles.filter( function( candidate ) {
				return candidate.get( 'network' ) === profile.get( 'network' ) && _.contains(
					_.pluck( selectedProfileIds, 'id' ),
					candidate.get( 'id' )
				);
			});
			this._availableSocialNetworks[ profile.get( 'network' ) ] = selectedProfilesInNetwork.length;
	
			// Decide the profile that will be used in the preview area.
			var ids = _.pluck( this.model.get( 'profiles' ), 'id' );
			if ( _.contains( ids, profile.get( 'id' ) ) ) {
	
				// If we activated this profile, we should use it in the preview.
				this.model.set( 'profileId', profile.get( 'id' ) );
	
			} else {
	
				// If the profile we were using in the preview was the one we just
				// unselected, we need to find a new one.
				if ( this.model.get( 'profileId' ) === profile.get( 'id' ) ) {
	
					// Use the candidate profile in preview.
					var candidate = this._findBestProfileInNetwork( profile.get( 'network' ) );
					this.model.set( 'profileId', candidate.get( 'id' ) );
	
				}//end if
	
			}//end if
	
			// Trigger a change.
			this.trigger( 'nc:change:selectedProfile' );
	
		},//end _selectProfileForPreview()
	
		/**
		 * This function returns the best profile available, given a certain network.
		 *
		 * If the network has at least one selected profile, the function will return
		 * that one. If it doesn't, any profile will work.
		 *
		 * @since 1.0.0
		 */
		_findBestProfileInNetwork: function( network ) {
	
			var selectedProfileIds = _.pluck( this.model.get( 'profiles' ), 'id' );
			var candidates = NelioContent.profiles.filter( function( candidate ) {
				return candidate.get( 'network' ) === network && _.contains( selectedProfileIds, candidate.get( 'id' ) );
			});
	
			var candidate = candidates[0];
			if ( typeof candidate === 'undefined' ) {
				candidate = NelioContent.profiles.findWhere({ network : network });
			}//end if
	
			return candidate;
	
		},//end _findBestProfileInNetwork()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class MultipleProfileSelector
	
	

	// Previews
	// --------

	/**
	 * This class processes a social message and renders it using the template of
	 * an implementing view. In particular, it beautifies all links and hashtags
	 * that might appear in the message and, should the resulting message be too
	 * long, shortens it.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @abstract
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SocialMessagePreview = Backbone.View.extend({
	
		/**
		 * Some basic information about the social profile that will be used for
		 * sharing the message. These values are needed for previewing the social
		 * message properly.
		 */
		_profileInformation: {
				displayName: 'David Aguilera',
				firstLetter: 'd',
				username: '@davilera, Nelio Software',
				photo: 'https://twitter.com/davilera/profile_image'
		},
	
		/**
		 * This private variable holds information about the first link included in
		 * the social message (or the related WordPress post, if any).
		 *
		 * The most important attributes here are:
		 *
		 *  * status   {string} It can either be `invalid` (if shared link's
		 *               information is not correct), `loading` (if information is
		 *               being retrieved from an external service), `ready` (if all
		 *               the data is correct), or `error` (if something went wrong in
		 *               the last update).
		 *  * _isBasedOnTheRelatedPost {boolean} Whether we're sharing the related post
		 *               or another link.
		 */
		_sharedLinkInformation: {
			title: '',
			excerpt: '',
			permalink: '',
			domain: '',
			date: false,
			author: '',
			image: '',
			status: 'invalid',
			_ajaxRequest: undefined,
			_isBasedOnTheRelatedPost: false
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Prepare render function and set the current social profile.
			this.render = _.bind( this.render, this );
			this._getUrlMetaData = _.bind( this._getUrlMetaData, this );
	
			// Listen to relevant events.
			this.listenTo( this, 'nc:getUrlMetaData', _.debounce( this._getUrlMetaData, 300 ) );
			this.listenTo( this, 'nc:change:sharedLink', this.render );
			this.listenTo( this.model, 'change', this.render );
			this.listenTo( this.model, 'change:profileId', this._updateProfileInformation );
	
			// Make sure that the shared link information is always up-to-date.
			this.listenTo( this.model, 'change:url', this._maybeObtainSharedLinkInformation  );
	
			this._sharedLinkInformation.permalink = '';
			this._sharedLinkInformation.status = 'invalid';
			this._updateProfileInformation();
			this._maybeObtainSharedLinkInformation();
	
	
		},//end initialize()
	
		/**
		 * Renders this view, overwritting any previous HTML elements.
		 *
		 * @return {SocialMessagePreview} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			var data = this.model.toJSON();
			data.textFormatted = this._beautifyLinks( this.model.getHighlightedText() );
			data.profile = this._profileInformation;
			data.sharedLink = this._sharedLinkInformation;
	
			if ( 0 === this.model.get( 'postId' ) || this.model.post.isPublished() || this.model.post.isScheduled() ) {
				data.dateFormatted = this.formatDate( this.model.get( 'schedule' ) );
			} else if ( this.model.get( 'dateType' ) === 'exact' && /[12][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]/.test( this.model.get( 'dateValue' ) ) ) {
				var date = this.model.get( 'dateValue' ) + ' ' + this.model.get( 'timeValue' );
				date = ncNewLocalMoment( date );
				data.dateFormatted = this.formatDate( date );
			} else {
				data.dateFormatted = NelioContent.i18n.someday;
			}//end if
	
			this.el.innerHTML = this.template( data );
	
			return this;
	
		},//end render()
	
		/**
		 * This function returns the link as it is.
		 *
		 * In principle, any child view is supposed to override it, so that links can
		 * look like as they're supposed to. One coud see this function as abstract,
		 * but we included a default implementation to prevent the code from failing.
		 *
		 * @param link {string} the link that has to be adapted to this network.
		 *
		 * @return {string} the beautified version of the given link.
		 *
		 * @since 1.0.0
		 */
		beautifyLink: function( link ) {
	
			return link;
	
		},//end beautifyLink()
	
		/**
		 * Returns a string representation of the given date.
		 *
		 * In principle, any child view is supposed to override it, so that dates can
		 * look like as they're supposed to. One coud see this function as abstract,
		 * but we included a default implementation to prevent the code from failing.
		 *
		 * @param date {object} A momentjs object with the social message's date.
		 *
		 * @return {string} A string representation of the given date.
		 *
		 * @since 1.0.0
		 */
		formatDate: function( date ) {
	
			return date.format( 'YYYY-MM-DD h:mm a' );
	
		},//end formatDate()
	
		/**
		 * This helper function extracts all links in the message and adapts them to the
		 * specific preview using `beautifyLink`.
		 *
		 * @param text {string} the text whose links have to be modified.
		 *
		 * @return {string} the original text with its links "beautified".
		 *
		 * @since 1.0.3
		 */
		_beautifyLinks: function( text ) {
	
			var matches, link;
			matches = _.uniq( text.match( /"nc-link">[^<]+</g ) );
			for ( var i = 0; i < matches.length; ++i ) {
				link = matches[ i ].replace( '"nc-link">', '' ).replace( '<', '' );
				text = text.replace( matches[ i ], '"nc-link">' + this.beautifyLink( link ) + '<' );
			}//end for
	
			return text;
	
		},//end _beautifyLinks
	
		/**
		 * This callback updates the profile information that we use based on the
		 * currently selected profile.
		 *
		 * @since 1.0.0
		 */
		_updateProfileInformation: function() {
	
			// Find the currently active profile.
			var currentProfile = NelioContent.profiles.get( this.model.get( 'profileId' ) );
	
			// If we didn't find a profile, we'll add some fake data. This should never
			// happen, but it's always nice to have a guard.
			if ( typeof currentProfile === 'undefined' ) {
				currentProfile = NelioContent.profiles.at( 0 );
			}//end if
	
			// Use current profile data in the view.
			this._profileInformation = {
				displayName: currentProfile.get( 'displayName' ),
				firstLetter: currentProfile.get( 'firstLetter' ),
				username: currentProfile.get( 'username' ),
				photo: currentProfile.get( 'photo' )
			};
	
		},//end _updateProfileInformation()
	
		/**
		 * This function updates the status of the shared link to the given value and
		 * it triggers to events:
		 *
		 *  * `nc:change:sharedLink:status`
		 *  * `nc:change:sharedLink`
		 *
		 * @param stat {string} The new status of the shared link.
		 *
		 * @since 1.0.0
		 */
		_setSharedLinkStatus: function( stat ) {
	
			this._sharedLinkInformation.status = stat;
			this.trigger( 'nc:change:sharedLink:status' );
			this.trigger( 'nc:change:sharedLink' );
	
		},//end _setSharedLinkStatus()
	
		/**
		 * This function updates the shared link information so that it shows the
		 * information related to the message's URL attribute. Eventually, the
		 * function might need to trigger an AJAX request (if the URL is not the
		 * related post's), in order to obtain this information from an external
		 * service.
		 *
		 * @since 1.0.0
		 */
		_maybeObtainSharedLinkInformation: function() {
	
			var link = this.model.get( 'url' );
			var post = this.model.post.toJSON();
	
			// Cancel any previous requests
			if ( typeof this._sharedLinkInformation._ajaxRequest !== 'undefined' ) {
				this._sharedLinkInformation._ajaxRequest.abort();
				this._setSharedLinkStatus( 'invalid' );
			}//end if
	
			if ( link.length === 0 ) {
	
				this._sharedLinkInformation.permalink = '';
				this._setSharedLinkStatus( 'invalid' );
	
			} else if ( link === this._sharedLinkInformation.permalink ) {
	
				// I already have what I need.
	
			} else if ( link !== post.permalink || 'error' === this._sharedLinkInformation.status ) {
	
				// If it isn't, we have to ask an external service to look for the data
				// and return it.
				this._setSharedLinkStatus( 'loading' );
				this._sharedLinkInformation._isBasedOnTheRelatedPost = false;
				this.trigger( 'nc:getUrlMetaData', link );
	
			} else if ( link === post.permalink && this.model.get( 'postId' ) === post.id ) {
	
				this._sharedLinkInformation._isBasedOnTheRelatedPost = true;
				var author = NelioContent.users.getUser( post.author );
	
				if ( author.isLoading() ) {
					author.listenToOnce( author, 'nc:load', _.bind( function() {
						this._maybeObtainSharedLinkInformation();
					}, this ) );
				} else {
					post.author = author.get( 'name' );
					if ( typeof post.image === 'undefined' || 0 === post.image.length ) {
						post.image = post.autoImage;
					}//end if
					this._updateSharedLinkInformation( post );
					this._setSharedLinkStatus( 'ready' );
				}//end if
	
			}//end if
	
		},//end _maybeObtainSharedLinkInformation()
	
		/**
		 * This function triggers an AJAX request for recovering meta data about the
		 * given URL.
		 *
		 * @param link {string} the link we're interested in.
		 *
		 * @since 1.1.1
		 */
		_getUrlMetaData: function( link ) {
	
			var view = this;
			this._sharedLinkInformation._ajaxRequest = $.ajax({
	
				url: ajaxurl,
				data: {
					action: 'nelio_content_get_url_meta_data',
					url: link
				},
	
				/**
				 * Updates preview information with the given data.
				 *
				 * @param data {object} Information about the given URL.
				 *
				 * @since 1.0.0
				 */
				success: function( data ) {
	
					data.title = NelioContent.helpers.decodeHTMLEntities( data.title );
					data.excerpt = NelioContent.helpers.decodeHTMLEntities( data.excerpt );
					view._updateSharedLinkInformation( data );
	
					if ( view._sharedLinkInformation.status !== 'error' ) {
						view._setSharedLinkStatus( 'ready' );
					}//end if
	
				},//end success()
	
				/**
				 * Sets the preview object to error.
				 *
				 * @since 1.0.0
				 */
				error: function() {
	
					view._setSharedLinkStatus( 'error' );
	
				}//end error()
	
			});
	
		},//end _getUrlMetaData()
	
		/**
		 * This function updates the information of our shared link and triggers the
		 * `nc:change:sharedLink:*` and `nc:change:sharedLink` events.
		 *
		 * @param info {object} An list of key, value pairs with the new values.
		 *
		 * @since 1.0.0
		 */
		_updateSharedLinkInformation: function( info ) {
	
			if ( typeof info.image === 'undefined' ) {
				info.image = '';
			}//end if
	
			// If the URL wasn't accessible, we set the status to error.
			switch ( info.responseCode ) {
				case 403:
				case 404:
				case 500:
					this._sharedLinkInformation.status = 'error';
					this.trigger( 'nc:change:sharedLink:status' );
					this.trigger( 'nc:change:sharedLink' );
					return;
			}//end switch
	
			// If we weren't able to obtain the title of the page, we set the status to error too.
			if ( typeof info.title === 'undefined' || NelioContent.helpers.trim( info.title ).length === 0 ) {
				this._sharedLinkInformation.status = 'error';
				this.trigger( 'nc:change:sharedLink:status' );
				this.trigger( 'nc:change:sharedLink' );
				return;
			}//end if
	
			// If everything seems to be OK, we move forward.
			var valuesChanged = false;
	
			// Initialize all relevant attributes.
			var keys = [ 'id', 'title', 'excerpt', 'permalink', 'date',
					'author' ];
			_.each( keys, function( key ) {
	
				var val = info[ key ];
				if ( typeof val === 'undefined' ) {
					val = '';
				}//end if
	
				if ( 'excerpt' === key && val.length > 90 ) {
					val = val.substring( 0, 90 ) + '';
				}//end if
	
				if ( this._sharedLinkInformation[ key ] !== val ) {
					this._sharedLinkInformation[ key ] = val;
					this.trigger( 'nc:change:sharedLink:' + key );
					valuesChanged = true;
				}//end if
	
			}, this );
	
			// Let's update the image.
			if ( this._sharedLinkInformation.image !== info.image ) {
	
				this._sharedLinkInformation.image = info.image;
				this.trigger( 'nc:change:sharedLink:image' );
				valuesChanged = true;
	
				// We need to check if the featured image exists. If it doesn't, it'll be
				// better if we "remove" it.
				if ( info.image.length > 0 ) {
	
					var img = new Image();
					var that = this;
					img.onerror = function() {
						if ( view._sharedLinkInformation.image === info.image ) {
							view._sharedLinkInformation.image = '';
							view.trigger( 'nc:change:sharedLink:image' );
							view.trigger( 'nc:change:sharedLink' );
						}//end if
					};//end img.onerror
					img.src = info.image;
	
				}//end if
	
			}//end if
	
			// Let's find the domain.
			if ( typeof info.permalink === 'string' ) {
	
				// Extract domain using the permalink.
				var domain = this._sharedLinkInformation.permalink;
				domain = domain.replace( /^https?:\/\//, '' );
				if ( domain.indexOf( '/' ) > 0 ) {
					domain = domain.substring( 0, domain.indexOf( '/' ) );
				}//end if
	
				if ( domain !== this._sharedLinkInformation.domain ) {
						this._sharedLinkInformation.domain = domain;
						this.trigger( 'nc:change:sharedLink:domain' );
						valuesChanged = true;
				}//end if
	
			}//end if
	
			if ( valuesChanged ) {
				this.trigger( 'nc:change:sharedLink' );
			}//end if
	
		},//end _updateSharedLinkInformation()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SocialMessagePreview
	
	
	/**
	 * This class is used for previewing a social message using Facebook's look and
	 * feel.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.FacebookPreview = NelioContent.views.SocialMessagePreview.extend({
	
		/**
		 * An underscore template with Facebook's look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-facebook-preview' ).innerHTML ) ),
	
		/**
		 * When sharing a link via Facebook, Facebook only shows its domain plus a
		 * few additional characters. This function shortens the link appropriately
		 * and adds ellipsis when needed.
		 *
		 * @param link {string} the link that has to be adapted to this network.
		 *
		 * @return {string} the beautified version of the given link.
		 *
		 * @override
		 * @since 1.0.0
		 */
		beautifyLink: function( link ) {
	
			if ( link.length > 60 ) {
				if ( link[link.length - 1] === '/' ) {
					link = link.substring( 0, 58 ) + '' + '/';
				} else {
					link = link.substring( 0, 59 ) + '';
				}
			}
	
			return link;
	
		},//end beautifyLink()
	
		/**
		 * Returns a string representation of the given date, as used in Facebook.
		 *
		 * @param date {object} A momentjs object with the social message's date.
		 *
		 * @return {string} A string representation of the given date, as used in
		 *                  Facebook.
		 *
		 * @override
		 * @since 1.0.0
		 */
		formatDate: function( date ) {
	
			return date.format( NelioContent.i18n.previewDates.facebook );
	
		}//end formatDate()
	
	});//class FacebookPreview
	
	
	/**
	 * This class is used for previewing a social message using Google+' look
	 * and feel.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.GooglePlusPreview = NelioContent.views.SocialMessagePreview.extend({
	
		/**
		 * An underscore template with Google+' look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-googleplus-preview' ).innerHTML ) ),
	
		/**
		 * When sharing a link via Google+, only its domain is visible. This function
		 * extracts the domain of the given link and returns it as its beautified
		 * version.
		 *
		 * @param link {string} the link that has to be adapted to this network.
		 *
		 * @return {string} the beautified version of the given link.
		 *
		 * @override
		 * @since 1.0.0
		 */
		beautifyLink: function( link ) {
	
			link = link.replace( /https?:\/\//, '' );
			var slash = link.indexOf( '/' );
			if ( slash !== -1 ) {
				link = link.substring( 0, slash );
			}
			return link;
	
		},//end beautifyLink()
	
		/**
		 * Returns a string representation of the given date, as used in Google+.
		 *
		 * @param date {object} A momentjs object with the social message's date.
		 *
		 * @return {string} A string representation of the given date, as used in
		 *                  Google+.
		 *
		 * @override
		 * @since 1.0.0
		 */
		formatDate: function( date ) {
	
			return date.format( NelioContent.i18n.previewDates.googleplus );
	
		}//end formatDate()
	
	});//class GooglePlusPreview
	
	
	/**
	 * This class is used for previewing a social message using LinkedIn's look and
	 * feel.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.LinkedInPreview = NelioContent.views.SocialMessagePreview.extend({
	
		/**
		 * This private variable contains a list of pairs: the original URL and a
		 * shorter version that mimics the results of LinkedIn's URL shortener
		 * service (i.e. https://lnkin.com/xxxxxxx).
		 */
		_links: {},
	
		/**
		 * An underscore template with LinkedIn's look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-linkedin-preview' ).innerHTML ) ),
	
		/**
		 * When sharing a link via LinkedIn, LinkedIn shortens it. This function
		 * simulates the behavior of LinkedIn's URL shortener.
		 *
		 * @param link {string} the link that has to be adapted to this network.
		 *
		 * @return {string} the beautified version of the given link.
		 *
		 * @override
		 * @since 1.0.0
		 */
		beautifyLink: function( link ) {
	
			if ( typeof this._links[link] === 'undefined' ) {
	
				// Generate a "random" lnkd.in link.
				var newLink = 'https://lnkd.in/';
				var r1 = Math.floor( Math.random() * 10 );
				var r2 = Math.floor( Math.random() * 10 );
	
				var option = Math.floor( Math.random() * 10 );
				if ( option < 3 ) {
					newLink += r1 + 'n3Li' + r2 + 'o';
				} else if ( option < 5 ) {
					newLink += 'D4' + r1 + 'vid' + r2;
				} else if ( option < 7 ) {
					newLink += r1 + 'toNI' + r2 + 'v';
				} else {
					newLink += 'ru' + r1 + r2 + 'Th' + r1;
				}
	
				this._links[link] = newLink;
	
			}
	
			return this._links[link];
	
		},//end beautifyLink()
	
		/**
		 * Returns a string representation of the given date, as used in LinkedIn.
		 *
		 * @param date {object} A momentjs object with the social message's date.
		 *
		 * @return {string} A string representation of the given date, as used in
		 *                  LinkedIn.
		 *
		 * @override
		 * @since 1.0.0
		 */
		formatDate: function( date ) {
	
			return date.format( NelioContent.i18n.previewDates.googleplus );
	
		},//end formatDate()
	
	});//class LinkedInPreview
	
	
	/**
	 * This class is used for previewing a social message using Pinterest' look
	 * and feel.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.PinterestPreview = NelioContent.views.SocialMessagePreview.extend({
	
		/**
		 * An underscore template with Pinterest' look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-pinterest-preview' ).innerHTML ) ),
	
		/**
		 * When sharing a link via Pinterest, only its domain is visible. This function
		 * extracts the domain of the given link and returns it as its beautified
		 * version.
		 *
		 * @param link {string} the link that has to be adapted to this network.
		 *
		 * @return {string} the beautified version of the given link.
		 *
		 * @override
		 * @since 1.0.0
		 */
		beautifyLink: function( link ) {
	
			link = link.replace( /https?:\/\//, '' );
			var slash = link.indexOf( '/' );
			if ( slash !== -1 ) {
				link = link.substring( 0, slash );
			}
			return link;
	
		},//end beautifyLink()
	
		/**
		 * Returns a string representation of the given date, as used in Pinterest.
		 *
		 * @param date {object} A momentjs object with the social message's date.
		 *
		 * @return {string} A string representation of the given date, as used in
		 *                  Pinterest.
		 *
		 * @override
		 * @since 1.0.0
		 */
		formatDate: function( date ) {
	
			return date.format( NelioContent.i18n.previewDates.pinterest );
	
		}//end formatDate()
	
	});//class PinterestPreview
	
	
	/**
	 * This class is used for previewing a social message using Twitter's look and
	 * feel.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.TwitterPreview = NelioContent.views.SocialMessagePreview.extend({
	
		/**
		 * An underscore template with Twitter's look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-twitter-preview' ).innerHTML ) ),
	
		/**
		 * When sharing a link via Twitter, Twitter only shows its domain plus a few
		 * additional characters. This function shortens the link appropriately and
		 * adds ellipsis when needed.
		 *
		 * @param link {string} the link that has to be adapted to this network.
		 *
		 * @return {string} the beautified version of the given link.
		 *
		 * @override
		 * @since 1.0.0
		 */
		beautifyLink: function( link ) {
	
			link = link.replace( /https?:\/\//, '' );
			var slash = link.indexOf( '/' );
			if ( slash !== -1 ) {
				var end = slash + 15;
				if ( end < link.length ) {
					link = link.substring( 0, end ) + '';
				}
			}
			return link;
	
		},//end beautifyLink()
	
		/**
		 * Returns a string representation of the given date, as used in Twitter.
		 *
		 * @param date {object} A momentjs object with the social message's date.
		 *
		 * @return {string} A string representation of the given date, as used in
		 *                  Twitter.
		 *
		 * @override
		 * @since 1.0.0
		 */
		formatDate: function( date ) {
	
			if ( this.model.get( 'timeType' ) === 'time-interval' ) {
				return date.format( NelioContent.i18n.previewDates.twitterNoTime );
			} else {
				return date.format( NelioContent.i18n.previewDates.twitter );
			}//end if
	
		}//end formatDate()
	
	});//class TwitterPreview
	
	

	// "Generic" selectors
	// ----------------------

	/**
	 * This view can be attached to any model that has the attributes `dateType` and `dateValue`.
	 *
	 * Examples of these models are a social message or a task. The concrete
	 * meaning of a date depends on the model ("publication date" for social
	 * messages, "due date" for tasks). Regardless of the concrete date type and
	 * value, they can be specified as offsets from the current date or the
	 * publication date of a related post.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.DateSelector = Backbone.View.extend({
	
		/**
		 * Whether this subview is locked or not.
		 */
		_isLocked: false,
	
		/**
		 * This view may either use browser's native date picker (if available) or a
		 * jQuery-based date picker. To prevent creating a jQuery date picker
		 * multiple times, we use this boolean variable.
		 */
		_isDatePickerReady: false,
	
		/**
		 * An underscore template with Twitter's look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-date-selector' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'change .nc-value': '_changeDate',
			'keyup  input.nc-value': '_changeDate',
			'click  .nc-change-type': '_changeDateType',
			'click  .nc-datepicker': '_maybeInitDatePicker'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this.listenTo( this.model, 'change:dateType', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {DateSelector} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Destroy old date picker (if any).
			var $datePicker = this.$( '.nc-datepicker' );
			if ( 'date' !== $datePicker.prop( 'type' ) ) {
				$datePicker.datepicker( 'destroy' );
				this._isDatePickerReady = false;
			}//end if
	
			// Render the view.
			var json = this.model.toJSON();
			json.dateOffsetMode = this._getDateOffsetMode();
			this.el.innerHTML = this.template( json );
			this.$( '.nc-value' ).val( this.model.get( 'dateValue' ) );
	
			return this;
	
		},//end render()
	
		/**
		 * This function locks all inputs in this view.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
			this.$( 'input' ).prop( 'disabled', true );
			this.$( 'select' ).prop( 'disabled', true );
	
		},//end lock();
	
		/**
		 * This function selects the date offset mode based on the current context.
		 *
		 * The date offset mode tells our partial which "labels" and "options" should
		 * be used. Thus, for example, if the offset mode is `after-publication`, the
		 * user interface will show options such as "same day as publication", "a
		 * week after publication" or "x days after publication". If, on the other
		 * hand, the mode is "after-now", options are "today", "tomorrow", and so on.
		 *
		 * @return {string} the date offset mode based on the current context.
		 *
		 * @since 1.0.0
		 */
		_getDateOffsetMode: function() {
	
			if ( 0 === this.model.get( 'postId' ) ) {
	
				return 'after-now';
	
			} else {
	
				if ( this.model.post.isPublished() ) {
	
					return 'after-now';
	
				} else {
	
					if ( this.model.get( 'dateType' ) === 'positive-days' ) {
						return 'after-publication';
					}//end if
	
					// Hack to detect whether the related model is a task and, if it is, offer "before-publication" dates
					if ( typeof this.model.get( 'task' ) !== 'undefined' ) {
						return 'before-publication';
					} else {
						return 'after-publication';
					}//end if
	
				}//end if
	
			}//end if
	
		},//end _getDateOffsetMode()
	
		/**
		 * This callback updates the related model's date type and value attributes.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_changeDate: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			var value;
			switch ( $el.data( 'date-type' ) ) {
	
				case 'exact':
					value = $el.val();
					this.model.set( 'dateValue', value );
					break;
	
				case 'negative-days':
					value = $el.val();
					if ( value.length === 0 ) {
						value = '2';
					}//end if
					this.model.set( 'dateValue', value );
					break;
	
				case 'positive-days':
					value = $el.val();
					if ( value.length === 0 ) {
						value = '2';
					}//end if
					this.model.set( 'dateValue', value );
					break;
	
				case 'predefined-offset':
					value = $el.val();
					switch ( value ) {
						case 'positive-days':
						case 'negative-days':
						case 'exact':
							this.model.set({
								'dateType':  value,
								'dateValue': ''
							});
							break;
	
						default:
							this.model.set( 'dateValue', value );
	
					}//end switch
					break;
	
			}//end switch
	
		},//end _changeDate()
	
		/**
		 * This callback reverts the date type and value to default values (that is,
		 * `predefined-offset` and `0`).
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_changeDateType: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			// Hack. We put the date value first, because changing the date type
			// triggers an event for rendering the view.
			this.model.set( 'dateValue', '0' );
			this.model.set( 'dateType', 'predefined-offset' );
	
			return false;
	
		},//end _changeDateType()
	
		/**
		 * This callback checks whether the browser supports native date pickers and,
		 * if it doesn't, it creates a jQuery-based date picker.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_maybeInitDatePicker: function( ev ) {
	
			var $datePicker = this.$( '.nc-datepicker' );
	
			// Create date picker (if required).
			if ( ! this._isDatePickerReady &&
					'exact' === this.model.get( 'dateType' ) &&
					$datePicker.prop( 'type' ) !== 'date' ) {
	
				$datePicker.datepicker({
					dateFormat: 'yy-mm-dd',
					minDate: 0
				});
				$datePicker.datepicker( 'show' );
	
			}//end if
	
			this._isDatePickerReady = true;
	
		},//end _maybeInitDatePicker()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class DateSelector
	
	
	/**
	 * This view can be attached to any model that has the attributes `timeType` and `timeValue`.
	 *
	 * Examples of these models are a social message or a task. The concrete
	 * meaning of time depends on the model (for example, "publication time" for
	 * social messages). Regardless of the concrete time type and value, they can
	 * be specified as offsets from now or the publication date of a related post.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.TimeSelector = Backbone.View.extend({
	
		/**
		 * Whether this subview is locked or not.
		 */
		_isLocked: false,
	
		/**
		 * An underscore template with Twitter's look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-time-selector' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'change .nc-value': '_changeTime',
			'keyup  input.nc-value': '_changeTime',
			'click  .nc-change-type': '_changeTimeType',
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this.listenTo( this.model, 'change:dateType', this._useProperSelector );
			this.listenTo( this.model, 'change:dateValue', this._useProperSelector );
	
			this.listenTo( this.model, 'change:dateType', this.render );
			this.listenTo( this.model, 'change:dateValue', this.render );
			this.listenTo( this.model, 'change:timeType', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {TimeSelector} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			var json = this.model.toJSON();
			json.timeOffsetMode = this._getTimeOffsetMode();
	
			this.el.innerHTML = this.template( json );
			this.$( '.nc-value' ).val( this.model.get( 'timeValue' ) );
	
			return this;
	
		},//end render()
	
		/**
		 * This function locks all inputs in this view.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
			this.$( 'input' ).prop( 'disabled', true );
			this.$( 'select' ).prop( 'disabled', true );
	
		},//end lock();
	
		/**
		 * This function selects the time offset mode based on the current context.
		 *
		 * The time offset mode tells our partial which "labels" and "options" should
		 * be used. Thus, for example, if the offset mode is `after-publication`, the
		 * user interface will show options such as "Same time as publication", "Three
		 * hours after publication" or "x hours after publication". If, on the other
		 * hand, the mode is "after-now", options are "Now", "In one hour", and so on.
		 *
		 * @since 1.0.0
		 */
		_getTimeOffsetMode: function() {
	
			var dateType = this.model.get( 'dateType' );
			var dateValue = this.model.get( 'dateValue' );
	
			if ( 'predefined-offset' === dateType && '0' === dateValue ) {
	
				if ( 0 === this.model.get( 'postId' ) || this.model.post.isPublished() ) {
					return 'after-now';
				} else {
					return 'after-publication';
				}//end if
	
			} else {
	
				return 'time-interval';
	
			}//end if
	
		},//end _getTimeOffsetMode()
	
		/**
		 * This callback updates the related model's time type and value attributes.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_changeTime: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			var value;
			switch ( $el.data( 'time-type' ) ) {
	
				case 'exact':
					value = $el.val();
					this.model.set( 'timeValue', value );
					break;
	
				case 'negative-hours':
					value = $el.val();
					if ( value.length === 0 ) {
						value = '2';
					}//end if
					this.model.set( 'timeValue', '-' + value );
					break;
	
				case 'positive-hours':
					value = $el.val();
					if ( value.length === 0 ) {
						value = '2';
					}//end if
					this.model.set( 'timeValue', value );
					break;
	
				case 'time-interval':
					value = $el.val();
					switch ( value ) {
						case 'exact':
							this.model.set({
								'timeType':  value,
								'timeValue': ''
							});
							break;
	
						default:
							this.model.set( 'timeValue', value );
	
					}//end switch
					break;
	
				case 'predefined-offset':
					value = $el.val();
					switch ( value ) {
						case 'positive-hours':
						case 'negative-hours':
						case 'exact':
							this.model.set({
								'timeType':  value,
								'timeValue': ''
							});
							break;
	
						default:
							this.model.set( 'timeValue', value );
	
					}//end switch
					break;
	
			}//end switch
	
		},//end _changeTime()
	
		/**
		 * This callback may change current time type (and hence value) depending on
		 * the selected date type and value.
		 *
		 * For example, let's assume the date was "today" and the time was "in three
		 * hours".  Once the user changes the date from "today" to "tomorrow", the
		 * time "in three hours" does no longer make any sense and, therefore, has to
		 * be changed.
		 *
		 * @since 1.0.0
		 */
		_useProperSelector: function() {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			var dateType = this.model.get( 'dateType' );
			var dateValue = this.model.get( 'dateValue' );
	
			var timeType = this.model.get( 'timeType' );
			switch ( timeType ) {
	
				case 'exact':
					// This option can be used always. Therefore, there's no need to update it.
					break;
	
				case 'negative-hours':
				case 'positive-hours':
				case 'predefined-offset':
					// These options can only be used if the date is set to "today" or "the
					// publication day".
					if ( 'predefined-offset' !== dateType || '0' !== dateValue ) {
						this.model.set( 'timeValue', 'morning' );
						this.model.set( 'timeType',  'time-interval' );
					}//end if
					break;
	
				case 'time-interval':
					// This option can only be used if the date is NOT set to "today" or
					// "the publication day".
					if ( 'predefined-offset' === dateType && '0' === dateValue ) {
						this.model.set( 'timeValue', '0' );
						this.model.set( 'timeType',  'predefined-offset' );
					}
					break;
	
			}//end switch
	
		},//end _useProperSelector()
	
		/**
		 * This callback reverts the time type and value to default values (that is,
		 * `predefined-offset` and `0`).
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_changeTimeType: function( ev ) {
	
			if ( this._isLocked ) {
				return;
			}//end if
	
			// Hack. We put the date value first, because changing the date type
			// triggers an event for rendering the view.
			this.model.set( 'timeValue', '0' );
			this.model.set( 'timeType', 'predefined-offset' );
			this._useProperSelector();
	
			return false;
	
		},//end _changeTimeType()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class TimeSelector
	
	

})( jQuery );
