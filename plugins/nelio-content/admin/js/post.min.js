/**
 * This file is used in the post editor page. It loads several backbone models
 * and templates and adds some listeners to the editor, so that views can be
 * automatically updated when the user modifies the post.
 *
 * @author David Aguilera <david.aguilera@neliosoftware.com>
 * @since  1.0.0
 */
(function( $ ) {

	'use strict';

	// ==========================================================================
	//     Custom Meta Boxes
	// ==========================================================================

	// --------------------------------------------------------------------------
	// Timeline
	// --------------------------------------------------------------------------

	/**
	 * This view shows the list of social messages related to a specific post.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SocialTimeline = Backbone.View.extend({
	
		/**
		 * The classes used in this view's element.
		 */
		className: 'nc-social-timeline',
	
		/**
		 * An object that contains some relevant information about the overview
		 * block. This block is used as a "summary" of the information we'll find in
		 * each block (today, tomorrow, week...) and a quick access list to each of
		 * these latter blocks.
		 */
		_overview: {
			$instance: undefined,
			sections: {
				$before: undefined,
				$day: undefined,
				$nextDay: undefined,
				$week: undefined,
				$month: undefined,
				$later: undefined
			},
			marks: {
				$start: undefined,
				$end: undefined
			},
			isFixed: false,
			lastHighlightedBlock: 'day',
			ignoreNextAutoHighlight: false
		},
	
		/**
		 * The list of blocks in which we render social messages.
		 */
		_$blocks: {
			before: undefined,
			day: undefined,
			nextDay: undefined,
			week: undefined,
			month: undefined,
			later: undefined
		},
	
		/**
		 * A list of child views for rendering each social message.
		 */
		_messageViews: {
			before: [],
			day: [],
			nextDay: [],
			week: [],
			month: [],
			later: []
		},
	
		/**
		 * A view that's opened for editing/creating new social messages.
		 */
		_socialMessageEditorView: undefined,
	
		/**
		 * Admin bar's height.
		 */
		_adminBarHeight: 32,
	
		/**
		 * A reference to the browser's window.
		 */
		_$window: undefined,
	
		/**
		 * A reference to the HTML document.
		 */
		_$document: undefined,
	
		/**
		 * The underscore template of this view.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-social-timeline' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
	
			'click .nc-timeline-overview .nc-section': '_gotoSection',
	
			'click .button.nc-action.nc-new-social-message.nc-add-message': '_openSocialMessageEditorDialog',
			'click .button.nc-action.nc-new-social-message.nc-upgrade': '_gotoAccountPage',
	
			'click .nc-new-social-message.nc-first-message.nc-add-message': '_openSocialMessageEditorDialog',
			'click .nc-new-social-message.nc-first-message.nc-upgrade': '_gotoAccountPage'
	
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Define some generic variables.
			this._$window = $( window );
			this._$document = $( document );
	
			// Create the basic collection of social messages.
			this.collection = new NelioContent.collections.SocialTimeline();
			this._resetMessageViews();
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this._updateMessage = _.bind( this._updateMessage, this );
			this._addNewMessages = _.bind( this._addNewMessages, this );
	
			this.listenTo( this.collection, 'add', this._addMessageView );
			this.listenTo( this.collection, 'add', this.render );
	
			this.listenTo( this.collection, 'remove', this._removeMessageView );
			this.listenTo( this.collection, 'remove', this.render );
	
			this.listenTo( this.collection, 'reset', this._resetMessageViews );
			this.listenTo( this.collection, 'reset', this.render );
	
			this._maybeFixOverview = _.bind( this._maybeFixOverview, this );
			this._onWindowResize = _.bind( this._onWindowResize, this );
			this._maybeHighlightADifferentBlockInOverview = _.bind( this._maybeHighlightADifferentBlockInOverview, this );
	
			this._$document.on( 'scroll', this._maybeFixOverview );
			this._$document.on( 'scroll', this._maybeHighlightADifferentBlockInOverview );
			this._$window.on( 'resize', this._onWindowResize );
			this._$window.on( 'resize', this._maybeHighlightADifferentBlockInOverview  );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// If there are no social profiles, render a warning message.
			if ( NelioContent.profiles.length === 0 ) {
				this.el.innerHTML = document.getElementById( '_nc-no-profile-available' ).innerHTML;
				return this;
			}//end if
	
			// Prepare data for template.
			var data = {
				dayStatus: this._getStatus( 'day' ),
				nextDayStatus: this._getStatus( 'nextDay' ),
				weekStatus: this._getStatus( 'week' ),
				monthStatus: this._getStatus( 'month' ),
				laterStatus: this._getStatus( 'later' ),
				isPostPublished: this.collection.post.isPublished()
			};
	
			var now = ncNewLocalMoment();
			if ( this.collection.post.isPublished() ) {
				data.dayFormattedDate = now.format( NelioContent.i18n.date.default );
				data.nextDayFormattedDate = now.add( 1, 'd' ).format( NelioContent.i18n.date.default );
			} else if ( this.collection.post.isScheduled() ) {
				var schedule = this.collection.post.get( 'date' ).clone();
				data.dayFormattedDate = schedule.format( NelioContent.i18n.date.default );
				data.nextDayFormattedDate = schedule.add( 1, 'd' ).format( NelioContent.i18n.date.default );
			} else {
				data.dayFormattedDate = '';
				data.nextDayFormattedDate = '';
			}//end if
	
			if ( 'none' === NelioContent.subscriptionPlan ) {
				var collection = this.collection;
				var selected = _.map( collection.getDisabledProfileIds(), function( id ) {
					  return collection.get( id );
				});
				data.areMoreMessagesAllowed = selected.length < NelioContent.profiles.length;
			}//end if
	
			// Render the template.
			this.el.innerHTML = this.template( data );
	
			// Save some elements for fixing the timeline overview.
			this._overview.$instance = this.$( '.nc-timeline-overview' );
			this._overview.marks.$start = this.$( '#timeline-start' );
			this._overview.marks.$end = this.$( '#timeline-end' );
	
			// Highlight the appropriate block.
			this._overview.sections.$day = this.$( '.nc-timeline-overview .nc-section.nc-day' );
			this._overview.sections.$nextDay = this.$( '.nc-timeline-overview .nc-section.nc-next-day' );
			this._overview.sections.$week = this.$( '.nc-timeline-overview .nc-section.nc-week' );
			this._overview.sections.$month = this.$( '.nc-timeline-overview .nc-section.nc-month' );
			this._overview.sections.$later = this.$( '.nc-timeline-overview .nc-section.nc-later' );
			this._overview.sections[ '$' + this._overview.lastHighlightedBlock ].addClass( 'nc-active' );
	
			// Render social messages.
			this._populateBlock( 'day' );
			this._populateBlock( 'nextDay' );
			this._populateBlock( 'week' );
			this._populateBlock( 'month' );
			this._populateBlock( 'later' );
	
			// We may need to fix the overview.
			this._overview.isFixed = false;
			this._maybeFixOverview();
	
			this._maybeHighlightADifferentBlockInOverview();
	
			return this;
	
		},//end render()
	
		/**
		 * This helper function populates a certain block, rendering all the social
		 * messages that belong to said block.
		 *
		 * @param blockName {string} The name of the block we want to populate.
		 *
		 * @since 1.0.0
		 */
		_populateBlock: function( blockName ) {
	
			var className = blockName;
			if ( 'nextDay' === className ) {
				className = 'next-day';
			}//end if
	
			var $container = this.$( '.nc-timeline-section.nc-' + className + ' .nc-social-messages' );
			var list = this._messageViews[ blockName ];
	
			$container.children().detach();
			_.each( list, function( mv ) {
				$container.append( mv.render().el );
			}, this );
	
			this._$blocks[ blockName ] = $container;
	
		},//end _populateBlock()
	
		/**
		 * The status of the given block.
		 *
		 * @param block {string} The name of the block whose status we want to obtaing.
		 *
		 * @return {string} The status of the given block. It can be `bad`,
		 *                  `improvable`, or `good`, depending on the amount of
		 *                  social messages scheduled in the given block.
		 *
		 * @since 1.0.0
		 */
		_getStatus: function( block ) {
	
			if ( typeof this._messageViews[ block ] !== 'undefined' ) {
	
				if ( this._messageViews[ block ].length === 0 ) {
					return 'bad';
				} else if ( this._messageViews[ block ].length < 2 ) {
					return 'improvable';
				} else {
					return 'good';
				}//end if
	
			}//end if
	
			return 'bad';
	
		},//end _getStatus()
	
		/**
		 * A callback function invoked when resetting this view's collection.
		 *
		 * It removes old child views and creates a new set of child views.
		 *
		 * @since 1.0.0
		 */
		_resetMessageViews: function() {
	
			// Remove old views (if any).
			function closeView( view ) {
				this.stopListening( view );
				this.stopListening( view.model );
				view.close();
			}//end closeView()
	
			_.each( this._messageViews.before, closeView, this );
			_.each( this._messageViews.day, closeView, this );
			_.each( this._messageViews.nextDay, closeView, this );
			_.each( this._messageViews.week, closeView, this );
			_.each( this._messageViews.month, closeView, this );
			_.each( this._messageViews.later, closeView, this );
	
			this._messageViews = {
				before: [],
				day: [],
				nextDay: [],
				week: [],
				month: [],
				later: []
			};
	
			// Create new views.
			this.collection.each( this._addMessageView, this );
	
		},//end _resetMessageViews()
	
		/**
		 * A callback function invoked when adding a message in this view's
		 * collection, or when the date of an already included message changes and
		 * it has to be rendered somewhere else. It selects the block in which the
		 * given message has to be displayed.
		 *
		 * @param message {SocialMessage} the social message we added in this view's collection.
		 *
		 * @since 1.0.0
		 */
		_addMessageView: function( message ) {
	
			// Determine the block that must contain the view.
			var block = 'none';
			if ( 'publish' === message.get( 'status' ) && ! this.collection.post.isPublished() ) {
	
				return;
	
			} else if ( 'publish' === message.get( 'status' ) || this.collection.post.isPublished() || this.collection.post.isScheduled() ) {
	
				var day;
				var nextDay;
	
				if ( this.collection.post.isPublished() ) {
					// If post is published, timeline offset begins at "Today".
					day = ncNewLocalMoment();
					nextDay = day.clone().add( 1, 'd' );
				} else {
					// If it isn't, timeline offset begins at publication date.
					day = this.collection.post.get( 'date' ).clone();
					nextDay = day.clone().add( 1, 'd' );
				}//end if
	
				var msgDate = message.get( 'schedule' );
				var diff = msgDate.diff( day, 'day' );
	
				if ( day.isSame( msgDate, 'day' ) ) {
					block = 'day';
				} else if ( nextDay.isSame( msgDate, 'day' ) ) {
					block = 'nextDay';
				} else if ( 0 < diff && diff <= 9 ) {
					block = 'week';
				} else if ( 0 < diff && diff <= 30 ) {
					block = 'month';
				} else if ( 0 < diff ) {
					block = 'later';
				}//end if
	
			} else {
	
				if ( message.get( 'dateType' ) === 'exact' ) {
	
					block = 'later';
	
				} else {
	
					var dateOffset = message.get( 'dateValue' );
					if ( dateOffset <= 0 ) {
	
						if ( message.get( 'timeType' ) !== 'exact' ) {
	
							var timeOffset = message.get( 'timeValue' );
							if ( timeOffset < 24 ) {
								block = 'day';
							} else if ( timeOffset < 48 ) {
								block = 'nextDay';
							} else if ( timeOffset < 216 ) {
								block = 'week';
							} else if ( timeOffset < 720 ) {
								block = 'month';
							} else {
								block = 'later';
							}//end if
	
						} else {
							block = 'day';
						}//end if
	
					} else if ( dateOffset <= 1 ) {
						block = 'nextDay';
					} else if ( dateOffset <= 9 ) {
						block = 'week';
					} else if ( dateOffset <= 30 ) {
						block = 'month';
					} else {
						block = 'later';
					}//end if
	
				}//end if
	
			}//end if
	
			// Let's see if the message has a view already.
			var view = this._extractView( message );
	
			// If we didn't find the block that has to contain the view, remove it and
			// make sure it's not added.
			if ( 'none' === block ) {
	
				if ( typeof view !== 'undefined' ) {
					view.close();
				}//end if
	
				return;
	
			}//end if
	
			// If we didn't find it, let's create a new view.
			if ( typeof view === 'undefined' ) {
				view = new NelioContent.views.SocialTimelineMessage({ model : message });
				this.listenTo( view, 'nc:edit', this._openSocialMessageEditorDialog );
				this.listenTo( view.model, 'change:dateValue', this._addMessageView );
				this.listenTo( view.model, 'change:dateValue', this.render );
				this.listenTo( view.model, 'change:timeValue', this._addMessageView );
				this.listenTo( view.model, 'change:timeValue', this.render );
			}//end if
	
			// Sort the views in this block by their schedule date.
			this._messageViews[ block ].push( view );
			this._messageViews[ block ].sort( function( a, b ) {
	
				var x = a.model.getDateForSorting();
				var y = b.model.getDateForSorting();
	
				// Make sure twitter comes first.
				if ( 'twitter' === a.model.get( 'network' ) ) {
					x += 'Atwitter';
				} else {
					x += 'B' + a.model.get( 'network' );
				}//end if
	
				// Make sure twitter comes first.
				if ( 'twitter' === b.model.get( 'network' ) ) {
					y += 'Atwitter';
				} else {
					y += 'B' + b.model.get( 'network' );
				}//end if
	
				// If everything's the same, use the message for sorting.
				x += a.model.get( 'profileId' ) + a.model.get( 'text' );
				y += b.model.get( 'profileId' ) + b.model.get( 'text' );
	
				if ( x < y ) {
					return -1;
				} else if ( x > y ) {
					return 1;
				} else {
					return 0;
				}//end if
	
			});
	
		},//end _addMessageView()
	
		/**
		 * A callback function invoked when removing a message from the collection.
		 *
		 * @param message {SocialMessage} the social message we removed from this.
		 *
		 * @since 1.0.0
		 */
		_removeMessageView: function( message ) {
	
			// Extract the view and close it.
			var view = this._extractView( message );
	
			if ( typeof view !== 'undefined' ) {
				this.stopListening( view );
				this.stopListening( view.model );
				view.close();
			}//end if
	
		},//end _removeMessageView()
	
		/**
		 * Helper function for finding the view related to a certain social message
		 * and extract it (that is, "remove" it) from the block in which it's saved.
		 *
		 * @param message {SocialMessage} the social message whose view we want to obtain.
		 *
		 * @since 1.0.0
		 */
		_extractView: function( message ) {
	
			// Helper function for finding the view.
			function searchView( candidateView ) {
				return candidateView.model === message;
			}//end search()
	
			// Look for the view in the existing collection.
			var view;
	
			_.each( [ 'before', 'day', 'nextDay', 'week', 'month', 'later' ],
				function( block ) {
					if ( typeof view !== 'undefined' ) {
						return;
					}//end if
					var views = _.filter( this._messageViews[ block ], searchView );
					if ( views.length > 0 ) {
						view = views[0];
						this._messageViews[ block ] = _.without( this._messageViews[ block ], view );
					}//end if
				},
				this
			);
	
			return view;
	
		},//end _extractView()
	
		/**
		 * A helper function for fixing the overview block whilst scrolling. This
		 * way, the overview is always visible.
		 *
		 * @param top {int} The top position in which the block has to be "fixed".
		 *                  Each time the user scrolls, this value has to be
		 *                  updated, or else the block would move as the page
		 *                  scrolls.
		 *
		 * @since 1.0.0
		 */
		_fixOverview: function( top ) {
	
			if ( typeof this._overview.$instance === 'undefined' ) {
				return;
			}//end if
	
			this._overview.$instance.css( 'top', top );
	
			if ( this._overview.isFixed ) {
				return;
			}//end if
	
			var width = this._overview.$instance.width();
			this._overview.$instance.addClass( 'nc-fixed' );
			this._overview.$instance.css( 'left', this._overview.$instance.offset().left );
			this._overview.$instance.css( 'width', width );
	
			this._overview.isFixed = true;
	
		},//end _fixOverview()
	
		/**
		 * A helper function for unfixing the overview block.
		 *
		 * @since 1.0.0
		 */
		_unfixOverview: function() {
	
			if ( ! this._overview.isFixed ) {
				return;
			}//end if
	
			this._overview.$instance.removeClass( 'nc-fixed' );
			this._overview.$instance.css( 'top', '' );
			this._overview.$instance.css( 'left', '' );
			this._overview.$instance.css( 'width', '' );
	
			this._overview.isFixed = false;
	
		},//end _unfixOverview()
	
		/**
		 * A callback function triggered when the user scrolls the page. When
		 * required, the overview block is "fixed" and, therefore, its visibility
		 * guaranteed.
		 *
		 * @since 1.0.0
		 */
		_maybeFixOverview: function() {
	
			if ( typeof this._overview.$instance === 'undefined' ) {
				return;
			}//end if
	
			var scrollThreshold = 280;
			var scrollTop = this._$window.scrollTop();
			var start = this._overview.marks.$start.offset().top - scrollTop;
			var end = this._overview.marks.$end.offset().top - scrollTop;
	
			if ( start <= this._adminBarHeight && end > -100 ) {
	
				var top = this._adminBarHeight;
				if ( end < scrollThreshold ) {
					top = top - ( scrollThreshold - end );
				}//end if
	
				this._fixOverview( top );
	
			} else {
	
				this._unfixOverview();
	
			}//end if
	
		},//end _maybeFixOverview()
	
		/**
		 * A callback function for window resizing. It makes sure that the overview
		 * blok is properly rendered.
		 *
		 * @since 1.0.0
		 */
		_onWindowResize: function() {
	
			this._unfixOverview();
			this._maybeFixOverview();
			this._maybeHighlightADifferentBlockInOverview();
	
		},//end _onWindowResize()
	
		/**
		 * A callback function that scrolls the page to the clicked overview block.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback
		 *
		 * @since 1.0.0
		 */
		_gotoSection: function( ev ) {
	
			// Look for the block that was clicked.
			var target = ev.target || ev.srcElement;
			var attempts = 0;
			while ( target.className.indexOf( 'section' ) === -1 && attempts < 4 ) {
				target = target.parentNode;
			}//end while
	
			// Scroll to the selected block and highlight it in the overview.
			var offset = this._overview.$instance.height() + this._adminBarHeight + 75;
			this._overview.ignoreNextAutoHighlight = true;
			if ( target.className.indexOf( 'nc-later' ) !== -1 ) {
				this._$window.scrollTop( this._$blocks.later.offset().top - offset );
				this._highlightBlockInOverview( 'later' );
			} else if ( target.className.indexOf( 'nc-month' ) !== -1 ) {
				this._$window.scrollTop( this._$blocks.month.offset().top - offset );
				this._highlightBlockInOverview( 'month' );
			} else if ( target.className.indexOf( 'nc-week' ) !== -1 ) {
				this._$window.scrollTop( this._$blocks.week.offset().top - offset );
				this._highlightBlockInOverview( 'week' );
			} else if ( target.className.indexOf( 'nc-next-day' ) !== -1 ) {
				this._$window.scrollTop( this._$blocks.nextDay.offset().top - offset );
				this._highlightBlockInOverview( 'nextDay' );
			} else {
				this._$window.scrollTop( this._$blocks.day.offset().top - offset );
				this._highlightBlockInOverview( 'day' );
			}//end if
	
		},//end _gotoSection()
	
		/**
		 * A callback function that scrolls the page to the clicked overview block.
		 *
		 * @since 1.0.0
		 */
		_gotoAccountPage: function() {
	
			document.location.href = NelioContent.pages.account;
	
		},//end _gotoAccountPage()
	
		/**
		 * A callback function that highlights in the summary the block that's
		 * currently visible in the social timeline.
		 *
		 * @since 1.0.0
		 */
		_maybeHighlightADifferentBlockInOverview: function() {
	
			if ( this._overview.ignoreNextAutoHighlight ) {
				this._overview.ignoreNextAutoHighlight = false;
				return;
			}//end if
	
			if ( typeof this._overview.$instance === 'undefined' ) {
				return;
			}//end if
	
			var scrollTop = this._$window.scrollTop();
			var offset = this._adminBarHeight + this._overview.$instance.height() + 80;
	
			var start = scrollTop + offset;
	
			if ( this._$blocks.later.offset().top <= start ) {
				this._highlightBlockInOverview( 'later' );
			} else if ( this._$blocks.month.offset().top <= start ) {
				this._highlightBlockInOverview( 'month' );
			} else if ( this._$blocks.week.offset().top <= start ) {
				this._highlightBlockInOverview( 'week' );
			} else if ( this._$blocks.nextDay.offset().top <= start ) {
				this._highlightBlockInOverview( 'nextDay' );
			} else {
				this._highlightBlockInOverview( 'day' );
			}//end if
	
		},//end _maybeHighlightADifferentBlockInOverview()
	
		/**
		 * A helper function that actually highlights in the summary the active
		 * block.
		 *
		 * @since 1.0.0
		 */
		_highlightBlockInOverview: function( block ) {
	
			if ( this._overview.lastHighlightedBlock === block ) {
				return;
			}//end if
	
			this._overview.sections.$later.removeClass( 'nc-active' );
			this._overview.sections.$month.removeClass( 'nc-active' );
			this._overview.sections.$week.removeClass( 'nc-active' );
			this._overview.sections.$nextDay.removeClass( 'nc-active' );
			this._overview.sections.$day.removeClass( 'nc-active' );
	
			this._overview.sections[ '$' + block ].addClass( 'nc-active' );
	
			this._overview.lastHighlightedBlock = block;
	
		},//end _highlightBlockInOverview()
	
		/**
		 * A callback function that opens the social message editor dialog.
		 *
		 * @param ev      {object}  The JavaScript event that triggered the callback
		 * @param message {Message} The message that we'll be editing/creating.
		 *
		 * @since 1.0.0
		 */
		_openSocialMessageEditorDialog: function( ev, message ) {
	
			// Create an empty message and relate it to the current post.
			var messageToEdit = new NelioContent.models.SocialMessage();
			messageToEdit.setPost( this.collection.post );
	
			if ( typeof message === 'undefined' ) {
	
				var target = ev.target || ev.srcElement;
				var $el = $( target );
				switch ( $el.closest( '.nc-information' ).find( 'h4' ).attr( 'name' ) ) {
	
					case 'later':
						messageToEdit.set( 'dateType', 'exact' );
						messageToEdit.set( 'timeType', 'time-interval' );
						messageToEdit.set( 'timeValue', 'morning' );
						break;
	
					case 'month':
						messageToEdit.set( 'dateValue', '28' );
						messageToEdit.set( 'timeType', 'time-interval' );
						messageToEdit.set( 'timeValue', 'morning' );
						break;
	
					case 'week':
						messageToEdit.set( 'dateValue', '7' );
						messageToEdit.set( 'timeType', 'time-interval' );
						messageToEdit.set( 'timeValue', 'morning' );
						break;
	
					case 'next-day':
						messageToEdit.set( 'dateValue', '1' );
						messageToEdit.set( 'timeType', 'time-interval' );
						messageToEdit.set( 'timeValue', 'morning' );
						break;
	
				}//end switch
	
				messageToEdit.set( 'profileId', NelioContent.profiles.at( 0 ).get( 'id' ) );
	
			} else {
	
				messageToEdit.set( message.toJSON() );
	
			}//end if
	
			// Create the dialog for new social messages.
			this._socialMessageEditorView = new NelioContent.views.SocialMessageEditor({
				model: messageToEdit
			});
			this.listenTo( this._socialMessageEditorView, 'nc:add:messages', this._addNewMessages );
			this.listenTo( this._socialMessageEditorView, 'nc:update:message', this._updateMessage );
			this.listenTo( this._socialMessageEditorView, 'nc:delete:message', this._deleteMessage );
			this.listenTo( this._socialMessageEditorView, 'nc:close:dialog', this._onClosingMessageEditorView );
			this._socialMessageEditorView.disableProfiles( this.collection.getDisabledProfileIds() );
			this._socialMessageEditorView.render();
	
		},//end _openSocialMessageEditorDialog
	
		/**
		 * A callback function that adds a set of new messages to this view's collection.
		 *
		 * @param messages {array} the new messages that have to be added.
		 *
		 * @since 1.0.0
		 */
		_addNewMessages: function( messages ) {
	
			this.collection.add( messages );
	
		},//end _addNewMessages()
	
		/**
		 * A callback function that updates the information of a given social message.
		 *
		 * @param message {array} the new values of a social message.
		 *
		 * @since 1.0.0
		 */
		_updateMessage: function( message ) {
	
			if ( typeof message.toJSON === 'function' ) {
				message = message.toJSON();
			}//end if
	
			var aux = this.collection.get( message.id );
			if ( typeof aux !== 'undefined' ) {
				aux.set( message );
			}//end if
	
		},//end _updateMessage()
	
		/**
		 * A callback function that removes the given message from the collection.
		 *
		 * @param message {object} the message to be removed.
		 *
		 * @since 1.0.0
		 */
		_deleteMessage: function( message ) {
	
			this.collection.remove( message );
	
		},//end _deleteMessage()
	
		/**
		 * A callback function that closes the message editor dialog.
		 *
		 * @since 1.0.0
		 */
		_onClosingMessageEditorView: function() {
	
			this.stopListening( this._socialMessageEditorView );
			this._socialMessageEditorView.close();
			this._socialMessageEditorView = undefined;
	
		},//end this._onClosingMessageEditorView()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Remove old views (if any).
			function closeView( view ) {
				this.stopListening( view );
				this.stopListening( view.model );
				view.close();
			}//end closeView()
	
			// Remove all child views.
			this._messageViews = [];
			_.each( this._messageViews.before, closeView, this );
			_.each( this._messageViews.day, closeView, this );
			_.each( this._messageViews.nextDay, closeView, this );
			_.each( this._messageViews.week, closeView, this );
			_.each( this._messageViews.month, closeView, this );
			_.each( this._messageViews.later, closeView, this );
			this._messageViews = {
				before: [],
				day: [],
				nextDay: [],
				week: [],
				month: [],
				later: []
			};
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
	
			this._$document.off( 'scroll', this._maybeFixOverview );
			this._$document.off( 'scroll', this._maybeHighlightADifferentBlockInOverview );
			this._$window.off( 'resize', this._onWindowResize );
			this._$window.off( 'resize', this._maybeHighlightADifferentBlockInOverview  );
	
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SocialTimeline
	
	
	/**
	 * This view renders a social message in the social message timeline.
	 *
	 * It's inteded to be used as a child view in the SocialMessageTimeline view.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.SocialTimelineMessage = Backbone.View.extend({
	
		/**
		 * This variable contains the status of the deletion process. Possible values
		 * are:
		 *
		 *  * `none`: the user hasn't click on the `Delete` button.
		 *  * `awaiting-confirmation`: the user has clicked on `Delete`, but hasn't confirmed the action.
		 *  * `deleting`: the task is being deleted.
		 */
		_deletionStatus: 'none',
	
		/**
		 * The underscores template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-social-timeline-message' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'mouseleave': '_cancelMessageDeletion',
			'click .nc-actions .nc-delete': '_askForMessageDeletionConfirmation',
			'click .nc-actions .nc-cancel-deletion': '_cancelMessageDeletion',
			'click .nc-actions .nc-do-delete': '_deleteMessage',
			'click .nc-actions .nc-edit': '_editMessage',
			'click .nc-actions .nc-share-now': '_shareNow'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this.listenTo( this, 'nc:render', this.render );
			this.listenTo( this.model, 'change', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Prepare all the data.
			var data = this.model.toJSON();
			var profile = NelioContent.profiles.get( this.model.get( 'profileId' ) );
	
			var networkMeta = _.findWhere( NelioContent.networkMetas, {
				id: this.model.get( 'network' )
			});
			data.networkAllowsMultiTargets = false;
			if ( typeof networkMeta !== 'undefined' && networkMeta.allowsMultiTargets ) {
				data.networkAllowsMultiTargets = true;
				data.targetLabel = networkMeta.multiTargetLabels.targetLabel;
			}//end if
	
			// This shouldn't happen but...
			if ( typeof profile === 'undefined' ) {
				profile = NelioContent.profiles.at( 0 );
			}//end if
	
			data.photo = profile.get( 'photo' );
			data.displayName = profile.get( 'displayName' );
			data.firstLetter = profile.get( 'firstLetter' );
	
			data.textFormatted = this.model.getHighlightedText();
			data.dateFormatted = this._getDatetimeFormatted();
			data.isAuthorMe = this.model.get( 'authorId' ) === NelioContent.users.current().get( 'id' );
	
			data.deletionStatus = this._deletionStatus;
	
			// Render the whole view.
			this.el.innerHTML = this.template( data );
	
			if ( 'deleting' === this._deletionStatus ) {
				this.$el.addClass( 'nc-deleting' );
			} else {
				this.$el.removeClass( 'nc-deleting' );
			}//end if
	
			if ( 'image' === this.model.get( 'type' ) ) {
				this.$( '.nc-social-timeline.nc-message' ).addClass( 'nc-has-image' );
			} else {
				this.$( '.nc-social-timeline.nc-message' ).removeClass( 'nc-has-image' );
			}//end if
	
			return this;
	
		},//end render()
	
		/**
		 * Callback function. It asks whether the user really wants to delete the
		 * message or not.
		 *
		 * @since 1.0.0
		 */
		_askForMessageDeletionConfirmation: function() {
	
			this._deletionStatus = 'awaiting-confirmation';
			this.trigger( 'nc:render' );
	
		},//end _askForMessageDeletionConfirmation()
	
		/**
		 * Callback function. It asks whether the user really wants to delete the
		 * message or not.
		 *
		 * @since 1.0.0
		 */
		_cancelMessageDeletion: function() {
	
			if ( 'awaiting-confirmation' === this._deletionStatus ) {
				this._deletionStatus = 'none';
				this.trigger( 'nc:render' );
			}//end if
	
		},//end _cancelMessageDeletion()
	
		/**
		 * Callback function. It deletes the message.
		 *
		 * @since 1.0.0
		 */
		_deleteMessage: function( ev ) {
	
			this._deletionStatus = 'deleting';
			this.trigger( 'nc:render' );
			this.model.destroy();
	
		},//end _deleteMessage()
	
		/**
		 * Callback function. It triggers the event `nc:edit` when the
		 * user clicks on the edit button.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback
		 *
		 * @since 1.0.0
		 */
		_editMessage: function( ev ) {
	
			this.trigger( 'nc:edit', ev, this.model );
	
		},//end _editMessage()
	
		/**
		 * Callback function. It reshared the message right away.
		 *
		 * @since 1.0.0
		 */
		_shareNow: function() {
	
			this.model.shareNow();
	
		},//end _shareNow()
	
		/**
		 * Helper function that stringifies this message's date and time.
		 *
		 * @return {string} a stringified version of this message's schedule date.
		 *
		 * @since 1.0.0
		 */
		_getDatetimeFormatted: function() {
	
			var date = this._getDateFormatted();
			var time = this._getTimeFormatted();
	
			if ( date.length > 0 && time.length > 0 ) {
				return _.escape( date + ' • ' + time );
			} else {
				return _.escape( date + time );
			}//end if
	
		},//end _getDatetimeFormatted()
	
		/**
		 * Helper function that stringifies the date of this message.
		 *
		 * @return {string} the date of this message properly stringified.
		 *
		 * @since 1.0.0
		 */
		_getDateFormatted: function() {
	
			if ( this.model.post.isPublished() || this.model.post.isScheduled() ) {
				return this.model.get( 'schedule' ).format( NelioContent.i18n.date.default );
			}//end if
	
			if ( this.model.get( 'dateType' ) === 'exact' ) {
				return ncNewLocalMoment( this.model.get( 'dateValue' ) + ' 12:00' ).format( NelioContent.i18n.date.default );
			}//end if
	
			var aux = parseInt( this.model.get( 'dateValue' ) );
			if ( aux >= 3 ) {
				return NelioContent.i18n.daysAfterPublication.replace( '{days}', aux );
			}//end if
	
			return '';
	
		},//end _getDateFormatted()
	
		/**
		 * Helper function that stringifies the time of this message.
		 *
		 * @return {string} the time of this message properly stringified.
		 *
		 * @since 1.0.0
		 */
		_getTimeFormatted: function() {
	
			if ( this.model.post.isPublished() || this.model.post.isScheduled() ) {
				return this.model.get( 'schedule' ).format( NelioContent.i18n.time.default );
			}//end if
	
			if ( this.model.get( 'timeType' ) === 'exact' ) {
				return this.model.get( 'timeValue' );
			}//end if
	
			var aux = parseInt( this.model.get( 'timeValue' ) );
			if ( aux === 0 ) {
				return NelioContent.i18n.onPublication;
			} else if ( aux === 1 ) {
				return NelioContent.i18n.oneHourAfterPublication;
			} else if ( aux >= 2 ) {
				return NelioContent.i18n.hoursAfterPublication.replace( '{hours}', aux );
			}//end if
	
			return '';
	
		},//end _getTimeFormatted()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class SocialTimelineMessage
	
	


	// --------------------------------------------------------------------------
	// Editorial Comments
	// --------------------------------------------------------------------------

	if ( NelioContent.helpers.isSubscribedTo( 'team-plan' ) ) {
		/**
		 * This view represents an editorial comment.
		 *
		 * It's supposed to be used as a child view of the EditorialComments view.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.EditorialComment = Backbone.View.extend({
		
			/**
			 * This variable contains the status of the deletion process. Possible values
			 * are:
			 *
			 *  * `none`: the user hasn't click on the `Delete` button.
			 *  * `awaiting-confirmation`: the user has clicked on `Delete`, but hasn't confirmed the action.
			 *  * `deleting`: the task is being deleted.
			 */
			_deletionStatus: 'none',
		
			/**
			 * A timeout for re-rendering the view automatically and thus update the
			 * time.
			 */
			_autoRenderTimeout: 0,
		
			/**
			 * Whether the current comment is being saved or not.
			 */
			_isBeingSaved: false,
		
			/**
			 * The underscore template.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-editorial-comment' ).innerHTML ) ),
		
			/**
			 * List of events and their callbacks.
			 */
			events: {
				'mouseleave': '_cancelCommentDeletion',
				'click .nc-action.nc-delete': '_askForCommentDeletionConfirmation',
				'click .nc-action.nc-cancel-deletion': '_cancelCommentDeletion',
				'click .nc-action.nc-do-delete': '_deleteComment'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				// Add listeners.
				this.render = _.bind( this.render, this );
				this.listenTo( this, 'nc:render', this.render );
		
				var author = NelioContent.users.getUser( this.model.get( 'authorId' ) );
				if ( author.isLoading() ) {
					this.listenToOnce( author, 'nc:load', _.bind( function() {
						this.trigger( 'nc:render' );
					}, this ) );
				}//end if
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {Calendar} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// Prepare all the data.
				var data = this.model.toJSON();
				data.deletionStatus = this._deletionStatus;
				data.isBeingSaved = this._isBeingSaved;
		
				// Date related stuff.
				data.dateFormatted = this._prepareDate();
				if ( ncNewLocalMoment().diff( this.model.get( 'date' ), 'm' ) < 15  ) {
					data.canBeDeleted = true;
				} else {
					data.canBeDeleted = false;
				}//end if
		
				// Information about the author.
				var author = NelioContent.users.getUser( this.model.get( 'authorId' ) );
				data.isAuthorMe = author.get( 'id' ) === NelioContent.users.current().get( 'id' );
				data.photo = author.get( 'photo' );
				data.displayName = author.get( 'name' );
				data.firstLetter = author.get( 'firstLetter' );
		
				// Render the whole view.
				this.el.innerHTML = this.template( data );
		
				return this;
		
			},//end render()
		
			/**
			 * This function modifies the view so that it shows whether the comment is being
			 * saved or not, and re-renders it.
			 *
			 * @param isBeingSaved {boolean} whether the comment is being saved or not.
			 *
			 * @since 1.0.0
			 */
			setIsBeingSaved: function( isBeingSaved ) {
		
				this._isBeingSaved = isBeingSaved;
				this.trigger( 'nc:render' );
		
			},//end setIsBeingSaved()
		
			/**
			 * Callback function that re-generates the formatted date attribute, which
			 * shows the date in which the message was created.
			 *
			 * Depending on how much time ago this message was created, this function
			 * also sets a timeout for re-rendering the comment every once in a while
			 * and, hence, show a dynamic time.
			 *
			 * @return {string} the formatted date.
			 *
			 * @since 1.0.0
			 */
			_prepareDate: function() {
		
				// Clear old timeout (if any)
				this._clearAutoRenderTimeout();
		
				// Prepare the new date and, maybe, set a timeout for re-rendering the view
				// automatically.
				var now = ncNewLocalMoment();
				var yesterday = now.clone().add( -1, 'd' );
				var date = this.model.get( 'date' );
		
				var dateFormatted;
		
				if ( now.diff( date, 'd' ) > 2 ) {
		
					dateFormatted = date.format( NelioContent.i18n.date.default );
		
				} else if ( date.isSame( yesterday, 'day' ) ) {
		
					dateFormatted = date.format( NelioContent.i18n.date.lastDay ) + ', ' +
						date.format( NelioContent.i18n.time.default );
					this._autoRenderTimeout = setTimeout( this.render, 900000 );
		
				} else if ( date.isSame( now, 'day' ) ) {
		
					if ( Math.abs( date.diff( now, 'h' ) ) > 3 ) {
						dateFormatted = date.format( NelioContent.i18n.time.default );
					} else if ( now.diff( date, 's' ) < 30 ) {
						dateFormatted = date.format( NelioContent.i18n.time.now );
					} else {
						dateFormatted = NelioContent.helpers.capitalizeFirstLetter( date.fromNow() );
					}//end if
		
					var diff = Math.abs( now.diff( date, 'm' ) );
					if ( diff < 1 ) {
						this._autoRenderTimeout = setTimeout( this.render, 20000 );
					} else if ( diff < 5 ) {
						this._autoRenderTimeout = setTimeout( this.render, 60000 );
					} else {
						this._autoRenderTimeout = setTimeout( this.render, 900000 );
					}//end if
		
				} else {
		
					dateFormatted = date.format( NelioContent.i18n.date.default );
		
				}//end if
		
				return dateFormatted;
		
			},//end _prepareDate()
		
			/**
			 * Callback function. It asks whether the user really wants to delete the
			 * comment.
			 *
			 * @since 1.0.0
			 */
			_askForCommentDeletionConfirmation: function() {
		
				this._deletionStatus = 'awaiting-confirmation';
				this.trigger( 'nc:render' );
		
			},//end _askForCommentDeletionConfirmation()
		
			/**
			 * Callback function. It discards the delete comment confirmation message.
			 *
			 * @since 1.0.0
			 */
			_cancelCommentDeletion: function() {
		
				if ( 'awaiting-confirmation' === this._deletionStatus ) {
					this._deletionStatus = 'none';
					this.trigger( 'nc:render' );
				}//end if
		
			},//end _cancelCommentDeletion()
		
			/**
			 * Callback function. It deletes the comment.
			 *
			 * @since 1.0.0
			 */
			_deleteComment: function( ev ) {
		
				this._deletionStatus = 'deleting';
				this.trigger( 'nc:render' );
				this.model.destroy();
		
			},//end _deleteComment()
		
			/**
			 * Clears the auto render timeout.
			 *
			 * @since 1.0.0
			 */
			_clearAutoRenderTimeout: function() {
		
				if ( this._autoRenderTimeout > 0 ) {
					clearTimeout( this._autoRenderTimeout );
					this._autoRenderTimeout = 0;
				}//end if
		
			},//end _clearAutoRenderTimeout()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// Clear the auto-render timeout (if any).
				this._clearAutoRenderTimeout();
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class EditorialComment
		
		
		/**
		 * This view shows the list of editorial comments related to a specific post.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.EditorialComments = Backbone.View.extend({
		
			/**
			 * A list of child views for rendering each editorial comment.
			 */
			_commentViews: [],
		
			/**
			 * Whether this view has already been rendered or not.
			 */
			_rendered: false,
		
			/**
			 * The underscore template of this view.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-editorial-comments' ).innerHTML ) ),
		
			/**
			 * List of events and their callbacks.
			 */
			events: {
				'keypress textarea': '_maybeAddComment'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				if ( typeof this.collection === 'undefined' ) {
					this.collection = new NelioContent.collections.EditorialComments();
				}//end if
		
				this.collection.each( function( item ) {
					var view = new NelioContent.views.EditorialComment({ model:item });
					this._commentViews.push( view );
				}, this );
		
				// Add listeners.
				this.render = _.bind( this.render, this );
		
				this.listenTo( this.collection, 'add', this._addEditorialComment );
				this.listenTo( this.collection, 'add', this.render );
		
				this.listenTo( this.collection, 'remove', this._removeEditorialComment );
				this.listenTo( this.collection, 'remove', this.render );
		
				this.listenTo( this.collection, 'reset', this._resetCommentViews );
				this.listenTo( this.collection, 'reset', this.render );
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {Calendar} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// Render the whole view.
				if ( ! this._rendered ) {
					this.el.innerHTML = this.template();
					this._rendered = true;
				}//end if
		
				// Render comments.
				var $editorialComments = this.$( '.nc-editorial-comments' );
				$editorialComments.children().detach();
				_.each( this._commentViews, function( cv ) {
					$editorialComments.append( cv.render().el );
				}, this );
		
				// Scroll to bottom.
				$editorialComments[0].scrollTop = $editorialComments[0].scrollHeight;
		
				return this;
		
			},//end render()
		
			/**
			 * This function adds the new comment to the collection associated with this view.
			 *
			 * @since 1.0.0
			 */
			addComment: function( comment ) {
		
				// Prepare the new child view for this comment.
				var view = new NelioContent.views.EditorialComment({ model : comment });
				view.setIsBeingSaved( true );
				this._commentViews.push( view );
		
				// Add the new comment to the collection.
				this.stopListening( this.collection, 'add', this._addEditorialComment );
				this.collection.add( comment );
				this.listenTo( this.collection, 'add', this._addEditorialComment );
		
				// Save the comment.
				comment.save( undefined, {
		
					/**
					 * This function updates the values of the given model to the ones
					 * returned by our cloud and re-renders the list of editorial tasks.
					 *
					 * @param model    {object} The model we're saving.
					 * @param response {object} The response from our cloud.
					 *
					 */
					success: function( model, response ) {
		
						comment.set( response );
						view.setIsBeingSaved( false );
		
					}//end success()
		
				});
		
			},//end addComment()
		
			/**
			 * A callback function invoked when resetting this view's collection.
			 *
			 * It removes old child views and creates a new set of child views.
			 *
			 * @since 1.0.0
			 */
			_resetCommentViews: function() {
		
				// Remove old views (if any).
				_.each( this._commentViews, function( view ) {
					view.close();
				}, this );
				this._commentViews = [];
		
				// Create new views.
				this.collection.each( this._addEditorialComment, this );
		
			},//end _resetCommentViews()
		
			/**
			 * This callback creates a new child view for rendering the comment.
			 *
			 * @param comment {EditorialComment} the comment that has been added to the
			 *                 collection.
			 *
			 * @since 1.0.0
			 */
			_addEditorialComment: function( comment ) {
		
				// Prepare the new child view for this comment.
				var view = new NelioContent.views.EditorialComment({ model : comment });
				this._commentViews.push( view );
		
			},//end _addEditorialComment()
		
			/**
			 * Looks for the view related to the given comment and closes it.
			 *
			 * @param comment {EditorialComment} the comment whose view has to be closed.
			 *
			 * @since 1.0.0
			 */
			_removeEditorialComment: function( comment ) {
		
				// Find the view to remove.
				var views = _.filter( this._commentViews, function( candidate ) {
					return candidate.model === comment;
				}, this );
		
				// And remove it.
				if ( views.length > 0 ) {
					var view = views[0];
					this._commentViews = _.without( this._commentViews, view );
					this.stopListening( view );
					view.close();
				}//end if
		
			},//end _removeEditorialComment()
		
			/**
			 * Callback function
			 *
			 * @param ev {object} The JavaScript event that triggered the callback.
			 *
			 * @since 1.0.0
			 */
			_maybeAddComment: function( ev ) {
		
				// If the user pressed Enter and there's a comment to be
				// sent, let's create it.
				if ( 13 === ev.keyCode && ! ev.shiftKey ) {
		
					var $textarea = this.$( 'textarea' );
					var actualComment = NelioContent.helpers.trim( $textarea.val() );
					$textarea.val( '' );
		
					if ( 0 === actualComment.length ) {
						return false;
					}//end if
		
					var comment = new NelioContent.models.EditorialComment({
						comment: actualComment,
					});
		
					this.addComment( comment );
		
					return false;
		
				}//end if
		
			},//end _maybeAddComment()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// Remove all child views.
				_.each( this._commentViews, function( view ) {
					view.close();
				}, this );
				this._commentViews = [];
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class EditorialComments
		
		
	}//end if


	// --------------------------------------------------------------------------
	// Editorial Tasks
	// --------------------------------------------------------------------------

	if ( NelioContent.helpers.isSubscribedTo( 'personal-plan' ) ) {
		/**
		 * This view renders an editorial task related to a certain post.
		 *
		 * It's inteded to be used as a child view in the EditorialTasks view.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.EditorialTask = Backbone.View.extend({
		
			/**
			 * This variable contains the status of the deletion process. Possible values
			 * are:
			 *
			 *  * `none`: the user hasn't click on the `Delete` button.
			 *  * `awaiting-confirmation`: the user has clicked on `Delete`, but hasn't confirmed the action.
			 *  * `deleting`: the task is being deleted.
			 */
			_deletionStatus: 'none',
		
			/**
			 * Whether the current comment is being saved or not.
			 */
			_isBeingSaved: false,
		
			/**
			 * The underscores template.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-editorial-task' ).innerHTML ) ),
		
			/**
			 * List of events and their callbacks.
			 */
			events: {
				'mouseleave': '_cancelTaskDeletion',
				'click .nc-actions .nc-delete': '_askForTaskDeletionConfirmation',
				'click .nc-actions .nc-cancel-deletion': '_cancelTaskDeletion',
				'click .nc-actions .nc-do-delete': '_deleteTask',
				'click input[type=checkbox]:not( .disabled )': '_toggleCompletion'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				// Add listeners.
				this.render = _.bind( this.render, this );
				this.listenTo( this, 'nc:render', this.render );
		
				this.listenTo( this.model, 'change:completed', this.render );
		
				var assignee = NelioContent.users.getUser( this.model.get( 'assigneeId' ) );
				if ( assignee.isLoading() ) {
					this.listenToOnce( assignee, 'nc:load', _.bind( function() {
						this.trigger( 'nc:render' );
					}, this ) );
				}//end if
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {Calendar} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// Render the whole view.
				var data = this.model.toJSON();
				data.deletionStatus = this._deletionStatus;
				data.isBeingSaved = this._isBeingSaved;
		
				data.isAssignerMe = this.model.get( 'assignerId' ) === NelioContent.users.current().get( 'id' );
				data.isAssigneeMe = this.model.get( 'assigneeId' ) === NelioContent.users.current().get( 'id' );
				data.assigneeName = NelioContent.users.getUser( this.model.get( 'assigneeId' ) ).get( 'name' );
		
				data.isOverdue = false;
				data.dateFormatted = this._getDateFormatted();
		
				if ( ! this.isBeingSaved ) {
		
					if ( this.model.post.isPublished() || this.model.post.isScheduled() ) {
						data.isOverdue = this.model.get( 'dateDue' ).isBefore( ncNewLocalMoment() );
					}//end if
		
				}//end if
		
				this.el.innerHTML = this.template( data );
		
				return this;
		
			},//end render()
		
			/**
			 * This function modifies the view so that it shows whether the task is being
			 * saved or not, and re-renders it.
			 *
			 * @param isBeingSaved {boolean} whether the task is being saved or not.
			 *
			 * @since 1.0.0
			 */
			setIsBeingSaved: function( isBeingSaved ) {
		
				this._isBeingSaved = isBeingSaved;
				this.trigger( 'nc:render' );
		
			},//end setIsBeingSaved()
		
			/**
			 * Callback function. It asks whether the user really wants to delete the
			 * task.
			 *
			 * @since 1.0.0
			 */
			_askForTaskDeletionConfirmation: function() {
		
				this._deletionStatus = 'awaiting-confirmation';
				this.trigger( 'nc:render' );
		
			},//end _askForTaskDeletionConfirmation()
		
			/**
			 * Callback function. It discards the delete task confirmation message.
			 *
			 * @since 1.0.0
			 */
			_cancelTaskDeletion: function() {
		
				if ( 'awaiting-confirmation' === this._deletionStatus ) {
					this._deletionStatus = 'none';
					this.trigger( 'nc:render' );
				}//end if
		
			},//end _cancelTaskDeletion()
		
			/**
			 * Callback function. It deletes the task.
			 *
			 * @since 1.0.0
			 */
			_deleteTask: function( ev ) {
		
				this._deletionStatus = 'deleting';
				this.trigger( 'nc:render' );
				this.model.destroy();
		
			},//end _deleteTask()
		
			/**
			 * Toggles the completed status of the related task.
			 *
			 * @since 1.0.0
			 */
			_toggleCompletion: function() {
		
				var completed = ! this.model.get( 'completed' );
				this.model.set( 'completed', completed );
		
				// Mark the view as being saved.
				this._isBeingSaved = true;
				this.trigger( 'nc:render' );
		
				// And save the model.
				var view = this;
				this.model.save( undefined, {
		
					/**
					 * This function updates the values of the given model to the ones
					 * returned by our cloud and re-renders the list of editorial tasks.
					 *
					 * @param model    {object} The model we're saving.
					 * @param response {object} The response from our cloud.
					 *
					 * @since 1.0.0
					 */
					success: function( model, response ) {
		
						view.model.set( 'completed', response.completed );
						view.setIsBeingSaved( false );
						view.trigger( 'nc:render' );
		
					}//end success()
		
				});
		
			},//end _toggleCompletion()
		
			/**
			 * Helper function that returns a stringified version of the due date.
			 *
			 * @return {string} a stringified version of the due date.
			 *
			 * @since 1.0.0
			 */
			_getDateFormatted: function() {
		
				if ( this.model.post.isPublished() || this.model.post.isScheduled() ) {
					return this.model.get( 'dateDue' ).calendar();
				}//end if
		
				var offset;
		
				switch ( this.model.get( 'dateType' ) ) {
		
					case 'exact':
						return this.model.get( 'dateDue' ).calendar();
		
					case 'predefined-offset':
						offset = parseInt( this.model.get( 'dateValue' ) );
						break;
		
					case 'negative-days':
						offset = -parseInt( this.model.get( 'dateValue' ) );
						break;
		
					default: // positive-days
						offset = parseInt( this.model.get( 'dateValue' ) );
		
				}//end switch
		
				if ( offset < 0 ) {
					return NelioContent.i18n.daysBeforePublication.replace( '{days}', -offset );
				} else if ( 0 === offset ) {
					return NelioContent.i18n.publicationDay;
				} else {
					return NelioContent.i18n.daysAfterPublication.replace( '{days}', offset );
				}//end if
		
			},//end _getDateFormatted()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class EditorialTask
		
		
		/**
		 * This view shows the list of editorial tasks related to a specific post.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.EditorialTasks = Backbone.View.extend({
		
			/**
			 * A list of child views for rendering each editorial task.
			 */
			_taskViews: [],
		
			/**
			 * A child view for rendering the editorial task creation form.
			 */
			_newTaskView: false,
		
			/**
			 * Whether this view has already being rendered or not.
			 */
			_rendered: false,
		
			/**
			 * The underscore template of this view.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-editorial-tasks' ).innerHTML ) ),
		
			/**
			 * List of events and their callbacks.
			 */
			events: {
				'click .nc-new-task-form-opener input': '_openNewTaskForm'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				if ( typeof this.collection === 'undefined' ) {
					this.collection = new NelioContent.collections.EditorialTasks();
				}//end if
		
				this.collection.each( function( item ) {
					var view = new NelioContent.views.EditorialTask({ model:item });
					this._taskViews.push( view );
				}, this );
		
				// Add listeners.
				this.render = _.bind( this.render, this );
				this.listenTo( this, 'nc:render', this.render );
		
				this.listenTo( this.collection, 'add', this._addEditorialTask );
				this.listenTo( this.collection, 'add', this.render );
		
				this.listenTo( this.collection, 'remove', this._removeEditorialTask );
				this.listenTo( this.collection, 'remove', this.render );
		
				this.listenTo( this.collection, 'reset', this._resetTaskViews );
				this.listenTo( this.collection, 'reset', this.render );
		
				this.listenTo( this.collection, 'change:completed', this.render );
				this.listenTo( this, 'nc:open:newTaskForm', this.render );
				this.listenTo( this, 'nc:close:newTaskForm', this.render );
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {Calendar} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// If the collection doesn't have any task, the view can be "fully
				// rendered", because the progress bar will not exist and, therefore, there
				// won't be any animations.
				if ( 0 === this.collection.length ) {
					this._rendered = false;
				}//end if
		
				// Render the whole view.
				if ( ! this._rendered ) {
					var data = {
						taskCount: this.collection.length
					};
					this.el.innerHTML = this.template( data );
					this._rendered = this.collection.length !== 0;
				}//end if
		
				var completedTasks = this.collection.where( { completed:true } );
				var completionPercentage = Math.round( 100 * completedTasks.length / this.collection.length );
		
				var $progressBar = this.$( '.nc-task-list-progress .nc-bar' );
				if ( completionPercentage == 100 ) {
					$progressBar.addClass( 'nc-completed' );
				} else {
					$progressBar.removeClass( 'nc-completed' );
				}//end if
				$progressBar.css( 'width', completionPercentage + '%' );
		
				this.$( '.nc-task-list-progress .nc-percentage' ).text( completionPercentage + '%' );
		
				// Render tasks.
				var $editorialTasks = this.$( '.nc-tasks' );
				$editorialTasks.children().detach();
				_.each( this._taskViews, function( tv ) {
					$editorialTasks.append( tv.render().el );
				}, this );
		
				// Render the task view.
				if ( this._newTaskView ) {
					this.$( '.nc-new-task-form-opener' ).hide();
					this.$( '.nc-new-task-form-container' ).append( this._newTaskView.render().el );
				} else {
					this.$( '.nc-new-task-form-opener' ).show();
				}
		
				return this;
		
			},//end render()
		
			/**
			 * This function adds the new task to the collection and saves it in AWS (if
			 * it wasn't already there).
			 *
			 * @param task {EditorialTask} The task to be added.
			 *
			 * @since 1.0.0
			 */
			addEditorialTask: function( task ) {
		
				// Close the new task form (if it's already opened).
				this._closeNewTaskForm();
		
				// Prepare the new child view for this task.
				var view = new NelioContent.views.EditorialTask({ model : task });
				view.setIsBeingSaved( true );
				this._taskViews.push( view );
		
				// Add the new task to the collection.
				this.stopListening( this.collection, 'add', this._addEditorialTask );
				this.collection.add( task );
				this.listenTo( this.collection, 'add', this._addEditorialTask );
		
				// Save the task.
				var editorialTasksView = this;
				task.save( undefined, {
		
					/**
					 * This function updates the values of the given model to the ones
					 * returned by our cloud and re-renders the list of editorial tasks.
					 *
					 * @param model    {object} The model we're saving.
					 * @param response {object} The response from our cloud.
					 *
					 * @since 1.0.0
					 */
					success: function( model, response ) {
		
						task.set( response );
						view.setIsBeingSaved( false );
						editorialTasksView.trigger( 'nc:render' );
		
					}//end success()
		
				});
		
			},//end addEditorialTask()
		
			/**
			 * A callback function invoked when resetting this view's collection.
			 *
			 * It removes old child views and creates a new set of child views.
			 *
			 * @since 1.0.0
			 */
			_resetTaskViews: function() {
		
				// Remove old views (if any).
				_.each( this._taskViews, function( view ) {
					view.close();
				}, this );
				this._taskViews = [];
		
				// Create new views.
				this.collection.each( this._addEditorialTask, this );
				this._sortEditorialTasks();
		
			},//end _resetTaskViews()
		
			/**
			 * This callback creates a new view for rendering the given task.
			 *
			 * @param task {EditorialTask} The task that has been added in this view's
			 *                             collection.
			 *
			 * @since 1.0.0
			 */
			_addEditorialTask: function( task ) {
		
				// Prepare the new child view for this task.
				var view = new NelioContent.views.EditorialTask({ model : task });
				task.setPost( this.collection.post );
				this._taskViews.push( view );
		
			},//end _addEditorialTask()
		
			/**
			 * This callback creates a new view for rendering the given task.
			 *
			 * @param task {EditorialTask} The task that has been added in this view's
			 *                             collection.
			 *
			 * @since 1.0.0
			 */
			_sortEditorialTasks: function( task ) {
		
				this._taskViews.sort( function( a, b ) {
		
					var x = a.model.getDateForSorting() + a.model.get( 'task' );
					var y = b.model.getDateForSorting() + b.model.get( 'task' );
		
					if ( x < y ) {
						return -1;
					} else if ( x > y ) {
						return 1;
					} else {
						return 0;
					}//end if
		
				});
		
			},//end _sortEditorialTasks()
		
			/**
			 * Looks for the child view whose model is the given task and closes it.
			 *
			 * @param task {EditorialTask} the task whose view is to be closed.
			 *
			 * @since 1.0.0
			 */
			_removeEditorialTask: function( task ) {
		
				// Find the view to remove.
				var views = _.filter( this._taskViews, function( candidate ) {
					return candidate.model === task;
				}, this );
		
				// And remove it.
				if ( views.length > 0 ) {
					var view = views[0];
					this._taskViews = _.without( this._taskViews, view );
					view.close();
				}//end if
		
			},//end _removeEditorialTask()
		
			/**
			 * Opens the task creation form.
			 *
			 * @since 1.0.0
			 */
			_openNewTaskForm: function() {
		
				// Create a new task object and insert it in the view.
		
				this._newTaskView = new NelioContent.views.NewEditorialTask();
				this._newTaskView.model.setPost( this.collection.post );
		
				this.listenTo( this._newTaskView, 'nc:create:task', this.addEditorialTask );
				this.listenTo( this._newTaskView, 'nc:cancel', this._closeNewTaskForm );
		
				this.trigger( 'nc:open:newTaskForm' );
		
			},//end _openNewTaskForm()
		
			/**
			 * Closes the task creation form.
			 *
			 * @since 1.0.0
			 */
			_closeNewTaskForm: function() {
		
				if ( this._newTaskView ) {
		
					this.stopListening( this._newTaskView );
		
					this._newTaskView.close();
					this._newTaskView = false;
		
					this.trigger( 'nc:close:newTaskForm' );
		
				}//end if
		
			},//end _openNewTaskForm()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// Remove all child views.
				_.each( this._taskViews, function( tv ) {
					tv.close();
				}, this );
				this._taskViews = [];
		
				if ( typeof this._newTaskView.close === 'function' ) {
					this._newTaskView.close();
					this._newTaskView = undefined;
				}//end if
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class EditorialTasks
		
		
		/**
		 * This view represents the form for creating new tasks.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.NewEditorialTask = Backbone.View.extend({
		
			/**
			 * Due date view.
			 */
			_assigneeView: undefined,
		
			/**
			 * Due date view.
			 */
			_dueDateView: undefined,
		
			/**
			 * Dialog's save button.
			 */
			_$saveButton: undefined,
		
			/**
			 * An underscore template with the form for creating new tasks.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-new-editorial-task' ).innerHTML ) ),
		
			/**
			 * List of events and their callbacks.
			 */
			events: {
				'keyup textarea': '_updateTask',
				'change textarea': '_updateTask',
				'click .nc-cancel': '_cancel',
				'click .nc-add-task:not( .button-disabled )': '_addTask'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				// Create the new model.
				this.model = new NelioContent.models.EditorialTask();
		
				// Create child views.
				if ( 'team-plan' === NelioContent.subscriptionPlan ) {
		
					this._assigneeView = new NelioContent.views.UserSelector({
						defaultValue: this.model.get( 'assigneeId' )
					});
		
				} else {
		
					this._assigneeView = new NelioContent.views.UserSelector({
						single: true,
						defaultValue: this.model.get( 'assigneeId' )
					});
		
				}//end if
		
				this._dueDateView = new NelioContent.views.DateSelector({
					model: this.model
				});
		
				// Add listeners.
				this.render = _.bind( this.render, this );
		
				this.listenTo( this.model, 'change:task', this._maybeEnableAddButton );
				this.listenTo( this.model, 'change:dateType', this._maybeEnableAddButton );
				this.listenTo( this.model, 'change:dateValue', this._maybeEnableAddButton );
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {Calendar} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// Remove old tooltip button (if any).
				if ( typeof this._$saveButton !== 'undefined' ) {
					this._$saveButton.tooltip( 'destroy' );
				}//end if
		
				// Render the whole view.
				var data = this.model.toJSON();
				this.el.innerHTML = this.template( data );
		
				// Render users and date.
				this.$( '.nc-assignee' ).html( this._assigneeView.render().el );
				this.$( '.nc-date' ).html( this._dueDateView.render().el );
				this._$saveButton = this.$( '.nc-add-task' );
				NelioContent.helpers.makeWarningTooltip( this._$saveButton );
		
				return this;
		
			},//end render()
		
			/**
			 * This callback is called when the user clicks on the Cancel button.
			 *
			 * It triggers the following event:
			 *
			 *  * `cancel`
			 *
			 * @since 1.0.0
			 */
			_cancel: function() {
		
				this.trigger( 'nc:cancel' );
		
			},//end _cancel
		
			/**
			 * Adds a new editorial task in the collection.
			 *
			 * It triggers the following event:
			 *
			 *  * `create-task` with the new `EditorialTask` model as a parameter.
			 *
			 * @since 1.0.0
			 */
			_addTask: function() {
		
				// Note that date type and value are controlled by the date selector view.
				this.model.set({
					task: this.$( 'textarea' ).val(),
					assignerId: NelioContent.users.current().get( 'id' ),
					assigneeId: parseInt( NelioContent.helpers.trim( this.$( '.nc-assignee select' ).val() ) )
				});
				this.trigger( 'nc:create:task', this.model );
		
			},//end _addTask
		
			/**
			 * A callback function that updates the concrete task that has to get done.
			 *
			 * @param ev {object} The JavaScript event that triggered the callback.
			 *
			 * @since 1.0.0
			 */
			_updateTask: function( ev ) {
		
				// Update the model.
				this.model.set( 'task', NelioContent.helpers.trim( this.$( 'textarea' ).val() ) );
		
				// If we pressed the enter button and everything's OK, we have to add
				// the reference.
				if ( ev.keyCode === 13 && ! this.model.isSomethingMissing() ) {
					this._addTask();
				}//end if
		
			},//end _updateTask()
		
			/**
			 * A callback function that enables or disables the add task button,
			 * depending on the task and its due date.
			 *
			 * @since 1.0.0
			 */
			_maybeEnableAddButton: function() {
		
				this._$saveButton.tooltip( 'close' );
		
				var missing = this.model.isSomethingMissing();
				if ( missing ) {
					this._$saveButton.addClass( 'button-disabled' );
					this._$saveButton.attr( 'title', _.escape( missing ) );
				} else {
					this._$saveButton.removeClass( 'button-disabled' );
					this._$saveButton.attr( 'title', '' );
				}//end if
		
			},//end _maybeEnableAddButton()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// Close child views.
				this._assigneeView.close();
				this._dueDateView.close();
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class NewEditorialTask
		
		
	}//end if


	// --------------------------------------------------------------------------
	// References in a post.
	// --------------------------------------------------------------------------

	/**
	 * This view renders an reference related to a certain post.
	 *
	 * It's inteded to be used as a child view in the References view.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.Reference = Backbone.View.extend({
	
		/**
		 * Whether we're waiting for the user to confirm (or cancel) the discarding
		 * of this reference or not.
		 */
		_awaitingDiscardConfirmation: false,
	
		/**
		 * This variable contains the child view for editing this reference.
		 */
		_referenceEditor: undefined,
	
		/**
		 * The underscores template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-reference' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'mouseleave': '_cancelDiscard',
			'click .nc-actions .nc-edit': '_editReference',
			'click .nc-actions .nc-discard': '_askForDiscardConfirmation',
			'click .nc-actions .nc-cancel-discard': '_cancelDiscard',
			'click .nc-actions .nc-do-discard': '_discard'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this.listenTo( this, 'nc:render', this.render );
	
			this.listenTo( this.model, 'change', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Render the whole view.
			var data = this.model.toJSON();
			data.awaitingDiscardConfirmation = this._awaitingDiscardConfirmation;
	
			var advisor = this.model.get( 'suggestionAdvisorId' );
			data.wasSuggestedByMe = ( advisor === NelioContent.users.current().get( 'id' ) );
			data.wasSuggestedByNelio = ( 0 === NelioContent.users.current().get( 'id' ) );
	
			this.el.innerHTML = this.template( data );
	
			return this;
	
		},//end render()
	
		/**
		 * Callback function that creates a dialog for editing this reference.
		 *
		 * The dialog is created using a child view:
		 * `NelioContent.views.ReferenceEditor`.
		 *
		 * @since 1.0.0
		 */
		_editReference: function() {
	
			// Prepare the reference that we'll edit.
			var reference = new NelioContent.models.Reference( this.model.toJSON() );
			this._referenceEditor = new NelioContent.views.ReferenceEditor({ model:reference });
			this.listenTo( this._referenceEditor, 'nc:update:reference', this._updateReference );
			this.listenTo( this._referenceEditor, 'nc:close:dialog', this._closeDialog );
	
			// And let the world (i.e. our parent) know we're about to open a dialog.
			this.trigger( 'nc:open:editorDialog' );
			this._referenceEditor.openDialog();
	
		},//end _editReference()
	
		/**
		 * Callback function for updating this reference's information.
		 *
		 * @param reference {object} the new values of this reference.
		 *
		 * @since 1.0.0
		 */
		_updateReference: function( reference ) {
	
			// Update the reference.
			this.model.set( reference );
	
		},//end if
	
		/**
		 * Callback function for closing the editor dialog.
		 *
		 * It also triggers the following event:
		 * `nc:close:editor-dialog`.
		 *
		 * @since 1.0.0
		 */
		_closeDialog: function() {
	
			// Close the editor dialog and let the world know.
			this._referenceEditor.close();
			this._referenceEditor = undefined;
			this.trigger( 'nc:close:editorDialog' );
	
		},//end _closeDialog()
	
		/**
		 * Callback function. It asks whether the user really wants to discard this
		 * reference.
		 *
		 * @since 1.0.0
		 */
		_askForDiscardConfirmation: function() {
	
			this._awaitingDiscardConfirmation = true;
			this.trigger( 'nc:render' );
	
		},//end _askForDiscardConfirmation()
	
		/**
		 * Callback function. It discards the discard reference confirmation message.
		 *
		 * @since 1.0.0
		 */
		_cancelDiscard: function() {
	
			this._awaitingDiscardConfirmation = false;
			this.trigger( 'nc:render' );
	
		},//end _cancelDiscard()
	
	
		/**
		 * Callback function that triggers the `nc:discard` event in the
		 * model.
		 *
		 * @since 1.0.0
		 */
		_discard: function() {
	
			this._awaitingDiscardConfirmation = false;
			this.model.trigger( 'nc:discard', this.model );
	
		},//end render()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class Reference
	
	
	/**
	 * This view opens a dialog for editing an existing reference.
	 *
	 * Its lifetime is supposed to be controlled by a reference view.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.ReferenceEditor = Backbone.View.extend({
	
		/**
		 * A reference to the `save` button included in this view's dialog.
		 */
		_$saveButton: undefined,
	
		/**
		 * The underscores template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-reference-editor' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'change input.nc-title': '_updateTitle',
			'keyup input.nc-title': '_updateTitle',
			'change input.nc-url': '_updateUrl',
			'keyup input.nc-url': '_updateUrl',
			'change input.nc-author': '_updateAuthor',
			'keyup input.nc-author': '_updateAuthor',
			'change input.nc-email': '_updateEmail',
			'keyup input.nc-email': '_updateEmail',
			'change input.nc-twitter': '_updateTwitter',
			'keyup input.nc-twitter': '_updateTwitter'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add some bindings.
			this.render = _.bind( this.render, this );
			this._onDialogSave = _.bind( this._onDialogSave, this );
			this._onDialogCancel = _.bind( this._onDialogCancel, this );
	
			// Add listeners.
			this.listenTo( this, 'nc:render', this.render );
			this.listenTo( this.model, 'change:url', this._maybeEnableSaveButton );
			this.listenTo( this.model, 'change:twitter', this._maybeEnableSaveButton );
			this.listenTo( this.model, 'change:email', this._maybeEnableSaveButton );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Render the whole view.
			var data = this.model.toJSON();
			data.authorEscaped = _.escape( data.author );
	
			this.el.innerHTML = this.template( data );
	
			return this;
	
		},//end render()
	
		/**
		 * Opens the dialog and renders the view.
		 *
		 * @since 1.0.0
		 */
		openDialog: function() {
	
			// Create buttons.
			var buttons = [];
			if ( this.model.get( 'isExternal' ) ) {
				buttons.push(
					NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.cancel )
				);
			} else {
				buttons.push(
					NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.close )
				);
			}//end if
			buttons.push(
				NelioContent.helpers.makeDialogSaveButton( this, NelioContent.i18n.actions.save )
			);
	
			// Create the dialog.
			var view = this;
			this.$el.dialog({
	
				title: NelioContent.i18n.titles.editReference,
	
				buttons: buttons,
				modal: true,
				width: Math.min( 600, NelioContent.helpers.getWindowWidth() - 20 ),
	
				/**
				 * Opens the dialog and listens to the events triggered by its buttons.
				 *
				 * @since 1.0.0
				 */
				open: function() {
	
					// Listen to dialog button events.
					view.listenTo( view, 'nc:click:dialog:save', view._onDialogSave );
					view.listenTo( view, 'nc:click:dialog:cancel', view._onDialogCancel );
	
					// Prepare beautiful tooltips for save button.
					view._$saveButton = view.$el.parent().find( '.button-primary' );
					NelioContent.helpers.makeWarningTooltip( view._$saveButton );
	
				},//end open()
	
				/**
				 * Destroys the dialog and triggers the `nc:close:dialog` event.
				 *
				 * @since 1.0.0
				 */
				close: function() {
	
					// Stop listening to dialog buttons, now that the dialog is about to be closed.
					view.stopListening( view, 'nc:click:dialog:save', view._onDialogSave );
					view.stopListening( view, 'nc:click:dialog:cancel', view._onDialogCancel );
	
					// Remove beautiful tooltips for save button.
					view._$saveButton.tooltip( 'destroy' );
	
					// If necessary, destroy the dialog.
					view.$el.dialog( 'destroy' );
					view.trigger( 'nc:close:dialog' );
	
				}//end close()
	
			});
	
			this.trigger( 'nc:render' );
	
		},//end openDialog()
	
		/**
		 * Callback for updating the title.
		 *
		 * @since 1.0.0
		 */
		_updateTitle: function() {
	
			var value = this.$( 'input.nc-title' ).val();
			this.model.set( 'title', NelioContent.helpers.trim( value ) );
	
		},//end _updateTitle()
	
		/**
		 * Callback for updating the URL.
		 *
		 * @since 1.0.0
		 */
		_updateUrl: function() {
	
			var value = this.$( 'input.nc-url' ).val();
			this.model.set( 'url', NelioContent.helpers.trim( value ) );
	
		},//end _updateUrl()
	
		/**
		 * Callback for updating the author's name.
		 *
		 * @since 1.0.0
		 */
		_updateAuthor: function() {
	
			var value = this.$( 'input.nc-author' ).val();
			this.model.set( 'author', NelioContent.helpers.trim( value ) );
	
		},//end _updateAuthor()
	
		/**
		 * Callback for updating the author's email.
		 *
		 * @since 1.0.0
		 */
		_updateEmail: function() {
	
			var value = this.$( 'input.nc-email' ).val();
			this.model.set( 'email', NelioContent.helpers.trim( value ) );
	
		},//end _updateEmail()
	
		/**
		 * Callback for updating the author's twitter username.
		 *
		 * @since 1.0.0
		 */
		_updateTwitter: function() {
	
			var value = this.$( 'input.nc-twitter' ).val();
			this.model.set( 'twitter', NelioContent.helpers.trim( value ) );
	
		},//end _updateTwitter()
	
		/**
		 * Disables all inputs, so that user cannot change any value (presumably,
		 * whilst saving).
		 *
		 * @since 1.0.0
		 */
		_lock: function() {
	
			this.$( 'input' ).attr( 'disabled', 'disabled' );
	
		},//end _lock()
	
		/**
		 * Re-enables all inputs (as required).
		 *
		 * @since 1.0.0
		 */
		_unlock: function() {
	
			if ( this.model.get( 'isExternal' ) ) {
				this.$( 'input' ).removeAttr( 'disabled' );
			}//end if
	
		},//end _unlock()
	
		/**
		 * A callback function that enables or disables the save button.
		 *
		 * @since 1.0.0
		 */
		_maybeEnableSaveButton: function() {
	
			this._$saveButton.tooltip( 'close' );
	
			var missing = this.model.isSomethingMissing();
			if ( missing ) {
				this._$saveButton.addClass( 'button-disabled' );
				this._$saveButton.attr( 'title', _.escape( missing ) );
			} else {
				this._$saveButton.removeClass( 'button-disabled' );
				this._$saveButton.attr( 'title', '' );
			}//end if
	
		},//end _maybeEnableSaveButton()
	
		/**
		 * Callback function that updates the reference.
		 *
		 * @since 1.0.0
		 */
		_onDialogSave: function() {
	
			if ( this.model.isSomethingMissing() ) {
				return;
			}//end if
	
			var $dialog = this.$el.parent();
			var $otherButtons = $dialog.find( '.ui-dialog-titlebar button, .ui-dialog-buttonpane button:not( .button-primary )' );
			var $saveButton = $dialog.find( '.ui-dialog-buttonpane button.button-primary' );
	
			// Disable all input fields and buttons.
			this._lock();
			this.$el.dialog( 'option', 'closeOnEscape', false );
			$otherButtons.prop( 'disabled', true );
			$saveButton.prop( 'disabled', true );
			$saveButton.html( NelioContent.i18n.feedback.saving );
	
			// Save the reference using AJAX.
			var view = this;
			$.ajax({
	
				url: ajaxurl,
				data: {
					action: 'nelio_content_update_reference',
					reference: view.model.get( 'postId' ),
					title: view.model.get( 'title' ),
					url: view.model.get( 'url' ),
					author: view.model.get( 'author' ),
					email: view.model.get( 'email' ),
					twitter: view.model.get( 'twitter' )
				},
	
				success: function( response ) {
	
					if ( response ) {
						view.trigger( 'nc:update:reference', response );
						view.$el.dialog( 'close' );
					} else {
						this.error();
					}//end if
	
				},//end success()
	
				error: function( xhr ) {
	
					NelioContent.helpers.openErrorDialog( xhr.responseJSON );
	
					$saveButton.html( NelioContent.i18n.actions.save );
					$otherButtons.prop( 'disabled', false );
					$saveButton.prop( 'disabled', false );
					view.$el.dialog( 'option', 'closeOnEscape', true );
					view._unlock();
	
				}//end error()
	
			});
	
		},//end _onDialogSave()
	
		/**
		 * Callback function that closes the dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogCancel: function() {
	
			this.$el.dialog( 'close' );
	
		},//end _onDialogCancel()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class ReferenceEditor
	
	
	/**
	 * This view shows the list of references related to a specific post.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.References = Backbone.View.extend({
	
		/**
		 * Regular expression for matching URLs.
		 */
		_urlMatcher: /^https?:\/\/([\da-z\.-]+)\.([a-z]{2,6})(\/[^\/\s]+)*\/?$/i,
	
		/**
		 * A list of child views for rendering references that are not linked in the post.
		 */
		_referenceViews: [],
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'keypress input[type=url]': '_doNotPropagateEnter',
			'keyup input[type=url]': '_onUrlChange',
			'change input[type=url]': '_onUrlChange',
			'click .nc-actions .button:not( .button-disabled )': '_addReference'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function( options ) {
	
			// Create a default collection if none was provided.
			if ( typeof this.collection === 'undefined' ) {
				this.collection = new NelioContent.collections.References();
			}//end if
			this._resetReferenceViews();
	
			// Use the template given by the creator.
			this.template = options.template;
	
			// Add listeners.
			this.render = _.bind( this.render, this );
	
			this.listenTo( this.collection, 'add', this._resetReferenceViews );
			this.listenTo( this.collection, 'add', this.render );
	
			this.listenTo( this.collection, 'remove', this._resetReferenceViews );
			this.listenTo( this.collection, 'remove', this.render );
	
			this.listenTo( this.collection, 'reset', this._resetReferenceViews );
			this.listenTo( this.collection, 'reset', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Destroy previous tooltip (if any).
			try {
				this.$( '.nc-actions .button' ).tooltip( 'destroy' );
			} catch ( e ) {}
	
			var data = {
				amITheAuthor: this.collection.post.get( 'author' ) === NelioContent.users.current().get( 'id' )
			};
			this.el.innerHTML = this.template( data );
	
			if ( this._referenceViews.length > 0 ) {
				var $list = this.$( '.nc-list' );
				$list.empty();
				_.each( this._referenceViews, function( rv ) {
					$list.append( rv.render().el );
				}, this );
			}//end if
	
			NelioContent.helpers.makeWarningTooltip( this.$( '.nc-actions .button' ) );
			this._maybeEnableAddButton();
	
			return this;
	
		},//end render()
	
		/**
		 * A callback function invoked when resetting this view's collection.
		 *
		 * It removes old child views and creates a new set of child views.
		 *
		 * @since 1.0.0
		 */
		_resetReferenceViews: function() {
	
			// Remove old views.
			_.each( this._referenceViews, function( rv ) {
				rv.close();
			}, this );
			this._referenceViews = [];
	
			// Create new views.
			this.collection.each( function( reference ) {
				var view = new NelioContent.views.Reference({ model : reference });
				this._referenceViews.push( view );
			}, this );
	
		},//end _resetReferenceViews()
	
		/**
		 * Callback function that prevents the key press event on the enter key to be
		 * propagated. If we don't do this, the form for editing a post is
		 * auto-submitted and, therefore, the post is auto-saved.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_doNotPropagateEnter: function( ev ) {
	
			if ( ev.keyCode === 13 ) {
				ev.preventDefault();
				ev.stopPropagation();
			}//end if
	
		},//end _doNotPropagateEnter()
	
		/**
		 * A callback function that enables or disables the add reference button,
		 * depending on the URL the user typed in.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onUrlChange: function( ev ) {
	
			if ( this._maybeEnableAddButton() ) {
	
				// Recover the target.
				var target = ev.target || ev.srcElement;
				var $el = this.$( target );
	
				// If we pressed the enter button and everything's OK, we have to add
				// the reference.
				if ( ev.keyCode === 13 ) {
					this._addReference();
				}//end if
	
			}//end if
	
		},//end _onUrlChange()
	
		/**
		 * Returns whether the add button is enabled or not. If it's not, it also
		 * adds a message explaining the user why.
		 *
		 * @return {boolean} whether the add button is enabled or not.
		 *
		 * @since 1.0.0
		 */
		_maybeEnableAddButton: function() {
	
			var $button = this.$( '.nc-actions .button' );
			var $el = this.$( '.nc-reference-url input' );
	
			if ( NelioContent.helpers.trim( $el.val() ).length === 0 ) {
				$button.addClass( 'button-disabled' );
				$button.attr( 'title', NelioContent.i18n.errors.reference.noUrl );
				return false;
			}//end if
	
			if ( ! this._urlMatcher.test( NelioContent.helpers.trim( $el.val() ) ) ) {
				$button.addClass( 'button-disabled' );
				$button.attr( 'title', NelioContent.i18n.errors.reference.invalidUrl );
				return false;
			}//end if
	
			$button.removeClass( 'button-disabled' );
			$button.attr( 'title', '' );
	
			return true;
	
		},//end _maybeEnableAddButton()
	
		/**
		 * A helper function for actually adding the reference added by the user.
		 *
		 * @since 1.0.0
		 */
		_addReference: function() {
	
			var $input = this.$( 'input[type=url]' );
			var url = $input.val();
			$input.val( '' );
	
			this.collection.suggestReference({
				id: url,
				url: url,
				urlEscaped: _.escape( url )
			});
	
		},//end _addReference()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Remove old views (if any).
			_.each( this._referenceViews, function( rv ) {
				rv.close();
			}, this );
			this._referenceViews = [];
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class References
	
	


	// --------------------------------------------------------------------------
	// Suggested references and broken links in a post.
	// --------------------------------------------------------------------------

	/**
	 * This view is a parent view and contains both the broken links and the
	 * suggested references in a post.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.Links = Backbone.View.extend({
	
		/**
		 * Whether this view has been rendered or not.
		 */
		_rendered: false,
	
		/**
		 * The child views used by this view.
		 */
		_views: {
			brokenLinks: undefined,
			suggestedReferences: undefined
		},
	
		/**
		 * List of broken links included in the post.
		 */
		brokenLinks: undefined,
	
		/**
		 * List of references suggested in this post.
		 */
		suggestedReferences: undefined,
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @param options {object} Options that can be attached to the view.
		 *
		 * @since 1.0.0
		 */
		initialize: function( options ) {
	
			if ( typeof options === 'undefined' ) {
				options = {};
			}//end if
	
			// Load options into this view variables.
			this.brokenLinks = options.brokenLinks;
			this.suggestedReferences = options.suggestedReferences;
	
			// Initialize child views.
			this._views.brokenLinks = new NelioContent.views.BrokenLinks({
				collection: this.brokenLinks
			});
	
			this._views.suggestedReferences = new NelioContent.views.References({
				template: _.template(
					NelioContent.helpers.trim( document.getElementById( '_nc-suggested-references' ).innerHTML )
				),
				collection: this.suggestedReferences
			});
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			if ( ! this._rendered ) {
	
				this.$el.append( this._views.brokenLinks.render().el );
				this.$el.append( this._views.suggestedReferences.render().el );
	
				this._rendered = true;
	
			}//end if
	
			if ( this.brokenLinks.length === 0 ) {
				this._views.brokenLinks.$el.css( 'display', 'none' );
			} else {
				this._views.brokenLinks.$el.css( 'display', 'block' );
			}//end if
	
			return this;
	
		},//end render()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Close child views.
			_.each( this._views, function( v ) {
				v.close();
			}, this );
			this._views = {};
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class Links
	
	
	/**
	 * This view renders an reference related to a certain post.
	 *
	 * It's inteded to be used as a child view in the BrokenLinks view.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.BrokenLink = Backbone.View.extend({
	
		/**
		 * The underscores template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-broken-link' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add listeners.
			this.render = _.bind( this.render, this );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Render the whole view.
			this.el.innerHTML = this.template( this.model.toJSON() );
	
			return this;
	
		},//end render()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class BrokenLink
	
	
	/**
	 * This (partial) view shows the links that are broken in a given post.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.BrokenLinks = Backbone.View.extend({
	
		/**
		 * The underscore template of this view.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-broken-links' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {Calendar} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			this.el.innerHTML = this.template();
	
			return this;
	
		},//end render()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class BrokenLinks
	
	


	// --------------------------------------------------------------------------
	// Errors
	// --------------------------------------------------------------------------

	/**
	 * This view shows an error message in a Nelio Content's meta box.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.MetaBoxError = Backbone.View.extend({
	
		/**
		 * An underscore template with Twitter's look and feel.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-meta-box-error' ).innerHTML ) ),
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this.listenTo( this.model, 'change', this.render );
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {MetaBoxError} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			var json = this.model.toJSON();
			this.el.innerHTML = this.template( json );
	
			return this;
	
		},//end render()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class MetaBoxError
	
	


	var post;
	var $postTitle = $( '#title' );
	var $postExcerpt = $( '#excerpt' );

	var tinyMceEditor = false;
	$( document ).on( 'tinymce-editor-init', function( event, editor ) {
		tinyMceEditor = editor;
		$( document ).trigger( 'nc:tinymce-editor', tinyMceEditor );
	});

	// ==========================================================================
	//    Load Post using AJAX
	// ==========================================================================

	$.ajax({
		url: ajaxurl,
		data: {
			action: 'nelio_content_get_post',
			post: $( '#post_ID' ).val()
		},

		/**
		 * Initializes the current post with the information obtained from WordPress.
		 *
		 * @param p {object} the post.
		 *
		 * @since 1.0.0
		 */
		success: function( p ) {

			post = new NelioContent.models.Post( p );

		},//end success()

		/**
		 * If we couldn't get the post, we'll initialize the post object using the
		 * information we have in the edit-post page.
		 *
		 * @since 1.0.0
		 */
		error: function() {

			post = new NelioContent.models.Post({
				id: parseInt( $( '#post_ID' ).val() ),
				title: NelioContent.helpers.decodeHTMLEntities( $postTitle.val() ),
				excerpt: NelioContent.helpers.decodeHTMLEntities( $postExcerpt.text() ),
				permalink: $( '#sample-permalink a' ).attr( 'href' ),
				author: $( '#post_author' ).val(),
				status: $( '#post_status' ).val()
			});

		},//end error()

		/**
		 * After the post has been initialized, this function populates all meta
		 * boxes and sets all relevant events.
		 *
		 * @since 1.0.5
		 */
		complete: function() {

			post.set( 'imageId', parseInt( $( '#nc-feat-image-thumbnail-id' ).val() ) );
			post.set( 'image', $( '#nc-feat-image-url' ).val() );
			post.set( 'autoImage', $( '#nc-feat-image-auto-url' ).val() );

			populateMetaBoxes( post );
			listenToEvents( post );

		}//end complete()

	});


	// ==========================================================================
	//    Helper Functions for Rendering all Meta Boxes and Listening to Events
	// ==========================================================================

	var timelineView, commentView, taskView;

	timelineView = new NelioContent.views.SocialTimeline();

	if ( NelioContent.helpers.isSubscribedTo( 'personal-plan' ) ) {
		taskView = new NelioContent.views.EditorialTasks();
	}//end if

	if ( NelioContent.helpers.isSubscribedTo( 'team-plan' ) ) {
		commentView = new NelioContent.views.EditorialComments();
	}//end if

	/**
	 * This function populates all relevant meta boxes.
	 *
	 * @param post {Post} the post we're currently editing.
	 *
	 * @since 1.0.5
	 */
	function populateMetaBoxes( post ) {

		$.ajax({

			url: NelioContent.apiUri + '/post/' +  post.get( 'id' ) + '/items',
			method: 'GET',
			headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },

			success: function( data ) {

				timelineView.collection.setPost( post );
				timelineView.collection.reset( data.social );
				timelineView.listenToOnce( NelioContent.profiles, 'nc:ready', function() {
					$( '#nelio-content-social-timeline-container' ).html( timelineView.render().el );
				});
				// If profiles are already ready, we trigger the event so that the timeline view
				// is rendered.
				if ( NelioContent.profiles.isReady() ) {
					NelioContent.profiles.trigger( 'nc:ready' );
				}//end if


				if ( NelioContent.helpers.isSubscribedTo( 'personal-plan' ) ) {
					taskView.collection.setPost( post );
					taskView.collection.reset( data.tasks );
					$( '#nelio-content-editorial-tasks-container' ).html( taskView.render().el );
				}//end if

				if ( NelioContent.helpers.isSubscribedTo( 'team-plan' ) ) {
					commentView.collection.setPost( post );
					commentView.collection.reset( data.comments );
					$( '#nelio-content-editorial-comments-container' ).html( commentView.render().el );
				}//end if

			},//end success()

			error: function( xhr ) {

				var error = new NelioContent.models.AjaxError();
				error.parseResponse( xhr );

				timelineView.close();
				$( '#nelio-content-social-timeline-container' ).html(
					new NelioContent.views.MetaBoxError({ model: error }).render().el
				);

				if ( NelioContent.helpers.isSubscribedTo( 'team-plan' ) ) {
					commentView.close();
					$( '#nelio-content-editorial-comments-container' ).html(
						new NelioContent.views.MetaBoxError({ model: error }).render().el
					);
				}//end if

				if ( NelioContent.helpers.isSubscribedTo( 'personal-plan' ) ) {
					taskView.close();
					$( '#nelio-content-editorial-tasks-container' ).html(
						new NelioContent.views.MetaBoxError({ model: error }).render().el
					);
				}//end if

			}//end error()

		});

	}//end populateMetaBoxes();

	/**
	 * This function listens to all relevant events (both from the post itself
	 * and the UI).
	 *
	 * @param post {Post} the post we're currently editing.
	 *
	 * @since 1.0.5
	 */
	function listenToEvents( post ) {

		// Listen to changes on the featured image.
		post.listenTo( Backbone, 'nc:change:featuredImage', function( image ) {
			post.set({
				imageId: image.get( 'attachmentId' ),
				image: image.get( 'url' )
			});
		});

		// Create the references view...
		var linksInPost = new NelioContent.collections.LinksInPost();
		linksInPost.setPost( post );
		var references = new NelioContent.collections.References();
		references.setPost( post );

		var linksView = new NelioContent.views.Links({
			brokenLinks: linksInPost,
			suggestedReferences: references
		});

		// ...and populate it.
		$.ajax({
			url: ajaxurl,
			data: {
				action: 'nelio_content_get_post_references',
				post: $( '#post_ID' ).val()
			},
			success: function( data ) {
				linksView.suggestedReferences.reset( data.suggested );
				$( '#nelio-content-links-container' ).html( linksView.render().el );
			}//end success()
		});

		// ==========================================================================
		//    Post Analysis
		// ==========================================================================

		/**
		 * This view renders post's quality analysis.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		NelioContent.views.PostAnalysisView = Backbone.View.extend({
		
			/**
			 * Whether the detailed analysis is visible or not.
			 */
			_areDetailsVisible: store.get( 'nc-post-analysis-visible-details', false ),
		
			/**
			 * Information about all the checks.
			 */
			_data: {},
		
			/**
			 * Summary of all criteria.
			 */
			_summary: 'pending',
		
			/**
			 * Status of the post.
			 */
			_postStatus: 'draft',
		
			/**
			 * Post type.
			 */
			_postType: 'post',
		
			/**
			 * Timeout for discarding any elements that couldn't be automatically evaluated.
			 */
			_discardPendingTimeout: 0,
		
			/**
			 * An underscore template with Twitter's look and feel.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-post-analysis' ).innerHTML ) ),
		
			/**
			 * List of events.
			 */
			events: {
				'click .nc-details-control': '_toggleDetailsVisibility'
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				// Add listeners.
				this.render = _.bind( this.render, this );
				this.listenTo( this, 'nc:render', this.render );
		
				// Debounce the render function, so that we don't change the information
				// too fast (flickering).
				var view = this;
				this.listenTo( this, 'nc:change', _.debounce( function() {
					view.trigger( 'nc:render' );
				}, 600 ) );
		
				// Initialize data.
				this._data = {
					author: 'pending',
					excerpt: 'pending',
					externalLinks: 'pending',
					imageCount: 'pending',
					internalLinks: 'pending',
					tag: 'pending',
					textLength: 'pending',
					thumbnail: 'pending',
					social: 'pending',
					tasks: 'pending'
				};
		
				if ( ! NelioContent.helpers.isSubscribedTo( 'personal-plan' ) ) {
					this._data.tasks = undefined;
				}//end if
		
				if ( NelioContent.postAnalysis.isYoastSeoIntegrated ) {
					this._data.yoastSeo = 'pending';
					this._data.yoastContent = 'pending';
				}//end if
		
				this._discardPendingTimeout = setTimeout( function() {
					view._discardPendingDetails();
				}, 15000 );
		
			},//end initialize()
		
			/**
			 * Renders this view.
			 *
			 * @return {PostAnalysisView} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				// Update summary.
				this._updateSummary();
		
				// Prepare data.
				var data = _.clone( this._data );
				data.isPostPublished = 'publish' === this._postStatus;
				data.areDetailsVisible = this._areDetailsVisible;
				data.summary = this._summary;
		
				// Render the template.
				this.el.innerHTML = this.template( data );
		
				return this;
		
			},//end render()
		
			/**
			 * This function analyzes some information about a post, such as whether the
			 * author is an administrator or not or the length of the excerpt.
			 *
			 * @param post {Post} the post that changed.
			 *
			 * @since 1.0.0
			 */
			onPostChange: function( post ) {
		
				this._postStatus = post.get( 'status' );
		
				this._postType = post.get( 'type' );
				if ( 'post' !== this._postType ) {
					this._data.tag = undefined;
				}//end if
		
				if ( 'publish' === this._postStatus ) {
					this._data.social = undefined;
				}//end if
		
				var author = NelioContent.users.getUser( post.get( 'author' ) );
				if ( author.isLoading() ) {
					this.listenToOnce( author, 'nc:load', _.bind( function() {
						this._checkAuthor( author );
						this.trigger( 'nc:change' );
					}, this ) );
				} else {
					this._checkAuthor( author );
				}//end if
		
				if ( NelioContent.helpers.trim( post.get( 'excerpt' ) ).length < 20 ) {
					this._data.excerpt = 'improvable';
				} else {
					this._data.excerpt = 'good';
				}//end if
		
				var image = post.get( 'image' );
				var autoImage = post.get( 'autoImage' );
				var aux = _.where( NelioContent.postTypes, { name: post.get( 'type' ) } );
				var supportsImage = aux.length && aux[0].supportsFeaturedImage;
				if ( post.get( 'imageId' ) > 0 ) {
					this._data.thumbnail = 'good';
				} else if ( typeof image === 'string' && image.length > 0 ) {
					this._data.thumbnail = 'good';
				} else if ( typeof autoImage === 'string' && autoImage.length > 0 ) {
					this._data.thumbnail = 'improvable';
				} else if ( supportsImage ) {
					this._data.thumbnail = 'bad';
				} else {
					this._data.thumbnail = undefined;
				}//end if
		
		
		
				this.trigger( 'nc:change' );
		
			},//end onPostChange()
		
			/**
			 * This function checks whether the author is admin or not.
			 *
			 * @param author {User} the author of this post.
			 *
			 * @since 1.0.0
			 */
			_checkAuthor: function( author ) {
		
				if ( 'administrator' === author.get( 'role' ) ) {
					this._data.author = 'improvable';
				} else {
					this._data.author = 'good';
				}//end if
		
			},//end _checkAuthor()
		
			/**
			 * Updates the social message criterion when mesages are added or removed.
			 *
			 * @param messages {SocialMessageTimeline} List of social messages.
			 *
			 * @since 1.0.0
			 */
			onSocialMessageListUpdate: function( messages ) {
		
				if ( 'publish' === this._postStatus ) {
					return;
				}//end if
		
				if ( 0 === messages.length ) {
					this._data.social = 'bad';
				} else if ( 1 === messages.length ) {
					this._data.social = 'improvable';
				} else {
					this._data.social = 'good';
				}//end if
		
				this.trigger( 'nc:change' );
		
			},//end onSocialMessageListUpdate()
		
			/**
			 * Updates the task criterion when tasks are added or removed.
			 *
			 * @param tasks {EditorialTasks} List of editorial tasks.
			 *
			 * @since 1.0.0
			 */
			onTaskListUpdate: function( tasks ) {
		
				if ( 'post' !== this._postType ) {
					this._data.tag = undefined;
					this.trigger( 'nc:change' );
					return;
				}//end if
		
				var incompletedTasks = [];
		
				if ( typeof tasks.where === 'function' ) {
					incompletedTasks = tasks.where( function( t ) {
						return ! t.get( 'completed' );
					});
				}//end if
		
				if ( incompletedTasks.length > 0 ) {
					this._data.tasks = 'bad';
				} else {
					this._data.tasks = 'good';
				}//end if
		
				this.trigger( 'nc:change' );
		
			},//end onTaskListUpdate()
		
			/**
			 * Updates the external and internal links criterion when the set of links
			 * included in the post changes.
			 *
			 * @param tasks {array} List of links included in the post
			 *
			 * @since 1.0.0
			 */
			onLinksChange: function( links ) {
		
				var externalLinks = 0;
				var internalLinks = 0;
		
				var blogUrl = NelioContent.blogUrl.toLowerCase();
				var fullUrlRegEx = /^[a-zA-Z]+:\/\//;
		
				for ( var i = 0; i < links.length; ++i ) {
		
					var link = links[i];
					if ( link.toLowerCase().indexOf( blogUrl ) === 0 ) {
						++internalLinks;
					} else if ( fullUrlRegEx.test( link ) ) {
						++externalLinks;
					} else {
						++internalLinks;
					}//end if
		
					if ( internalLinks >= 2 && externalLinks >= 2 ) {
						break;
					}//end if
		
				}//end for
		
				if ( 0 === internalLinks ) {
					this._data.internalLinks = 'bad';
				} else if ( 1 === internalLinks ) {
					this._data.internalLinks = 'improvable';
				} else {
					this._data.internalLinks = 'good';
				}//end if
		
				if ( 0 === externalLinks ) {
					this._data.externalLinks = 'bad';
				} else if ( 1 === externalLinks ) {
					this._data.externalLinks = 'improvable';
				} else {
					this._data.externalLinks = 'good';
				}//end if
		
				this.trigger( 'nc:change' );
		
			},//end onLinksChange()
		
			/**
			 * Updates the image citerion based on the number of images included in the
			 * post.
			 *
			 * @param imageCount {integer} Number of images included in the post.
			 *
			 * @since 1.0.0
			 */
			onImageCountChange: function( imageCount ) {
		
				if ( imageCount > 0 ) {
					this._data.imageCount = 'good';
				} else {
					this._data.imageCount = 'improvable';
				}//end if
		
				this.trigger( 'nc:change' );
		
			},//end onImageCountChange()
		
			/**
			 * Updates the text length citerion based on the number of words the post has.
			 *
			 * @param wordCount {integer} number of words in the post.
			 *
			 * @since 1.0.0
			 */
			onTextLengthChange: function( wordCount ) {
		
				var mpl = NelioContent.postAnalysis.minPostLength;
				if ( wordCount < Math.floor( mpl * 0.6 ) ) {
					this._data.textLength = 'bad';
				} else if ( wordCount < Math.floor( mpl * 0.95 ) ) {
					this._data.textLength = 'improvable';
				} else {
					this._data.textLength = 'good';
				}//end if
		
				this.trigger( 'nc:change' );
		
			},//end onTextLengthChange()
		
			/**
			 * Updates the tags citerion based on the number of tags the post has.
			 *
			 * @param tags {array} list of tags applied to the post.
			 *
			 * @since 1.0.0
			 */
			onTagListUpdate: function( tags ) {
		
				if ( typeof this._data.tag === 'undefined' ) {
					return;
				}//end if
		
				if ( tags.length > 0 ) {
					this._data.tag = 'good';
				} else {
					this._data.tag = 'bad';
				}//end if
		
				this.trigger( 'nc:change' );
		
			},//end onTagListUpdate()
		
			/**
			 * Updates Yoast SEO criterion based on Yoast SEO's status.
			 *
			 * This only works if Yoast SEO is integrated within Nelio Content.
			 *
			 * @param stat {string} Yoast SEO's status.
			 *
			 * @since 1.0.0
			 */
			onYoastSeoChange: function( stat ) {
		
				if ( ! NelioContent.postAnalysis.isYoastSeoIntegrated ) {
					return;
				}//end if
		
				this._data.yoastSeo = stat;
		
				this.trigger( 'nc:change' );
		
			},//end onYoastSeoChange()
		
			/**
			 * Updates Yoast Content criterion based on Yoast Content's status.
			 *
			 * This only works if Yoast SEO is integrated within Nelio Content.
			 *
			 * @param stat {string} Yoast's Content Analysis.
			 *
			 * @since 1.0.0
			 */
			onYoastContentChange: function( stat ) {
		
				if ( ! NelioContent.postAnalysis.isYoastSeoIntegrated ) {
					return;
				}//end if
		
				this._data.yoastContent = stat;
		
				this.trigger( 'nc:change' );
		
			},//end onYoastContentChange()
		
			/**
			 * Shows or hides all criteria.
			 *
			 * @since 1.0.0
			 */
			_toggleDetailsVisibility: function() {
		
				this._areDetailsVisible = ! this._areDetailsVisible;
				store.set( 'nc-post-analysis-visible-details', this._areDetailsVisible );
				this.trigger( 'nc:render' );
		
			},//end _toggleDetailsVisibility()
		
			/**
			 * Updates the summary analysis based on all criteria.
			 *
			 * @since 1.0.0
			 */
			_updateSummary: function() {
		
				// Compute summary.
				var pendingCount = _.filter( _.values( this._data ), function( el ) {
					return 'pending' === el;
				}).length;
				var goodCount = _.filter( _.values( this._data ), function( el ) {
					return 'good' === el;
				}).length;
				var improvableCount = _.filter( _.values( this._data ), function( el ) {
					return 'improvable' === el;
				}).length;
				var badCount = _.filter( _.values( this._data ), function( el ) {
					return 'bad' === el;
				}).length;
		
				if ( pendingCount > 0 ) {
					this._summary = 'pending';
				} else if ( 0 === improvableCount + badCount ) {
					this._summary = 'awesome';
				} else if ( 0 === badCount && improvableCount < 3 ) {
					this._summary = 'good';
				} else if ( 1 >= badCount ) {
					this._summary = 'improvable';
				} else {
					this._summary = 'bad';
				}//end if
		
			},//end _updateSummary()
		
			/**
			 * Callback function that sets all criteria that couldn't be evaluated to
			 * `unknown`, in order to prevent post analysis from loading endlessly.
			 *
			 * @since 1.0.0
			 */
			_discardPendingDetails: function() {
		
				clearTimeout( this._discardPendingTimeout );
				this._discardPendingTimeout = 0;
		
				this._data = _.object( _.map( this._data, function ( value, key ) {
					if ( 'pending' === value ) {
						return [ key, 'unknown' ];
					} else {
						return [ key, value ];
					}//end if
				} ) );
		
				this.trigger( 'nc:change' );
		
			},//end _updateSummary()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// Clear timeout.
				if ( this._discardPendingTimeout > 0 ) {
					clearTimeout( this._discardPendingTimeout );
					this._discardPendingTimeout = 0;
				}//end if
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class PostAnalysisView
		
		
		var postAnalysisView = new NelioContent.views.PostAnalysisView();
		$( '#nelio-content-post-analysis-container' ).html( postAnalysisView.render().el );


		// ==========================================================================
		//    Finally, listen to all relevant changes and update what's needed
		// ==========================================================================

		// Social messages.
		postAnalysisView.listenTo( timelineView.collection, 'reset', postAnalysisView.onSocialMessageListUpdate );
		postAnalysisView.listenTo( timelineView.collection, 'update', postAnalysisView.onSocialMessageListUpdate );
		postAnalysisView.onSocialMessageListUpdate( timelineView.collection );

		// Editorial tasks.
		if ( NelioContent.helpers.isSubscribedTo( 'personal-plan' ) ) {
			postAnalysisView.listenTo( taskView.collection, 'reset', postAnalysisView.onTaskListUpdate );
			postAnalysisView.listenTo( taskView.collection, 'update', postAnalysisView.onTaskListUpdate );
			postAnalysisView.listenTo( taskView.collection, 'nc:change:model', postAnalysisView.onTaskListUpdate );
			postAnalysisView.onTaskListUpdate( taskView.collection );
		}//end if

		// Post values.
		postAnalysisView.listenTo( post, 'change', postAnalysisView.onPostChange );
		postAnalysisView.onPostChange( post );

		// Tags.
		$( '#tax-input-post_tag' ).on( 'change keyup', function() {
			var tags = NelioContent.helpers.trim( $( '#tax-input-post_tag' ).val() );
			tags = tags.replace( ', ', '' ).split( '' );
			postAnalysisView.onTagListUpdate( tags );
		});
		$( '#tax-input-post_tag' ).trigger( 'change' );

		// Yoast Integration.
		if ( NelioContent.postAnalysis.isYoastSeoIntegrated ) {

			// SEO.
			var updateYoastSeoScore = function() {

				var yoastStatus;

				var light = $( '#misc-publishing-actions .yoast-seo-score.keyword-score .image' );
				if ( light.hasClass( 'na' ) ) {
					yoastStatus = 'unknown';
				} else if ( light.hasClass( 'bad' ) ) {
					yoastStatus = 'bad';
				} else if ( light.hasClass( 'ok' ) ) {
					yoastStatus = 'improvable';
				} else {
					yoastStatus = 'good';
				}//end if

				postAnalysisView.onYoastSeoChange( yoastStatus );

			};//end updateYoastSeoScore()

			NelioContent.helpers.addStyle( '#misc-publishing-actions .yoast-seo-score.keyword-score { display:none!important; }' );
			$( window ).on( 'YoastSEO:numericScore', updateYoastSeoScore );
			updateYoastSeoScore();

			// Content.
			var updateYoastContentScore = function() {

				var yoastStatus;

				var light = $( '#misc-publishing-actions .yoast-seo-score.content-score .image' );
				if ( light.hasClass( 'na' ) ) {
					yoastStatus = 'unknown';
				} else if ( light.hasClass( 'bad' ) ) {
					yoastStatus = 'improvable';
				} else if ( light.hasClass( 'ok' ) ) {
					yoastStatus = 'improvable';
				} else {
					yoastStatus = 'good';
				}//end if

				postAnalysisView.onYoastContentChange( yoastStatus );

			};//end updateYoastContentScore()

			NelioContent.helpers.addStyle( '#misc-publishing-actions .yoast-seo-score.content-score { display:none!important; }' );
			$( window ).on( 'YoastSEO:numericScore', updateYoastContentScore );
			updateYoastContentScore();

		}//end if

		/**
		 * This function tells our post analysis that the content has changed and,
		 * therefore, that it might need to update its analysis.
		 *
		 * @param content {string} the content of this post.
		 *
		 * @since 1.0.4
		 */
		function refreshAnalysisView( content ) {

			var wordCount = parseInt( $( '#wp-word-count .word-count' ).text() );
			if ( isNaN( wordCount ) || 0 === wordCount ) {
				var counter = new wp.utils.WordCounter();
				wordCount = counter.count( content );
			}//end if

			postAnalysisView.onLinksChange( NelioContent.helpers.extractUrls( content ) );
			postAnalysisView.onImageCountChange( NelioContent.helpers.countImages( content ) );
			postAnalysisView.onTextLengthChange( wordCount );

		}//end refreshAnalysisView()

		/**
		 * This function tells our suggested references view that the content has changed,
		 * which means there might be more (or fewer) references, some of which might be
		 * suggested.
		 *
		 * @param content {string} The content of the post.
		 *
		 * @since 1.0.4
		 */
		function refreshSuggestedReferencesView( content ) {

			linksView.suggestedReferences.each( function( ref ) {
				ref.testIfIsInPostContent( content );
			});

		}//end refreshSuggestedReferencesView()

		// ==========================================================================
		// Updating views on certain events.
		// ==========================================================================

		// Update post analysis the very first time, so that word count works.
		postAnalysisView.onTextLengthChange( $( '#wp-word-count .word-count' ).text() );

		// 1) TinyMCE Editor Listener.
		$( document ).on( 'nc:tinymce-editor', function( event, editor ) {

			function contentChanged() {

				var content = editor.getContent();
				refreshAnalysisView( content );
				refreshSuggestedReferencesView( content );

			}//end contentChanged()

			editor.on( 'nodechange keyup',
				NelioContent.helpers.callAndDebounce( contentChanged, 4000, 1500 )
			);

			linksView.suggestedReferences.bind( 'add reset',
				NelioContent.helpers.callAndDebounce( function() {
					refreshSuggestedReferencesView( editor.getContent() );
				}, 4000, 1500 )
			);

		});
		if ( tinyMceEditor ) {
			$( document ).trigger( 'nc:tinymce-editor', tinyMceEditor );
		}//end if

		// 2) HTML Editor.
		(function() {

			var editor = $( '#content' );

			function contentChanged() {

				var content = editor.val();
				refreshAnalysisView( content );
				refreshSuggestedReferencesView( content );

			}//end contentChanged()

			editor.on( 'nodechange keyup',
				NelioContent.helpers.callAndDebounce( contentChanged, 4000, 1500 )
			);

			linksView.suggestedReferences.bind( 'add reset',
				NelioContent.helpers.callAndDebounce( function() {
					refreshSuggestedReferencesView( editor.val() );
				}, 4000, 1500 )
			);

		})();

		// 3. Other inputs.
		$postTitle.on( 'change', _.debounce( function() {
			post.set( 'title', NelioContent.helpers.decodeHTMLEntities( $postTitle.val() ) );
		}, 2000 ) );

		$postExcerpt.on( 'change', _.debounce( function() {
			post.set( 'excerpt', NelioContent.helpers.decodeHTMLEntities( $postExcerpt.val() ) );
		}, 2000 ) );

	}//end listenToEvents()


})( jQuery );
