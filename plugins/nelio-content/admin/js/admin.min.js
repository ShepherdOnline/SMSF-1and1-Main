/**
 * Generic admin settings.
 *
 * @author David Aguilera <david.aguilera@neliosoftware.com>
 * @since  1.0.0
 */
(function( $ ) {
	'use strict';

	// --------------------------------------------------------------------------
	// Configure momentjs.
	// --------------------------------------------------------------------------

	var locale = NelioContent.i18n.locale.toLowerCase().replace( '_', '-' );
	var shortLocale = locale;
	if ( shortLocale.indexOf( '-' ) > 0 ) {
		shortLocale = shortLocale.substr( 0, shortLocale.indexOf( '-' ) );
	}//end if

	$.fn.ncselect2.defaults.set( 'language', shortLocale );

	if ( _.contains( moment.locales(), locale ) ) {

		moment.updateLocale(
			locale, {
				calendar: {
					lastDay: NelioContent.i18n.date.lastDay,
					sameDay: NelioContent.i18n.date.sameDay,
					nextDay: NelioContent.i18n.date.nextDay,
					lastWeek: NelioContent.i18n.date.lastWeek,
					nextWeek: NelioContent.i18n.date.nextWeek,
					sameElse: NelioContent.i18n.date.default
				},
				week: {
					dow: NelioContent.i18n.startOfWeek
				}
			}
		);

	} else if ( _.contains( moment.locales(), shortLocale ) ) {

		moment.updateLocale(
			shortLocale, {
				calendar: {
					lastDay: NelioContent.i18n.date.lastDay,
					sameDay: NelioContent.i18n.date.sameDay,
					nextDay: NelioContent.i18n.date.nextDay,
					lastWeek: NelioContent.i18n.date.lastWeek,
					nextWeek: NelioContent.i18n.date.nextWeek,
					sameElse: NelioContent.i18n.date.default
				},
				week: {
					dow: NelioContent.i18n.startOfWeek
				}
			}
		);

	}//end if


	// --------------------------------------------------------------------------
	// Load helpers
	// --------------------------------------------------------------------------

	/**
	 * This file creates a variation of Backbone Model and Collection classes, so
	 * that they include an Authorization header.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		/**
		 * Backbone model super class with authentication.
		 *
		 * @constructor
		 * @augments Backbone.Model
		 *
		 * @since 1.0.0
		 */
		NelioContent.models.Model = Backbone.Model.extend({
	
			sync: function( method, collection, options ) {
				options = options || {};
				options.beforeSend = function( xhr ) {
					xhr.setRequestHeader( 'Authorization', 'Bearer ' + NelioContent.apiAuthToken );
				};
				return Backbone.Model.prototype.sync.apply( this, arguments );
			}//end sync()
	
		});
	
		/**
		 * Backbone collection super class with authentication.
		 *
		 * @constructor
		 * @augments Backbone.Collection
		 *
		 * @since 1.0.0
		 */
		NelioContent.collections.Collection = Backbone.Collection.extend({
	
			sync: function( method, collection, options ) {
				options = options || {};
				options.beforeSend = function( xhr ) {
					xhr.setRequestHeader( 'Authorization', 'Bearer ' + NelioContent.apiAuthToken );
				};
				return Backbone.Collection.prototype.sync.apply( this, arguments );
			}//end sync()
	
		});
	
	})( jQuery );
	
	/**
	 * This file defines some helper functions.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		/**
		 * Scroll ba width.
		 */
		var scrollbarWidth = -1;
	
		/**
		 * Requests a new API authentication token.
		 *
		 * @param success {function} Function to be called on completion.
		 * @param error   {function} Function to be called on error.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.refreshAuthToken = function( success, error ) {
	
			$.ajax({
	
				url: ajaxurl,
				data: {
					action: 'nelio_content_get_api_auth_token'
				},
	
				success: function( token ) {
	
					NelioContent.apiAuthToken = token;
	
					if ( typeof success === 'function' ) {
						success();
					}//end if
	
				},//end success()
	
				error: function( xhr ) {
	
					if ( typeof error === 'function' ) {
						error( xhr );
					}//end if
	
				}//end error()
	
			});
	
		};//end refreshAuthToken()
	
		/**
		 * Returns whether the current user is subscribed to a certain plan or not.
		 *
		 * @param reqPlan {string} the plan the user "should" be subscribed to.
		 * @param mode    {string} Optional. Whether the user has to be exactly
		 *                         subscribed to the given plan, or any plan above it
		 *                         works just fine too.  Default: or-above.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.isSubscribedTo = function( reqPlan, mode ) {
	
			if ( typeof mode === 'undefined' ) {
				mode = 'or-above';
			}//end if
	
			if ( 'none' === NelioContent.subscriptionPlan ) {
				return false;
			}//end if
	
			if ( reqPlan === NelioContent.subscriptionPlan ) {
				return true;
			}//end if
	
			if ( 'or-above' === mode ) {
	
				switch ( reqPlan ) {
	
					case 'personal-plan':
						return true;
	
				}//end switch
	
			}//end if
	
			return false;
	
		};//end isSubscribedTo()
	
		/**
		 * Returns the current window's width.
		 *
		 * @return {integer} The current window's width.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.getWindowWidth = function() {
	
			return $( window ).width();
	
		};//end getWindowWidth()
	
		/**
		 * Returns the scroll bar width (which might be different on different browsers).
		 *
		 * @return {integer} the scroll bar width (which might be different on different browsers).
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.getScrollbarWidth = function() {
	
			if ( scrollbarWidth >= 0 ) {
				return scrollbarWidth;
			}//end if
	
			var outer = document.createElement( 'div' );
			outer.style.visibility = 'hidden';
			outer.style.width = '100px';
			outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
	
			document.body.appendChild( outer );
			var widthNoScroll = outer.offsetWidth;
	
			// Force scrollbars.
			outer.style.overflow = 'scroll';
	
			// Add innerdiv.
			var inner = document.createElement( 'div' );
			inner.style.width = '100%';
			outer.appendChild( inner );
	
			var widthWithScroll = inner.offsetWidth;
	
			// Remove divs.
			outer.parentNode.removeChild( outer );
	
			// Save the value in our private variable and return it.
			scrollbarWidth = widthNoScroll - widthWithScroll;
			return scrollbarWidth;
	
		};//end isTime()
	
		/**
		 * This function opens a new browser window, completely centered in the parent window.
		 *
		 * Source: http://www.xtf.dk/2011/08/center-new-popup-window-even-on.html
		 *
		 * @param url    {string} the URL that has to be opened.
		 * @param width  {string} new window's width in `px`.
		 * @param height {string} new window's height in `px`.
		 *
		 * @return {object} a reference to the new window.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.openPopup = function( url, width, height ) {
	
			var dualScreenLeft = typeof window.screenLeft !== 'undefined' ? window.screenLeft : screen.left;
			var dualScreenTop = typeof window.screenTop !== 'undefined' ? window.screenTop : screen.top;
	
			var w = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
			var h = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
	
			var left = ( ( w / 2 ) - ( width / 2 ) ) + dualScreenLeft;
			var top = ( ( h / 2 ) - ( height / 2 ) ) + dualScreenTop;
			var popup = window.open( url, '', 'width=' + width + ', height=' + height + ', top=' + top + ', left=' + left );
	
			// Puts focus on the newWindow
			if ( window.focus ) {
				popup.focus();
			}//end if
	
			return popup;
	
		};//end openPopup()
	
		/**
		 * Appends a style element.
		 *
		 * @param css {string} the CSS rules that will be included in the new style node.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.addStyle = function( css ) {
	
			var head = document.head || document.getElementsByTagName( 'head' )[0];
			var style = document.createElement( 'style' );
	
			style.type = 'text/css';
			if ( style.styleSheet ) {
				style.styleSheet.cssText = css;
			} else {
				style.appendChild( document.createTextNode( css ) );
			}//end if
	
			head.appendChild( style );
	
		};//end addStyle()
	
		/**
		 * Calls a certain function after a certain delay and returns a debounced
		 * version of that function.
		 *
		 * @param fn        {function} the function you want to debounce.
		 * @param debounce  {integer}  number of ms to debounce the function.
		 * @param delay     {integer}  Optional. Number of ms to wait until fn is
		 *                             called for the first time. Default: 0.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.callAndDebounce = function( fn, debounce, delay ) {
	
			if ( typeof delay !== 'number' ) {
				delay = 0;
			}//end if
	
			// Prepare first call function.
			var isCalled = false;
			var firstCallFunction = function() {
				fn();
				isCalled = true;
			};//end firstCallFunction()
	
			if ( 0 === delay ) {
				firstCallFunction();
			} else {
				setTimeout( firstCallFunction, delay );
			}//end if
	
			// Prepare the function for successive calls.
			var debouncedFn = _.debounce( fn, debounce );
	
			// Return a new function that uses these two.
			var res = function() { if ( isCalled ) debouncedFn() };
			return res;
	
		};//end callAndDebounce()
	
	})( jQuery );
	
	/**
	 * This file defines some string helper functions.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		/**
		 * Trims spaces before and after a given string.
		 *
		 * @param string {string} The string to be trimmed.
		 *
		 * @return {string} trimmed version of the given string.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.trim = function( string ) {
	
			if ( typeof string !== 'string' ) {
				return string;
			}//end if
	
			return string.replace( /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '' );
	
		};//end trim()
	
		/**
		 * Capitalizes the first letter of a string.
		 *
		 * @param string {string} The string whose first letter has to be capitalized.
		 *
		 * @return {string} the given string with its first letter capitalized.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.capitalizeFirstLetter = function( string ) {
	
			if ( typeof string !== 'string' ) {
				return '';
			}//end if
	
			return string.charAt( 0 ).toUpperCase() + string.slice( 1 );
	
		};//end capitalizeFirstLetter()
	
		/**
		 * Looks for a given term in the given string and surrounds said term with
		 * `strong` tags.
		 *
		 * @param string {string} The haystack.
		 * @param string {term}   The needle.
		 *
		 * @return {string} the given string, with all appearances of `term`
		 *                  surrounded by `strong` tags.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.strongify = function( string, term ) {
	
			term = term.replace( '\\', '' );
			term = term.replace( '.', '\\.' );
			var re = new RegExp( term, 'gi' );
			return string.replace( re, '<strong>$&</strong>' );
	
		};//end strongify()
	
		/**
		 * Helper element for rendering a string.
		 */
		var decoderElement = document.createElement( 'div' );
	
		/**
		 * This method decodes all HTML entites of any given string.
		 *
		 * Source: http://stackoverflow.com/questions/5796718/html-entity-decode/9609450#9609450
		 *
		 * @param string {string} The string to be decoded.
		 *
		 * @return {string} A decoded version of the given string.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.decodeHTMLEntities = function( string ) {
	
			if ( typeof string !== 'string' ) {
				return '';
			}//end if
	
			string = string.replace( /<script[^>]*>([\S\s]*?)<\/script>/gmi, '' );
			string = string.replace( /<\/?\w(?:[^"'>]|"[^"]*"|'[^']*')*>/gmi, '' );
			decoderElement.innerHTML = string;
			string = decoderElement.textContent;
	
			return NelioContent.helpers.trim( string );
	
		};//end decodeHTMLEntities()
	
		/**
		 * This method extracts the first letter of the latinized version of string,
		 * or "undefined" if none is found.
		 *
		 * @param string {string} The string whose first letter has to be extracted.
		 *
		 * @return {string} the first letter of the latinized version of string, or
		 *                  "unknown" if none is found.
		 *
		 * @since 1.0.5
		 */
		NelioContent.helpers.extractFirstLetter = function( string ) {
	
			var latinString = latinize( string.toLowerCase() ).replace( /[^a-z]/g, '' );
	
			if ( latinString.length > 0 ) {
				return latinString.substring( 0, 1 );
			} else {
				return 'unknown';
			}//end if
	
	
		};//end strongify()
	
	})( jQuery );
	
	/**
	 * This file extends jQuery's dialog by creating a new class named `dialogS2`.
	 * When a dialog is supposed to contain a ncselect2 component, this new class
	 * allows proper interaction.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		// Hack to permit the ncselect2 selector in the dialog.
		$.widget( 'ui.dialogS2', $.ui.dialog, {
	
			_allowInteraction: function( ev ) {
				return true;
			}//end _allowInteraction()
	
		});//end $.widget()
	
		/**
		 * Opens a modal dialog awaiting for deletion confirmation. It only contains two buttons:
		 *
		 *  * Default `Cancel` button.
		 *  * A 3D delete button with the given label.
		 *
		 * @param title   {string} Dialog's title.
		 * @param message {string} Dialog's content.
		 * @param button  {string} label of the delete button.
		 *
		 * @return {object} The jQuery element to which we applied the `dialog` function.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.openDeletionConfirmationDialog = function( title, message, button, onConfirm ) {
	
			var $el = $( '<div>' + message + '</div>' );
	
			$el.dialog({
	
				title: title,
				modal: true,
				width: Math.min( 500, $( window ).width() - 20 ),
	
				buttons: [
	
					{
						'class': 'button nc-cancel-button',
						text: NelioContent.i18n.actions.cancel,
						click: function() {
							$el.dialog( 'close' );
						}//end click()
					},
	
					{
						'class': 'button nc-super-delete-button',
						text: button,
						click: function() {
							onConfirm();
						}//end click()
					}
	
				]
	
			});
	
			return $el;
	
		};//end openDeletionConfirmationDialog()
	
		/**
		 * Opens a modal dialog to display an error message.
		 *
		 * @param title   {string} Dialog's title.
		 * @param message {string} Dialog's content.
		 *
		 * @return {object} The jQuery element to which we applied the `dialog` function.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.openWarningDialog = function( title, message ) {
	
			var $el = $( '<div class="nc-error-dialog">' + message + '</div>' );
	
			$el.dialog({
	
				title: title,
				modal: true,
				width: Math.min( 500, $( window ).width() - 20 ),
	
				buttons: [{
					'class': 'button nc-cancel-button',
					text: NelioContent.i18n.actions.ok,
					click: function() {
						$el.dialog( 'close' );
						$el.dialog( 'destroy' );
					}//end click()
				}]
	
			});
	
			return $el;
	
		};//end NelioContent.helpers.openWarningDialog()
	
		/**
		 * Opens a modal dialog to display an error message.
		 *
		 * @param message {string} Dialog's content.
		 *
		 * @return {object} The jQuery element to which we applied the `dialog` function.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.openErrorDialog = function( message ) {
	
			message = '<span class="nc-dashicons nc-dashicons-warning"></span> ' + message;
			NelioContent.helpers.openWarningDialog( NelioContent.i18n.titles.error, message );
	
		};//end openErrorDialog()
	
		/**
		 * Creates a dialog button that fires the specified event.
		 *
		 * In particular, it'll trigger the following event:
		 * `nc:click:dialog:{eventName}`, where `{eventName}` is the specified event.
		 *
		 * @param view      {object} The view related to this dialog.
		 * @param eventName {string} The event to be fired when the button is clicked.
		 * @param label     {string} Button's label.
		 * @param isPrimary {string} Optional. Whether the button is "primary" or not (CSS class).
		 *
		 * @return {object} The button, ready to be used in a jQuery dialog object.
		 *
		 * @since 1.0.5
		 */
		NelioContent.helpers.makeDialogButton = function( view, eventName, label, isPrimary ) {
	
			var buttonClass = 'button';
			if ( isPrimary ) {
				buttonClass = 'button button-primary';
			}//end if
	
			return {
	
				'class': buttonClass + ' nc-' + eventName + '-button',
				text: label,
	
				/**
				 * Click callback.
				 *
				 * @param ev {object} The JavaScript event that triggered the callback.
				 *
				 * @since 1.0.0
				 */
				click: function( ev ) {
	
					var target = ev.target || ev.srcElement;
					var $button = $( target ).closest( 'button' );
					if ( $button.hasClass( 'button-disabled' ) ) {
						return;
					}//end if
	
					view.trigger( 'nc:click:dialog:' + eventName, ev );
	
				}//end click()
	
			};
	
		};//end makeDialogSaveButton()
	
		/**
		 * Creates a save button. When clicked, it triggers the event:
		 * `nc:click:dialog:save` on the related view.
		 *
		 * @param view  {object} The view related to this dialog.
		 * @param label {string} Button's label.
		 *
		 * @return {object} The button, ready to be used in a jQuery dialog object.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.makeDialogSaveButton = function( view, label ) {
	
			return NelioContent.helpers.makeDialogButton( view, 'save', label, true );
	
		};//end makeDialogSaveButton()
	
		/**
		 * Creates a cancel button. When clicked, it triggers the event:
		 * `nc:click:dialog:cose` on the related view.
		 *
		 * @param view  {object} The view related to this dialog.
		 * @param label {string} Button's label.
		 *
		 * @return {object} The button, ready to be used in a jQuery dialog object.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.makeDialogCancelButton = function( view, label ) {
	
			return NelioContent.helpers.makeDialogButton( view, 'cancel', label );
	
		};//end makeDialogCancelButton()
	
		/**
		 * Creates a delete button. When clicked, it triggers the event:
		 * `nc:click:dialog:delete` on the related view.
		 *
		 * @param view  {object} The view related to this dialog.
		 * @param label {string} Button's label.
		 *
		 * @return {object} The button, ready to be used in a jQuery dialog object.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.makeDialogDeleteButton = function( view, label ) {
	
			return NelioContent.helpers.makeDialogButton( view, 'delete', label );
	
		};//end makeDialogDeleteButton()
	
		/**
		 * Modifies the given element so that it uses jQuery's tooltip instead of native's.
		 *
		 * @param $el {object} The element that will use jQuery's tooltip.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.makeWarningTooltip = function( $el ) {
	
			if ( typeof $el === 'undefined' ) {
				console.error( 'Error. Cannot create jQuery tooltip.' );
				return;
			}//end if
	
			if ( $el.length === 0 ) {
				console.error( 'Error. Cannot create jQuery tooltip.' );
				return;
			}//end if
	
			$el.tooltip({
				position: { my: 'right bottom', at: 'right+5 top-5' },
				tooltipClass: 'nc_tooltip nc_warning_tooltip',
				show: false,
				hide: false
			});
	
		};//end makeWarningTooltip
	
	})( jQuery );
	
	/**
	 * This file implements some useful functions related to media.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		/**
		 * Opens an image selector dialog with the given arguments.
		 *
		 * Args object may contain the following keys:
		 *
		 *  * onSelection: Callback function to be called when the user chooses an image.
		 *  * onClose:     Optional. Callback function to be called when the user closes the dialog without selecting any image.
		 *  * image:       Optional. Default image that has to be selected.
		 *
		 *
		 * @param args {object} An image object, as returned by `wp.media`.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.selectImage = function( args ) {
	
			if ( typeof args === 'undefined' ) {
				args = {};
			}//end if
	
			if ( typeof args.onSelection !== 'function' ) {
				args.onSelection = function(){};
			}//end if
	
			var shareImageFrame = wp.media.frames.shareImageFrame = wp.media({
				title: NelioContent.i18n.titles.selectImage,
				button: {
					text: NelioContent.i18n.actions.choose
				},
				multiple: false
			});
	
			// When an image is selected, call the "onSelection" function with said image.
			shareImageFrame.on( 'select', function() {
				var attachment = shareImageFrame.state().get('selection').first().toJSON();
				args.onSelection( attachment );
			});
	
			// Set default image.
			if ( typeof args.image === 'number' ) {
				shareImageFrame.on( 'open', function() {
					var selection = wp.media.attachment( args.image );
					shareImageFrame.state().get( 'selection' ).add( selection );
				});
			}//end if
	
			// When the selector is closed, call the "onClose" function
			if ( typeof args.onClose === 'function' ) {
				shareImageFrame.on( 'close', args.onClose );
			}//end if
	
			// Finally, open the modal
			shareImageFrame.open();
	
		};//end selectImage()
	
	})( jQuery );
	
	/**
	 * This file defines some helper functions with dates.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		var dateRegex = /20[0-9][0-9]-[01][0-9]-[0-3][0-9]/;
		var timeRegex = /[012][0-9]:[0-5][0-9]/;
	
		/**
		 * This helper function sets the timezone of a given moment object to
		 * the specified timezone.
		 *
		 * @param moment   {moment} A moment.
		 * @param timezone {string} Optional. The timezone the moment object has to be set to.
		 *
		 * @return moment The inpunt moment, with its timezone changed.
		 *
		 * @since 1.0.0
		 */
		window.ncLocalizeMoment = function( moment, timezone ) {
	
			// Load default timezone if none was set.
			if ( typeof timezone === 'undefined' ) {
				timezone = NelioContent.i18n.timezone;
			}//end if
	
			if ( timezone.indexOf( ':' ) > 0 ) {
				moment.utcOffset( timezone );
			} else {
				moment.tz( timezone );
			}//end if
	
			return moment;
	
		};//end ncLocalizeMoment()
	
		/**
		 * Creates a new moment object with a given local date and timezone.
		 *
		 * @param localDate {string} Optional. A local date.
		 * @param timezone  {string} Optional. The timezone used for converting the
		 *                           local date to UTC. Default:
		 *                           `NelioContent.i18n.timezone`.
		 *
		 * @return {moment} A moment object set to the given local date and timezone.
		 *
		 * @since 1.0.0
		 */
		window.ncNewLocalMoment = function( localDate, timezone ) {
	
			// If we don't have a local date, create a moment right now.
			if ( typeof localDate !== 'string' ||
					NelioContent.helpers.trim( localDate ) === '' ) {
				localDate = ncLocalizeMoment( moment() ).format( 'YYYY-MM-DD HH:mm' );
			}//end if
	
			// If the local date doesn't include an hour, let's add it or else
			// timezone offsets would fail.
			if ( /^[0-9]{4}.[0-9]{2}.[0-9]{2}/.test( localDate ) &&
					! /^[0-9]{4}.[0-9]{2}.[0-9]{2}.[0-9]{2}:[0-9]/.test( localDate ) ) {
				localDate = NelioContent.helpers.trim( localDate ) + ' 12:00';
			}//end if
	
			// Load default timezone if none was set.
			if ( typeof timezone === 'undefined' ) {
				timezone = NelioContent.i18n.timezone;
			}//end if
	
			// Return the result.
			if ( timezone.indexOf( ':' ) > 0 ) {
				return ncLocalizeMoment( moment( localDate + timezone ), timezone );
			} else {
				return ncLocalizeMoment( moment.tz( localDate, timezone ), timezone );
			}//end if
	
		};//end ncNewLocalMoment()
	
		/**
		 * Checks whether a given string is a date or not. A string is a date if it
		 * looks like this: YYYY-MM-DD.
		 *
		 * @param date {string} Any string (presumably, a date).
		 *
		 * @return {boolean} whether the given string is a date or not.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.isDate = function( date ) {
	
			return dateRegex.test( date );
	
		};//end isDate()
	
		/**
		 * Checks whether a given string is a time or not. A string is a time if it
		 * looks like this: HH:MM
		 *
		 * @param date {string} Any string (presumably, a time).
		 *
		 * @return {boolean} whether the given string is a time or not.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.isTime = function( time ) {
	
			return timeRegex.test( time );
	
		};//end isTime()
	
	})( jQuery );
	
	/**
	 * This file defines a helper function for extracting URLs from a given
	 * content.
	 *
	 * @since 1.0.0
	 */
	(function( $ ) {
	
		'use strict';
	
		/**
		 * Regular expression for matching links. In other words, the `href`
		 * attribute of an `a` tag.
		 */
		var urlMatcher = /<a[^>]+href=("[^"]*"|'[^']*')/gi;
	
		/**
		 * Regular expression for matching image tags.
		 */
		var imgMatcher = /<img[^>]+src=("[^"]*"|'[^']*')/gi;
	
		/**
		 * A cache of URLs that can be referenced (that is, they aren't an image, or a video, or a zip, etc).
		 */
		var citableUrls = [];
	
		/**
		 * A list of file extensions (links that should not be considered "page URLs").
		 */
		var fileExtensions = [
			// Image extensions.
			'jpg', 'png', 'tif', 'bmp', 'svg', 'pgm', 'pbm', 'pnm', 'hdr',
			'bpg', 'cpt', 'psd', 'psp', 'xcf', 'ppm', 'dwf', 'dwg', 'dxf',
			'jpeg', 'tiff', 'webp', 'heif',
			// Video extensions.
			'mkv', 'flv', 'avi', 'mov', 'vob', 'ogv', 'ogg', 'drc', 'mng',
			'mov', 'wmv', 'yuv', 'asf', 'mp4', 'm4p', 'm4v', 'mpg', 'mpe',
			'mpv', 'mp2', 'm2v', 'm4v', 'svi', '3gp', '3g2', 'mxf', 'roq',
			'nsv', 'f4v', 'f4p', 'f4a', 'f4b',
			'rm', 'qt', 'webm', 'gifv', 'rmvb', 'mpeg',
			// Other extensions.
			'zip', 'rar', '3ds', 'x3d', 'xgl', 'pub',
			'7z', 'po', 'pot', 'js', 'css', 'scss'
		];
	
		/**
		 * This function counts the number of `img` tags that appear in `content`.
		 *
		 * @param content string The content from which to extract the URLs.
		 *
		 * @return integer number of `img` tags found.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.countImages = function( content ) {
	
			var matches = content.match( imgMatcher );
			if ( typeof matches === 'undefined' || null === matches ) {
				return 0;
			} else {
				return matches.length;
			}//end if
	
		};
	
		/**
		 * This function extracts all the citable URLs from the given content.
		 *
		 * A citable URL is a URL that links to a web page or some documents (such
		 * as PDFs or DOC files). In other words, URLs that doen't point to images,
		 * videos, or some files such as zips, rars, and so on.
		 *
		 * @param content string The content from which to extract the URLs.
		 *
		 * @return array A list of citable URLs.
		 *
		 * @since 1.0.0
		 */
		NelioContent.helpers.extractUrls = function( content ) {
	
			var matches;
			var result = [];
	
			while ( ( matches = urlMatcher.exec( content ) ) ) {
	
				var url = matches[1];
				url = url.substring( 1, url.length - 1 );
	
				if ( isCitable( url ) && _.indexOf( result, url ) === -1 ) {
	
					result.push( url );
	
				}//end if
	
			}//end while
	
			return result;
	
		};//end extractUrls()
	
		/**
		 * Whether the given URL is citable or not.
		 *
		 * @param url string A URL.
		 *
		 * @return boolean Whether the given URL is citable or not.
		 *
		 * @since 1.0.0
		 */
		function isCitable( url ) {
	
			if ( _.indexOf( citableUrls, url ) !== -1 ) {
	
				return true;
	
			} else {
	
				var ext = extractExtensionIfAny( url );
				if ( ext.length > 0 && _.indexOf( fileExtensions, ext ) !== -1 ) {
					return false;
				} else {
					citableUrls.push( url );
					return true;
				}//end if
	
			}//end if
	
		}//end isCitable()
	
		/**
		 * This function extracts the extension of the (possible) document linked in
		 * the URL.
		 *
		 * @param url string A URL that may (or may not) point to a file.
		 *
		 * @return string If the URL points to a known file type, its extension is
		 *                returned. Otherwise, an empty string is returned.
		 *
		 * @since 1.0.0
		 */
		function extractExtensionIfAny( url ) {
	
			// Remove GET parameters (if any)
			var paramsPosition = url.indexOf( '?' );
			if ( -1 !== paramsPosition ) {
				url = url.substring( 0, paramsPosition );
			}//end if
	
			// If we're not in a relative path, make sure to ignore URL's domain.
			if ( /^https?:\/\//i.test( url ) ) {
	
				url = url.replace( /^https?:\/\//i, '' );
	
				// Let's see if we're accessing a resource in the domain.
				var firstSlash = url.indexOf( '/' );
				if ( -1 !== firstSlash ) {
					url = url.substring( firstSlash, url.length );
				} else {
					// If we're not accessing any resource, we're sure there's no
					// extension awaiting.
					return '';
				}//end if
	
			}//end if
	
			// Extract the extension.
			var ext = url.substring( Math.max( 0, url.length - 6 ), url.length );
			var dotPosition = ext.indexOf( '.' );
			if ( -1 !== dotPosition ) {
				return ext.substring( dotPosition + 1, ext.length ).toLowerCase();
			} else {
				return '';
			}//end if
	
		}//end extractExtensionIfAny()
	
	})( jQuery );
	

	// --------------------------------------------------------------------------
	// Refresh API token every 10 minutes.
	// --------------------------------------------------------------------------
	setInterval( NelioContent.helpers.refreshAuthToken, 600000 );

	// --------------------------------------------------------------------------
	// Initialize Social Profiles
	// --------------------------------------------------------------------------

	/**
	 * Backbone model of a Social Profile.
	 *
	 * @constructor
	 * @augments NelioContent.models.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.SocialProfile = NelioContent.models.Model.extend({
	
		/**
		 * Whether the network of this social profile allows the selection of
		 * multiple targets or not.
		 */
		_allowsMultiTargets: false,
	
		/**
		 * Whether the network of this social profile requires the user to share an
		 * image or not.
		 */
		_isImageRequired: false,
	
		/**
		 * URL root for accessing the API.
		 */
		urlRoot: NelioContent.apiUri + '/profile',
	
		/**
		 * Default values.
		 */
		defaults: function() { return {
	
			calendarId: '',
	
			profileId: '',
			network: '',
			kind: '',
	
			photo: '',
			creationDate: ncNewLocalMoment(),
	
			displayName: '',
			firstLetter: '',
	
			creatorId: 0,
			creatorDisplayName: '',
			creatorEditLink: '',
	
			username: '',
	
			status: 'valid'
	
		}; },
	
		/**
		 * User that created this profile.
		 */
		_creator: false,
	
		/**
		 * Initializes this model.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'change:displayName', this._setFirstLetter );
			this._setFirstLetter();
	
			this.listenTo( this, 'change:displayName', this._escapeNameAndUsername );
			this.listenTo( this, 'change:username', this._escapeNameAndUsername );
			this._escapeNameAndUsername();
	
			this.listenTo( this, 'change:creationDate', this._fixCreationDateFormat );
			this._fixCreationDateFormat();
	
			this.listenTo( this, 'change:network', this._fixAllowsMultiTargets );
			this._fixAllowsMultiTargets();
	
			this.listenTo( this, 'change:network', this._fixImageIsRequired );
			this._fixImageIsRequired();
	
			this.listenTo( this, 'change:creatorId', this._changeCreator );
			this._changeCreator();
	
		},//end initialize()
	
		/**
		 * Returns whether this social profile's network allows multiple targets or not.
		 *
		 * @return {boolean} whether this social profile's network allows multiple targets or not.
		 *
		 * @since 1.0.0
		 */
		allowsMultiTargets: function() {
	
			return this._allowsMultiTargets;
	
		},//end allowsMultiTargets()
	
		/**
		 * Returns whether this social profile's network requires the user to share an image or not.
		 *
		 * @return {boolean} whether this social profile's network requires the user to share an image or not.
		 *
		 * @since 1.0.0
		 */
		requiresImageToShare: function() {
	
			return this._isImageRequired;
	
		},//end requiresImageToShare()
	
		/**
		 * Callback function that updates the first letter attribute of this
		 * instance, based on the first letter of its name.
		 *
		 * @since 1.0.0
		 */
		_setFirstLetter: function() {
	
			this.set( 'firstLetter', NelioContent.helpers.extractFirstLetter( this.get( 'displayName' ) ) );
	
		},//end _setFirstLetter()
	
		/**
		 * Makes sure that creation date is an instance of moment.
		 *
		 * @since 1.0.0
		 */
		_fixCreationDateFormat: function() {
	
			var creationDate = this.get( 'creationDate' );
	
			if ( typeof creationDate === 'string' ) {
				this.set( 'creationDate', ncNewLocalMoment( creationDate ) );
			}//end if
	
		},//end _fixCreationDateFormat()
	
		/**
		 * Callback function that updates some fields about the user that
		 * added this social profile, such as his name and the edit link.
		 *
		 * @since 1.0.5
		 */
		_changeCreator: function() {
	
			if ( this._creator ) {
				this.stopListening( this._creator );
				this._creator = false;
			}//end if
			this._creator = NelioContent.users.getUser( this.get( 'creatorId' ) );
			var creator = this._creator;
	
			if ( creator.valid() ) {
				this.set( 'creatorDisplayName', creator.get( 'name' ) );
				this.set( 'creatorEditLink', creator.get( 'editLink' ) );
			} else {
				this.set( 'creatorDisplayName', '' );
				this.set( 'creatorEditLink', '' );
			}//end if
	
			// Listen to event changes.
			var model = this;
			this.listenTo( creator, 'nc:load', function() {
				if ( creator.valid() ) {
					model.set( 'creatorDisplayName', creator.get( 'name' ) );
					model.set( 'creatorEditLink', creator.get( 'editLink' ) );
				} else {
					model.set( 'creatorDisplayName', '' );
					model.set( 'creatorEditLink', '' );
				}//end if
			});
	
		},//end _changeCreator()
	
		/**
		 * Escapes the name and username.
		 *
		 * @since 1.0.0
		 */
		_escapeNameAndUsername: function() {
	
			var username = this.get( 'username' );
			if ( 'twitter' === this.get( 'network' ) && username[0] !== '@' ) {
				username = '@' + username;
				this.set( 'username', username );
			}//end if
	
			this.set( 'displayNameEscaped', _.escape( this.get( 'displayName' ) ) );
			this.set( 'usernameEscaped', _.escape( this.get( 'username' ) ) );
	
		},//end _escapeNameAndUsername()
	
		/**
		 * Updates the private property `_allowsMultiTargets` based on the meta
		 * information we have about the network.
		 *
		 * @since 1.0.0
		 */
		_fixAllowsMultiTargets: function() {
	
			var networkMeta = _.findWhere( NelioContent.networkMetas, {
				id: this.get( 'network' )
			});
			if ( typeof networkMeta !== 'undefined' && networkMeta.allowsMultiTargets ) {
				this._allowsMultiTargets = true;
			} else {
				this._allowsMultiTargets = false;
			}//end if
	
		},//end _fixAllowsMultiTargets()
	
		/**
		 * Updates the private property `_isImageRequired` based on the meta
		 * information we have about the network.
		 *
		 * @since 1.0.0
		 */
		_fixImageIsRequired: function() {
	
			var networkMeta = _.findWhere( NelioContent.networkMetas, {
				id: this.get( 'network' )
			});
			if ( typeof networkMeta !== 'undefined' && networkMeta.isImageRequired ) {
				this._isImageRequired = true;
			} else {
				this._isImageRequired = false;
			}//end if
	
		}//end _fixImageIsRequired()
	
	});//end class
	
	
	/**
	 * List of social profiles connected to Nelio Content.
	 *
	 * @constructor
	 * @augments NelioContent.collections.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.ConnectedSocialProfiles = NelioContent.collections.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.SocialProfile,
	
		/**
		 * Whether social profiles have been loaded or not.
		 */
		_isReady: false,
	
		/**
		 * Returns whether social profiles have been loaded or not.
		 *
		 * @return {boolean} whether social profiles have been loaded or not.
		 *
		 * @since 1.0.0
		 */
		isReady: function() {
	
			return this._isReady;
	
		},//end isReady()
	
		/**
		 * Alias for `reload`.
		 *
		 * @since 1.0.0
		 */
		populate: function() {
	
			this.reload();
	
		},//end reload()
	
		/**
		 * Loads the list of social profiles from AWS.
		 *
		 * See API call: /profiles
		 *
		 * @since 1.0.0
		 */
		reload: function() {
	
			this._isReady = false;
	
			var collection = this;
			$.ajax({
	
				url: NelioContent.apiUri + '/profiles',
				method: 'GET',
				headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },
	
				success: function( result ) {
	
					collection._isReady = true;
					collection.reset( result );
					collection.trigger( 'nc:ready' );
	
				}//end success()
	
			});
	
		}//end reload()
	
	});//end class
	
	

	NelioContent.profiles = new NelioContent.collections.ConnectedSocialProfiles();
	NelioContent.profiles.populate();

	// --------------------------------------------------------------------------
	// Initialize Users Collection
	// --------------------------------------------------------------------------

	/**
	 * Backbone model of a WordPress user.
	 *
	 * @constructor
	 * @augments Backbone.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.User = Backbone.Model.extend({
	
		/**
		 * Default values.
		 */
		defaults: {
	
			email: '',
			name: NelioContent.i18n.unknownUserName,
			photo: '',
			role: 'subscriber',
	
			loading: false,
			existsInWordPress: true
	
		},
	
		/**
		 * Initializes this model.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'change:name', this._setFirstLetter );
			this._setFirstLetter();
	
		},//end initialize()
	
		/**
		 * Loads the user information.
		 *
		 * @since 1.0.5
		 */
		loadData: function() {
	
			if ( this.get( 'loading' ) ) {
				return;
			}//end if
	
			if ( ! this.get( 'id' ) ) {
				this.set( 'loading', false );
				this.set( 'existsInWordPress', false );
				return;
			}//end if
	
			this.set( 'loading', true );
	
			var model = this;
			$.ajax({
	
				url: ajaxurl,
	
				data: {
					action: 'nelio_content_get_user',
					user: model.get( 'id' )
				},
	
				success: function( data ) {
	
					data.loading = false;
					data.existsInWordPress = true;
	
					model.set( data );
					model.trigger( 'nc:load' );
	
				},//end success()
	
				error: function() {
	
					var data = {
						loading: false,
						existsInWordPress: false
					};
	
					model.set( data );
					model.trigger( 'nc:load:error' );
	
				}//end error()
	
			});
	
		},//end loadData()
	
		/**
		 * Returns whether this user is valid or not.
		 *
		 * A user is valid if it's not being loaded an exists in WordPress.
		 *
		 * @return {boolean} whether this user is valid or not.
		 *
		 * @since 1.0.5
		 */
		valid: function() {
	
			return ! this.get( 'loading' ) && this.get( 'existsInWordPress' );
	
		},//end valid()
	
		/**
		 * Returns whether this current user is being loaded or not.
		 *
		 * @return {boolean} whether this current user is being loaded or not.
		 *
		 * @since 1.0.5
		 */
		isLoading: function() {
	
			return this.get( 'loading' );
	
		},//end isLoading()
	
		/**
		 * Callback function that updates the first letter attribute of this
		 * instance, based on the first letter of its name.
		 *
		 * @since 1.0.0
		 */
		_setFirstLetter: function() {
	
			var name = this.get( 'name' );
			if ( name === NelioContent.i18n.unknownUserName ) {
				name = '';
			}//end if
	
			this.set( 'firstLetter', NelioContent.helpers.extractFirstLetter( name ) );
	
		}//end _setFirstLetter()
	
	});//end class
	
	
	/**
	 * List of users in this WordPress.
	 *
	 * @constructor
	 * @augments Backbone.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.Users = Backbone.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.User,
	
		/**
		 * Returns the current user.
		 *
		 * @return User the current user.
		 *
		 * @since 1.0.0
		 */
		current: function() {
	
			return this.get( NelioContent.userId );
	
		},//end current()
	
		/**
		 * Returns the user whose ID is the given one, or a new User (that acts as an
		 * "Unknown" user).
		 *
		 * @param id {array} the ID of the user we want to obtain.
		 *
		 * @return User the user whose ID is the given one, or a new User (that acts
		 *              as an "Unknown" user).
		 *
		 * @since 1.0.0
		 */
		getUser: function( id ) {
	
			// Look for the user in the collection.
			var user = this.get( id );
	
			// If it doesn't exist, let's create a new "fake" user, which will act as
			// an "Unknown" user.
			if ( typeof user === 'undefined' ) {
				user = new NelioContent.models.User({ id: id });
				user.loadData();
				this.add( user );
			}//end if
	
			return user;
	
		}//end getUser()
	
	});//end class
	
	

	// Convert users array to Backbone collection.
	NelioContent.users = new NelioContent.collections.Users( NelioContent.users );

	// --------------------------------------------------------------------------
	// Load all models and collections
	// --------------------------------------------------------------------------

	/**
	 * Backbone model to represent an AJAX error.
	 *
	 * @constructor
	 * @augments Backbone.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.AjaxError = Backbone.Model.extend({
	
		/**
		 * Default values.
		 */
		defaults: function() { return {
	
			code: 0,
			message: '',
	
		}; },
	
		/**
		 * Initializes this object.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Nothing to be done here.
	
		},//end initialize()
	
		/**
		 * Initializes this model with the data in the jqXHR object.
		 *
		 * @param xhr {object} a jqXHR object.
		 *
		 * @since 1.0.0
		 */
		parseResponse: function( xhr ) {
	
			var code = 503;
			var message = NelioContent.i18n.errors.api.emptyAjaxStatus;
	
			if ( 0 !== xhr.status ) {
				code = xhr.status;
			}//end if
	
			if ( typeof xhr.reponseJSON === 'string' ) {
				message = xhr.responseJSON;
			}//end if
	
			this.set( 'code', code );
			this.set( 'message', message );
	
		}//end parseResponse()
	
	});//end class
	
	/**
	 * Backbone model of a post.
	 *
	 * @constructor
	 * @augments Backbone.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.Post = Backbone.Model.extend({
	
		/**
		 * Default values.
		 */
		defaults: function() { return {
	
			id: 0,
			type: NelioContent.postTypes[0].name,
			status: 'draft',
	
			calendarKind: 'post',
	
			title: '',
			excerpt: '',
			editLink: '',
			permalink: '',
			categories: [],
	
			titleFormatted: '',
			excerptFormatted: '',
	
			author: 0,
			autoImage: '',
			imageId: 0,
			image: '',
			date: false
	
		}; },
	
		/**
		 * Initializes this object.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'change:permalink', this._checkPermalink );
			this._checkPermalink();
	
			this.listenTo( this, 'change:id', this._fixPostIdType );
			this._fixPostIdType();
	
			this.listenTo( this, 'change:imageId', this._fixImageIdType );
			this._fixImageIdType();
	
			this.listenTo( this, 'change:date', this._fixDateFormat );
			this._fixDateFormat();
	
			this.listenTo( this, 'change:title', this._escapeTitle );
			this.listenTo( this, 'change:excerpt', this._escapeExcerpt );
			this._maybeUnescapeTitleAndExcerpt();
	
		},//end initialize()
	
		/**
		 * Returns whether this post's status is publish or not.
		 *
		 * @return {boolean} whether this post's status is publish or not.
		 *
		 * @since 1.0.0
		 */
		isPublished: function() {
	
			return 'publish' === this.get( 'status' );
	
		},//end isPublished()
	
		/**
		 * Returns whether the post is scheduled or not.
		 *
		 * A post is scheduled when the following conditions are met:
		 *
		 *  * it's not published,
		 *  * there's a publication date, and
		 *  * the publication date is set in the future.
		 *
		 * @return {boolean} whether the post is scheduled or not.
		 *
		 * @since 1.0.0
		 */
		isScheduled: function() {
	
			if ( this.isPublished() ) {
				return false;
			}//end if
	
			if ( this.get( 'date' ) && ncNewLocalMoment().isBefore( this.get( 'date' ) ) ) {
				return true;
			} else {
				return false;
			}//end if
	
		},//end isScheduled()
	
		/**
		 * Returns a string for sorting posts. Essentially, this string contains the
		 * schedule date.
		 *
		 * @return {string} a string for sorting posts.
		 *
		 * @since 1.0.0
		 */
		getDateForSorting: function() {
	
			return this.get( 'date' ).format( 'YYYY-MM-DDTHH:mm' );
	
		},//end getDateForSorting()
	
		/**
		 * Returns the day which this post was published in/is scheduled for.
		 *
		 * @return {string} the day which this post was published in/is scheduled for.
		 *
		 * @since 1.0.0
		 */
		getRelevantDay: function() {
	
			return this.get( 'date' ).format( 'YYYY-MM-DD' );
	
		},//end getRelevantDay()
	
		/**
		 * Reschedules the post to the given date.
		 *
		 * On success, the event `nc:reschedule` is triggered.
		 *
		 * @param localDate {string} New day (local timezone) in which the post has to be published.
		 *
		 * @since 1.0.0
		 */
		reschedule: function( localDate ) {
	
			if ( this.get( 'date' ).format( 'YYYY-MM-DD' ) === localDate ) {
				this.trigger( 'nc:undo:reschedule' );
				return;
			}//end if
	
			var model = this;
	
			$.ajax({
	
				url: ajaxurl,
	
				data: {
					action: 'nelio_content_reschedule_post',
					post: this.get( 'id' ),
					date: localDate
				},
	
				success: function( post ) {
					model.trigger( 'nc:reschedule' );
				},//end success()
	
				error: function( xhr ) {
					model.trigger( 'nc:error', xhr.responseJSON );
				}//end error()
	
			});
	
		},//end reschedule()
	
		/**
		 * Trashes the post.
		 *
		 * On success, the event `nc:trash` is triggered.
		 *
		 * @since 1.0.0
		 */
		trash: function() {
	
			var model = this;
	
			$.ajax({
	
				url: ajaxurl,
	
				data: {
					action: 'nelio_content_trash_post',
					post: this.get( 'id' )
				},
	
				success: function() {
					model.trigger( 'nc:trash' );
				},//end success()
	
				error: function( xhr ) {
					model.trigger( 'nc:error', xhr.responseJSON );
				}//end error()
	
			});
	
	
		},//end trash()
	
		/**
		 * Callback to ensure that ID is a number.
		 *
		 * @since 1.0.0
		 */
		_fixPostIdType: function() {
	
			this.stopListening( this, 'change:id', this._fixPostIdType );
	
			var id = this.get( 'id' );
	
			if ( typeof id === 'string' ) {
	
				id = parseInt( id );
	
				if ( ! isNaN( id ) ) {
					this.set( 'id', id );
				} else {
	
					this.set( 'id', 0 );
					this.set( 'status', 'draft' );
					this.set( 'title', '' );
					this.set( 'permalink', '' );
					this.set( 'excerpt', '' );
	
				}//end if
	
			}//end if
	
			this.listenTo( this, 'change:id', this._fixPostIdType );
	
		},//end _fixPostIdType()
	
		/**
		 * Callback to ensure that the image ID is a number.
		 *
		 * @since 1.0.0
		 */
		_fixImageIdType: function() {
	
			this.stopListening( this, 'change:imageId', this._fixImageIdType );
	
			var id = this.get( 'imageId' );
			id = parseInt( id );
			if ( ! isNaN( id ) ) {
				this.set( 'imageId', id );
			}//end if
	
			this.listenTo( this, 'change:imageId', this._fixImageIdType );
	
		},//end _fixImageIdType()
	
		/**
		 * Callback to ensure that date is an instance of moment (instead of a string).
		 *
		 * @since 1.0.0
		 */
		_fixDateFormat: function() {
	
			var date = this.get( 'date' );
	
			if ( typeof date === 'string' ) {
				this.set( 'date', ncNewLocalMoment( date ) );
			}//end if
	
		},//end _fixDateFormat()
	
		/**
		 * Callback function that ensures a permalink exists for this post.
		 *
		 * @since 1.0.0
		 */
		_checkPermalink: function() {
	
			this.stopListening( this, 'change:permalink', this._checkPermalink );
	
			var permalink = this.get( 'permalink' );
			if ( typeof permalink === 'undefined' || NelioContent.helpers.trim( permalink ) === '' ) {
	
				this.set( 'permalink', NelioContent.blogUrl );
	
			}//end if
	
			this.listenTo( this, 'change:permalink', this._checkPermalink );
	
		},//end _checkPermalink()
	
		/**
		 * Callback function that escapes the title.
		 *
		 * @since 1.0.0
		 */
		_escapeTitle: function() {
	
			this.set( 'titleFormatted', _.escape( this.get( 'title' ) ) );
	
		},//end _escapeTitle()
	
		/**
		 * Callback function that escapes the excerpt.
		 *
		 * @since 1.0.0
		 */
		_escapeExcerpt: function() {
	
			this.set( 'excerptFormatted', _.escape( this.get( 'excerpt' ) ) );
	
		},//end _escapeExcerpt()
	
		/**
		 * Callback function that unescapes title and excerpt.
		 *
		 * @since 1.0.0
		 */
		_maybeUnescapeTitleAndExcerpt: function() {
	
			var title = this.get( 'title' );
			if ( typeof title === 'undefined' || NelioContent.helpers.trim( title ).length === 0 ) {
				this.set( 'title', NelioContent.helpers.decodeHTMLEntities( this.get( 'titleFormatted' ) ) );
			}//end if
	
			var excerpt = this.get( 'excerpt' );
			if ( typeof excerpt === 'undefined' || NelioContent.helpers.trim( excerpt ).length === 0 ) {
				this.set( 'excerpt', NelioContent.helpers.decodeHTMLEntities( this.get( 'excerptFormatted' ) ) );
			}//end if
	
		}//end _maybeUnescapeTitleAndExcerpt()
	
	});//end class
	

	/**
	 * This class represents a social message, as defined in our cloud.
	 *
	 * It also contains some private information that might be useful:
	 *
	 *  * Related post information. If the social message is linked to a WordPress
	 *    post, it's important we know some basic information about that post.
	 *  * Profile information. Which we might need for rendering the social
	 *    message, such as the display name, username, or picture.
	 *
	 * @constructor
	 * @augments NelioContent.models.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.SocialMessage = NelioContent.models.Model.extend({
	
		/**
		 * URL root for accessing the API.
		 */
		urlRoot: NelioContent.apiUri + '/social',
	
		/**
		 * Default values.
		 */
		defaults: function() { return {
	
			siteId: '',
	
			profileId: '',
			targetName: 'default',
			targetDisplayName: '',
	
			profiles: [],
	
			network: 'twitter',
			networkKind: 'single',
	
			calendarKind: 'social',
	
			type: 'text',
			status: 'draft',
	
			postId: 0,
			postType: NelioContent.postTypes[0].name,
			baseDatetime: 'none',
	
			dateType: 'predefined-offset',
			dateValue: '0',
			timeType: 'predefined-offset',
			timeValue: '0',
			timezone: NelioContent.i18n.timezone,
	
			schedule: ncNewLocalMoment(),
	
			text: '',
			textComputed: '',
	
			image: '',
			imageId: 0,
			imageSource: 'none',
	
			sent: false,
			sentTime: 0,
			sentResponse: '',
			sentAttempts: 0,
			nextAttemptTimestamp: 0,
			failureDescription: '',
	
			url: '',
	
			timestamp: 0
	
		}; },
	
		/**
		 * This variable holds information about the "post" that's linked to this
		 * social message.
		 */
		post: new NelioContent.models.Post(),
	
		/**
		 * Initializes this object.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			// Generate the computed text value.
			this._computeText();
			this._extractRelevantUrl();
			this.listenTo( this, 'change:text', this._computeText );
			this.listenTo( this, 'change:textComputed', this._extractRelevantUrl );
			this.listenTo( this, 'change:network', this._extractRelevantUrl );
	
			this.listenTo( this, 'change:profileId', this._fixProfileInformation );
			this._fixProfileInformation();
	
			this.listenTo( this, 'change:schedule', this._fixScheduleFormat );
			this._fixScheduleFormat();
	
			this.listenTo( this, 'change:dateValue', this._fixSchedule );
			this.listenTo( this, 'change:timeValue', this._fixSchedule );
	
			this.listenTo( this, 'change:postId', this._setDefaultText );
	
			this.listenTo( this, 'change:network', this._updateMaxTextLength );
			this.listenTo( this, 'change:profiles', this._updateMaxTextLength );
			this._updateMaxTextLength();
	
			this.listenTo( this, 'change:dateType', this._setBaseDatetime );
			this._setBaseDatetime();
	
		},//end initialize()
	
		/**
		 * Relates this social message to the given post.
		 *
		 * @param post {object} The post which this message is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			// Stop listening to the previous post.
			this.stopListening( this.post );
	
			// Set the new post and update local variables.
			this.post = post;
			this.set( 'postId', this.post.get( 'id' ) );
			this.set( 'postType', this.post.get( 'type' ) );
	
			this._setBaseDatetime();
			this._fixSchedule();
	
			// Listen to the new post.
			this.listenTo( this.post, 'change:dateType', this._setBaseDatetime );
	
			// Trigger the "change:text" event, so that textComputed is recomputed (if
			// required).
			this.trigger( 'change:text' );
	
		},//end setPost()
	
		/**
		 * This function loads the related post (if any). Post loading is performed
		 * on the background.
		 *
		 * Triggers the following event on completion:
		 *  * `nc:load:post`
		 *
		 * @since 1.0.0
		 */
		loadPost: function() {
	
			// If there's no post to load, just leave.
			if ( 0 === this.get( 'postId' ) ) {
				this.trigger( 'nc:load:post' );
				return;
			}//end if
	
			if ( this.get( 'postId' ) === this.post.get( 'id' ) ) {
				this.trigger( 'nc:load:post' );
				return;
			}//end if
	
			// If there's a post, though, and it's not loaded, load it.
			var model = this;
			$.ajax({
				url: ajaxurl,
				data: {
					action: 'nelio_content_get_post',
					post: this.get( 'postId' )
				},
	
				success: function( post ) {
	
					model.setPost( new NelioContent.models.Post( post ) );
					model.trigger( 'nc:load:post' );
	
				},//end success()
	
				error: function( xhr ) {
	
					model.trigger( 'nc:error:post', xhr.responseJSON );
	
				}//end error()
	
			});
	
		},//end loadPost()
	
		/**
		 * Returns the length of this message, taking into account that links might
		 * be shortened.
		 *
		 * @return {int} the length of this message, taking into account that links
		 *               might be shortened.
		 *
		 * @since 1.0.0
		 */
		getTextLength: function() {
	
			// Return text length, taking into account that links are shortened and use
			// 23 chars. This might not be true in all networks, but it is in the most
			// restrictive nework--Twitter.
			var link = 'aaaaaaaaaaaaaaaaaaaaaaa';
			var text = this.get( 'textComputed' );
			text = text.replace( /(https?:\/\/[^ ]+)/g, link );
	
			// If the post contains an image, the URL is usually included in the content
			// (at least, on Twitter), so let's assume we have less space available.
			if ( 'image' === this.get( 'type' ) ) {
				text += ' ' + link;
			}//end if
	
			return text.length;
	
		},//end getTextLength
	
		/**
		 * Returns whether this text is too long or not, based on the network in
		 * which the message will appear.
		 *
		 * @return {boolean} whether this text is too long or not, based on the
		 *                   network in which the message will appear.
		 *
		 * @since 1.0.0
		 */
		isTextTooLong: function() {
	
			// Check if the text is too long.
			return this.getTextLength() > this.getMaxTextLength();
	
		},//end isTextTooLong()
	
		/**
		 * Returns the maximum text length allowed.
		 *
		 * @return {integer} the maximum text length allowed.
		 *
		 * @since 1.0.0
		 */
		getMaxTextLength: function() {
	
			return this._maxTextLength;
	
		},//end getMaxTextLength()
	
		/**
		 * Returns a string for sorting social messages. Essentially, this string
		 * contains the schedule date.
		 *
		 * @return {string} a string for sorting social messages.
		 *
		 * @since 1.0.0
		 */
		getDateForSorting: function() {
	
			// The result variable.
			var result = '';
	
			if ( this.post.isPublished() || this.post.isScheduled() ) {
	
				// If we do have an exact datetime, because the related post is published, use it.
				var aux = this.get( 'schedule' );
				result += aux.format( 'YYYY-MM-DDTHH:mm' );
	
			} else {
	
				// If we don't, add date information so that exact dates come after
				// offset dates.
				if ( this.get( 'dateType' ) === 'exact' ) {
					result += this.get( 'dateValue' );
				} else {
					var auxDate = 'Z0000000' + this.get( 'dateValue' );
					result += auxDate.substr( auxDate.length - 6 );
				}//end if
	
				// And append the time following the same approach: exact times come
				// after offset times.
				if ( this.get( 'timeType' ) === 'exact' ) {
					result += this.get( 'timeValue' );
				} else {
					var auxTime = 'Z0000000' + this.get( 'timeValue' );
					result += auxTime.substr( auxTime.length - 6 );
				}//end if
	
			}//end if
	
			return result.toLowerCase();
	
		},//end getDateForSorting()
	
		/**
		 * Returns the day which this social message was published in/is scheduled for.
		 *
		 * @return {string} the day which this social message was published in/is scheduled for.
		 *
		 * @since 1.0.0
		 */
		getRelevantDay: function() {
	
			return this.get( 'schedule' ).format( 'YYYY-MM-DD' );
	
		},//end getRelevantDay()
	
		/**
		 * Returns whether the current message is missing something and, therefore,
		 * can't be saved.
		 *
		 * A message cannot be saved if its message is empty, it doesn't specify
		 * a profile ID, or if date and time values are not properly set.
		 *
		 * @return {string|boolean} wh
		 *
		 * @since 1.0.0
		 */
		isSomethingMissing: function() {
	
			// Make sure the message is not empty.
			if ( NelioContent.helpers.trim( this.get( 'text' ) ) <= 0 ) {
				return NelioContent.i18n.errors.socialMessage.noMessage;
			}//end if
	
			// ...as well as NOT too long.
			if ( this.isTextTooLong() ) {
				return NelioContent.i18n.errors.socialMessage.messageTooLong;
			}//end if
	
			// Make sure there's at least one profile selected.
			if ( this.isNew() && this.get( 'profiles' ).length <= 0 ) {
				return NelioContent.i18n.errors.socialMessage.noProfiles;
			}//end if
	
			// If we're using a profile that needs images, make sure the user
			// selected an image.
			var profile;
			var isImageRequired = false;
			if ( this.isNew() ) {
	
				_.each( this.get( 'profiles' ), function( p ) {
					profile = NelioContent.profiles.get( p.id );
					if ( typeof profile !== 'undefined' ) {
						isImageRequired = isImageRequired || profile.requiresImageToShare();
					}//end if
				});
	
			} else {
	
				profile = NelioContent.profiles.get( this.get( 'profileId' ) );
				if ( typeof profile !== 'undefined' ) {
					isImageRequired = profile.requiresImageToShare();
				}//end if
	
			}//end if
	
			if ( isImageRequired && this.get( 'type' ) !== 'image' ) {
				if ( this.isNew() && this.get( 'profiles' ).length > 1 ) {
					return NelioContent.i18n.errors.socialMessage.noImageMultiple;
				} else {
					return NelioContent.i18n.errors.socialMessage.noImageSingle;
				}//end if
			}//end if
	
			// Make sure the message is not empty.
			if ( NelioContent.helpers.trim( this.get( 'targetName' ) ) <= 0 ) {
				return NelioContent.i18n.errors.socialMessage.noTarget;
			}//end if
	
			// Make sure there's a proper date.
			if ( this.get( 'dateType' ) === 'exact' ) {
	
				if ( ! NelioContent.helpers.isDate( this.get( 'dateValue' ) ) ) {
					return NelioContent.i18n.errors.datetime.invalidDate;
				}// end if
	
			} else if ( NelioContent.helpers.trim( this.get( 'dateValue' ) ) === '' ) {
	
				return NelioContent.i18n.errors.datetime.noDate;
	
			}//end if
	
			// Make sure there's a proper time.
			if ( this.get( 'timeType' ) === 'exact' ) {
				if ( ! NelioContent.helpers.isTime( this.get( 'timeValue' ) ) ) {
					return NelioContent.i18n.errors.datetime.invalidTime;
				}
			} else if ( NelioContent.helpers.trim( this.get( 'timeValue' ) ) === '' ) {
				return NelioContent.i18n.errors.datetime.noTime;
			}//end if
	
			// Make sure the date is not in the past.
			var date, time;
			if ( this.get( 'dateType' ) === 'exact' ) {
	
				if ( this.get( 'timeType' ) === 'exact' ) {
	
					time = this.get( 'timeValue' );
	
				} else if ( this.get( 'timeType' ) === 'time-interval' ) {
	
					switch ( this.get( 'timeValue' ) ) {
	
						case 'night':
							time = '23:00';
							break;
	
						case 'afternoon':
							time = '19:00';
							break;
	
						case 'noon':
							time = '15:00';
							break;
	
						default: // morning
							time = '11:00';
							break;
	
					}//end switch
	
				} else {
	
					// Fallback.
					time = '12:00';
	
				}//end if
	
				date = this.get( 'dateValue' ) + ' ' + time;
				date = ncNewLocalMoment( date );
	
				if ( date.isBefore( ncNewLocalMoment() ) ) {
					return NelioContent.i18n.errors.datetime.noPastAllowed;
				}//end if
	
			}//end if
	
			if ( this.post.get( 'id' ) === 0 || this.post.isPublished() ) {
	
				if ( this.get( 'dateValue' ) === '0' && this.get( 'timeType' ) === 'exact' ) {
	
					date = ncNewLocalMoment().format( 'YYYY-MM-DD' );
					date = date + ' ' + this.get( 'timeValue' );
					date = ncNewLocalMoment( date );
	
					if ( ncNewLocalMoment().isAfter( date ) ) {
						return NelioContent.i18n.errors.datetime.noPastAllowed;
					}//end if
	
				}//end if
	
			}//end if
	
			return false;
	
		},//end isSomethingMissing()
	
		/**
		 * Reschedules the social message to the given date.
		 *
		 * On success, the event `nc:reschedule` is triggered.
		 * Else, the event `nc:undo:reschedule` is triggered.
		 *
		 * @param localDate {string} New day (local timezone) in which the social message has to be published.
		 *
		 * @since 1.0.0
		 */
		reschedule: function( localDate ) {
	
			this.stopListening( this, 'change:dateValue', this._fixSchedule );
			this.stopListening( this, 'change:timeValue', this._fixSchedule );
	
			if ( 'exact' === this.get( 'dateType' ) ) {
	
				if ( this.get( 'dateValue' ) === localDate ) {
					this.trigger( 'nc:undo:reschedule' );
					return;
				}//end if
	
				this.set( 'dateValue', localDate );
				var time = this.get( 'schedule' ).format( 'HH:mm' );
				this.set( 'schedule', localDate + ' ' + time );
	
			} else {
	
				// Compute the difference in days between the old date and the new one.
				var oldSchedule = ncNewLocalMoment( this.get( 'schedule' ).format( 'YYYY-MM-DD' ) + 'T12:00:00.000' );
				var newSchedule = ncNewLocalMoment( localDate + 'T12:00:00.000' );
				var newTime = this.get( 'schedule' ).format( 'HH:mm' );
	
				var diff = newSchedule.diff( oldSchedule, 'd' );
				if ( 0 === diff ) {
					this.trigger( 'nc:undo:reschedule' );
					return;
				}//end if
	
				// Recompute offsets.
				var oldOffset = parseInt( this.get( 'dateValue' ) );
				var newOffset = oldOffset + diff;
	
				// We can't schedule a social message (with an offset) before the post's date.
				if ( newOffset < 0 ) {
					this.trigger( 'nc:undo:reschedule', {
						title: NelioContent.i18n.titles.invalidSocialScheduling,
						content: NelioContent.i18n.dialogs.invalidSocialScheduling
					});
					return;
				}//end if
	
				// Update values and save.
				switch ( newOffset ) {
	
					case 0:
						this.set( 'dateType', 'predefined-offset' );
						this.set( 'dateValue', '0' );
						break;
	
					case 1:
						this.set( 'dateType', 'predefined-offset' );
						this.set( 'dateValue', '1' );
						break;
	
					default:
						this.set( 'dateType', 'positive-days' );
						this.set( 'dateValue', '' + newOffset );
						break;
	
				}//end switch
	
				// When rescheduling a social message, if the time was an offset, we may
				// need to set an exact time.
				if ( 0 === oldOffset ) {
	
					if ( 'exact' !== this.get( 'timeType' ) && 'time-interval' !== this.get( 'timeType' ) ) {
	
						this.set( 'timeType', 'exact' );
						this.set( 'timeValue', newTime );
	
					}//end if
	
				}//end if
	
				this.get( 'schedule' ).add( diff, 'd' );
	
			}//end if
	
			this.set( 'baseDatetime', 'reschedule' );
			this.save( undefined, {
	
				/**
				 * This function updates the values of the given model to the ones
				 * returned by our cloud and re-renders the list of editorial tasks.
				 *
				 * @param _model   {object} The model we're saving.
				 * @param response {object} The response from our cloud.
				 *
				 * @since 1.0.0
				 */
				success: function( model, response ) {
	
					model.set( response );
					model._setBaseDatetime();
					model.trigger( 'nc:reschedule' );
	
				},//end success()
	
				/**
				 * XXX.
				 *
				 * @since 1.0.0
				 */
				error: function( model ) {
	
					// TODO. Get the error.
					model.trigger( 'nc:error' );
	
				}//end success()
	
			});
	
			this.listenTo( this, 'change:dateValue', this._fixSchedule );
			this.listenTo( this, 'change:timeValue', this._fixSchedule );
	
		},//end reschedule()
	
		/**
		 * This function forces the social message to be reshared right now.
		 *
		 * @since 1.0.0
		 */
		shareNow: function() {
	
			if ( 'error' !== this.get( 'status' ) ) {
				this.trigger( 'nc:error' );
				return;
			}//end if
	
			this.set( 'status', '_awaitingEnqueueConfirmation' );
	
			var model = this;
			$.ajax({
	
				url: NelioContent.apiUri + '/social/' + this.get( 'id' ) + '/retry',
				method: 'PUT',
				headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },
	
				/**
				 * This function is called when the message is in the sharing queue again.
				 *
				 * @param response {object} social message info.
				 *
				 * @since 1.0.0
				 */
				success: function( response ) {
	
					// If the social message is now scheduled,
					if ( 'schedule' === response.status ) {
						response.status = '_enqueued';
					}//end if
	
					model.set( response );
	
				},//end success()
	
				/**
				 * If something went wrong, we trigger a `nc:error` event.
				 *
				 * @since 1.0.0
				 */
				error: function() {
	
					// TODO. Get the error.
					model.set( 'status', '_awaitingEnqueueConfirmation' );
					model.trigger( 'nc:error' );
	
				},//end error()
	
			});
	
		},//end shareNow()
	
		/**
		 * Escapes the social message and highlights links, hashtags, and mentions.
		 * The highlight uses a `span` with special classes: `nc-link` for links,
		 * `nc-mention` for mentions, and `nc-hashtag` for hashtags.
		 *
		 * @return {string} Highlighted version of the message.
		 *
		 * @since 1.0.3
			 */
		getHighlightedText: function() {
	
			// Some variables.
			var i, matches, match, aux;
	
			// Don't replace HTML entities.
			var text = ' ' + this.get( 'textComputed' ) + ' ';
			text = text.replace( /\r\n/g, '\n' );
			text = text.replace( /\n/g, ' \n ' );
			text = _.escape( text );
	
			// Fix links.
			text = text.replace( / (https?:\/\/[^ ]+)/g, ' <a class="nc-link">$1</a>' );
	
			// Fix hashtags.
			text = text.replace( twttr.txt.regexen.validHashtag, ' <span class="nc-hash">#$3</span>' );
	
			// Fix mentions.
			text = text.replace( twttr.txt.regexen.validMentionOrList, ' <span class="nc-mention">@$3</span>' );
			text = text.replace( / \n /g, '\n' );
			text = text.replace( /\n/g, '<br>' );
			text = text.substring( 1, text.length - 1 );
	
			return text;
	
		},//end getHighlightedText()
	
		/**
		 * Helper function that updates the maximum number of chars the social
		 * message might have, depending on the selected social profiles.
		 *
		 * @since 1.0.0
		 */
		_updateMaxTextLength: function() {
	
			// Max text length by default is set to a "huge" number.
			this._maxTextLength = Infinity;
	
			if ( this.isNew() && this.get( 'profiles' ).length > 0 ) {
	
				var model = this;
				var profiles = this.get( 'profiles' );
				_.each( NelioContent.networkMetas, function( meta ) {
	
					var found = false;
					_.each( model.get( 'profiles' ), function( profile ) {
	
						if ( found ) {
							return;
						}//end if
	
						profile = NelioContent.profiles.get( profile.id );
						if ( typeof profile === 'undefined' ) {
							return;
						}//end if
	
						if ( profile.get( 'network' ) === meta.id ) {
	
							found = true;
							if ( meta.maxLength < model._maxTextLength ) {
								model._maxTextLength = meta.maxLength;
							}//end if
	
						}//end if
	
					});
	
				});
	
			}//end if
	
			// Default value for security reasons.
			if ( Infinity === this._maxTextLength ) {
	
				var networkMeta = _.findWhere( NelioContent.networkMetas, {
					id: this.get( 'network' )
				});
	
				if ( typeof networkMeta !== 'undefined' ) {
					this._maxTextLength = networkMeta.maxLength;
				}//end if
	
			}//end if
	
			// Default value for security reasons.
			if ( Infinity === this._maxTextLength ) {
				this._maxTextLength = NelioContent.networkMetas[0].maxLength;
			}//end if
	
		},//end _updateMaxTextLength()
	
		/**
		 * This callback function ensures that all the information of the selected
		 * profile ID is properly set.
		 *
		 * @since 1.0.0
		 */
		_fixProfileInformation: function() {
	
			var profile = NelioContent.profiles.get( this.get( 'profileId' ) );
			if ( typeof profile !== 'undefined' ) {
				this.set( 'network', profile.get( 'network' ) );
				this.set( 'networkKind', profile.get( 'kind' ) );
			}//end if
	
		},//end _fixProfileInformation()
	
		/**
		 * This function processes the text and replaces the following placeholders:
		 *
		 *  * `{title}`. Uses the title of the related WordPress post (if any).
		 *  * `{permalink}`. Uses the permalink of the related WordPress post (if any).
		 *
		 * @return {string} This message's text with the `title` and `permalink`
		 *                  placeholders replaced by the proper values.
		 *
		 * @since 1.0.0
		 */
		_computeText: function() {
	
			var text = this.get( 'text' );
	
			if ( 0 === this.get( 'postId' ) ) {
	
				// If the social message isn't related to a post, text computed and
				// text are the same.
				this.set( 'textComputed', text );
	
			} else if ( this.post.get( 'id' ) > 0 ) {
	
				// If, on the other hand, the message is related to a post, but the
				// post is not "available" (i.e. the post object is "empty"), don't
				// try to replace anything, because the process will fail.
				var permalink;
				if ( this.post.isPublished() ) {
	
					permalink = this.post.get( 'permalink' );
	
				} else {
	
					permalink = NelioContent.helpers.trim( NelioContent.blogUrl );
					if ( ! /\/$/.test( permalink ) ) {
						permalink += '/';
					}//end if
					permalink += NelioContent.i18n.defaultPostName + '/';
	
				}//end if
	
				text = text.replace( /\{title\}/g, this.post.get( 'title' ) );
				text = text.replace( /\{permalink\}/g, permalink );
	
				this.set( 'textComputed', text );
	
			}//end if
	
			this._extractRelevantUrl();
	
		},//end _computeText()
	
		/**
		 * Extract the relevant URL of this message (so that preview cards can be
		 * properly shown).
		 *
		 * @return {string} the relevant URL of this message. For instance, in a
		 *                  Twitter message, this is the last URL available. In
		 *                  Facebook, it's the first one.
		 *
		 * @since 1.0.0
		 */
		_extractRelevantUrl: function() {
	
			var text = ' ' + this.get( 'text' );
			text = text.replace( /\{title\}/g, this.post.get( 'title' ) );
			text = text.replace( /\{permalink\}/g, this.post.get( 'permalink' ) );
	
			var matches = text.match( / (https?:\/\/[^ ]+)/g );
			if ( null === matches ) {
				this.set( 'url', '' );
				return;
			}//end if
	
			var url = '';
	
			switch ( this.get( 'network' ) ) {
	
				case 'twitter':
					url = matches[ matches.length - 1 ];
					break;
	
				default:
					url = matches[0];
	
			}//end switch
	
			this.set( 'url', NelioContent.helpers.trim( url ) );
	
		},//end _extractRelevantUrl()
	
		/**
		 * Computes the schedule date based on the specified date and time values.
		 *
		 * @since 1.0.0
		 */
		_fixSchedule: function() {
	
			if ( 'publish' === this.get( 'status' ) ) {
				return;
			}//end if
	
			if ( this.get( 'postId' ) > 0 ) {
	
				if ( ! this.post.isPublished() && ! this.post.isScheduled() ) {
					return;
				}//end if
	
			}//end if
	
			var localBaseDate;
			if ( 0 === this.get( 'postId' ) || this.post.isPublished() ) {
				localBaseDate = ncNewLocalMoment();
			} else {
				localBaseDate = this.post.get( 'date' ).clone();
			}//end if
	
			var newLocalDate = '';
			if ( this.get( 'dateType' ) === 'exact' ) {
				newLocalDate = this.get( 'dateValue' );
			} else {
				localBaseDate.add( this.get( 'dateValue' ), 'd' );
				newLocalDate = localBaseDate.format( 'YYYY-MM-DD' );
			}//end if
	
			// Make sure that date is valid.
			if ( ! NelioContent.helpers.isDate( newLocalDate ) ) {
				return;
			}//end if
	
			if ( this.get( 'timeType' ) === 'exact' ) {
	
				// Make sure that time is valid.
				if ( ! NelioContent.helpers.isTime( this.get( 'timeValue' ) ) ) {
					return;
				}//end if
	
				newLocalDate += ' ' + this.get( 'timeValue' );
				this.set( 'schedule', ncNewLocalMoment( newLocalDate ) );
	
			} else if ( this.get( 'timeType' ) === 'time-interval' ) {
	
				var time = '08:00';
				switch ( this.get( 'timeValue' ) ) {
	
					case 'morning':
						time = '09:00';
						break;
	
					case 'noon':
						time = '13:00';
						break;
	
					case 'afternoon':
						time = '17:00';
						break;
	
					case 'night':
						time = '21:00';
						break;
	
				}//end switch
	
				newLocalDate += ' ' + time;
				this.set( 'schedule', ncNewLocalMoment( newLocalDate ) );
	
			} else {
	
				localBaseDate.add( this.get( 'timeValue' ), 'h' );
				this.set( 'schedule', localBaseDate );
	
			}//end if
	
		},//end _fixSchedule()
	
		/**
		 * Callback to ensure that schedule is an instance of moment (instead of a string).
		 *
		 * @since 1.0.0
		 */
		_fixScheduleFormat: function() {
	
			var schedule = this.get( 'schedule' );
	
			if ( typeof schedule === 'string' ) {
				this.set( 'schedule', ncNewLocalMoment( schedule ) );
			}//end if
	
		},//end _fixScheduleFormat()
	
		/**
		 * Callback that sets the base datetime to the appropriate value.
		 *
		 * This is how the function works:
		 *
		 *  * If there's an exact date/time, `baseDatetime` is set to `none`.
		 *  * If the post is published, `baseDatetime` is set to `now`.
		 *  * If the post is scheduled, `baseDatetime` is set to post's schedule date.
		 *  * Otherwise, `baseDatetime` is set to `none`.
		 *
		 * @since 1.0.0
		 */
		_setBaseDatetime: function() {
	
			if ( 0 === this.post.get( 'id' ) || this.post.isPublished() ) {
	
				if ( this.get( 'dateType' ) === 'exact' ) {
					this.set( 'baseDatetime', 'none' );
				} else {
					this.set( 'baseDatetime', 'now' );
				}//end if
	
			} else if ( this.post.isScheduled() ) {
	
				if ( this.get( 'dateType' ) === 'exact' ) {
					this.set( 'baseDatetime', 'none' );
				} else {
					this.set( 'baseDatetime', this.post.get( 'date' ).clone() );
				}//end if
	
			} else {
	
				this.set( 'baseDatetime', 'none' );
	
			}//end if
	
		},//end _setBaseDatetime()
	
		/**
		 * Callback that sets the default text to `{title} {permalink}` when there's
		 * a post and the text was empty.
		 *
		 * @since 1.0.0
		 */
		_setDefaultText: function() {
	
			var text = NelioContent.helpers.trim( this.get( 'text' ) );
			var postId = this.get( 'postId' );
	
			if ( postId > 0 ) {
	
				if ( 0 === text.length ) {
					this.set( 'text', '{title} {permalink}' );
				} else if ( text.indexOf( '{permalink}' ) === -1 ) {
					this.set( 'text', text + ' {permalink}' );
				}//end if
	
			}//end if
	
		}//end _setDefaultText()
	
	});//end class
	
	

	/**
	 * Backbone model of a reference in a post.
	 *
	 * @constructor
	 * @augments Backbone.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.Reference = Backbone.Model.extend({
	
		/**
		 * This variable holds the regular expression we used the last time for
		 * matching this model's URL with the post contents (see function
		 * "checkIfAppearsIntext").
		 */
		_lastMatchingRegExp: undefined,
	
		/**
		 * This variable holds all the regular expressions we use for matching.
		 */
		_regExps: [],
	
		/**
		 * Default values. These should be overwritten/extended by
		 * implementing subclasses.
		 */
		defaults: {
	
			id: '',
	
			title: '',
			titleFormatted: '',
			url: '',
			urlFormatted: '',
			date: '',
	
			author: '',
			email: '',
			twitter: '',
	
			isInPostContent: false,
	
			status: 'pending',
	
			suggestionAdvisorDisplayName: '',
			suggestionAdvisorId: -1,
			suggestionDate: '',
	
			isExternal: true
	
		},
	
		/**
		 * Initializes a new instance of this model.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this._lastMatchingRegExp = /a^/;
	
			this._generateRegExps();
			this.listenTo( this, 'change:url', this._generateRegExps );
	
			this.listenTo( this, 'change', this._escapeFields );
			this._escapeFields();
	
		},//end initialize()
	
		/**
		 * Returns whether the current reference is missing something and, therefore,
		 * can't be saved.
		 *
		 * A message cannot be saved if the URL of this reference is empty, if
		 * the twitter username doesn't start with `@`, or if the email address
		 * is invalid.
		 *
		 * @return {boolean} whether the current reference can be saved or not.
		 *
		 * @since 1.0.0
		 */
		isSomethingMissing: function() {
	
			var url = this.get( 'url' );
			if ( typeof url === 'undefined' || NelioContent.helpers.trim( url ).length === 0 ) {
				return NelioContent.i18n.errors.reference.noUrl;
			}//end if
	
			var twitter = this.get( 'twitter' );
			if ( typeof twitter === 'string' ) {
	
				twitter = NelioContent.helpers.trim( twitter );
	
				if ( twitter.length >= 2 && twitter.substr( 0, 1 ) !== '@' ) {
					return NelioContent.i18n.errors.reference.invalidTwitter;
				}//end if
	
			}//end if
	
			var email = this.get( 'email' );
			if ( typeof email === 'string' ) {
	
				email = NelioContent.helpers.trim( email ).toUpperCase();
	
				if ( email.length > 0 ) {
	
					var re = /\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b/;
					if ( ! re.test( email ) ) {
						return NelioContent.i18n.errors.reference.invalidMail;
					}//end if
	
				}//end if
	
			}//end if
	
			return false;
	
		},//end isSomethingMissing()
	
		/**
		 * Checks whether this reference appears in the given text and, if it
		 * does, its `isInPostContent` attribute is set to `true`. Otherwise,
		 * it's set to `false`.
		 *
		 * @param text {string} The text in which the reference might appear.
		 *
		 * @since 1.0.0
		 */
		testIfIsInPostContent: function( text ) {
	
			var url = this.get( 'url' );
	
			// First of all, let's see if the last regexp we used can find the url in
			// text.
			if ( this._lastMatchingRegExp.test( text ) ) {
				this.set( 'isInPostContent', true );
				return;
			}//end if
	
	
			// If the previous regular expression didn't work, let's test them all (at
			// least, until one matches).
			var isInPostContent = false;
			_.each( this._regExps, function( re ) {
				if ( re.test( text ) ) {
					isInPostContent = true;
					this._lastMatchingRegExp = re;
					return;
				}//end if
			}, this );
	
			this.set( 'isInPostContent', isInPostContent );
	
		},//end testIfIsInPostContent()
	
		/**
		 * Tries to auto-load information of this reference.
		 *
		 * @param text {string} The text in which the reference might appear.
		 *
		 * @since 1.0.0
		 */
		autoload: function() {
	
			var model = this;
			$.ajax({
	
				url: ajaxurl,
	
				data: {
					action: 'nelio_content_autoload_reference',
					url: this.get( 'url' )
				},
	
				success: function( res ) {
					model.set( res );
				}//end success()
	
			});
	
		},//end autoload()
	
		/**
		 * Helper function that generates several regular expressions based on the
		 * reference's URL so that we can look for this URL in post contents.
		 *
		 * @since 1.0.0
		 */
		_generateRegExps: function() {
	
			var url = this.get( 'url' );
	
			if ( url.length === 0 ) {
	
				this._regExps = [];
	
			} else {
	
				var esc_url = _.escape( url );
				this._regExps = [
					new RegExp( '"' + url + '"', 'i' ),
					new RegExp( '"' + esc_url + '"', 'i' ),
					new RegExp( '\'' + url + '\'', 'i' ),
					new RegExp( '\'' +  esc_url + '\'', 'i' )
				];
	
			}//end if
	
		},//end _generateRegExps()
	
		/**
		 * Callback function that escapes the author, url, and title, so they can be
		 * safely used in views.
		 *
		 * @since 1.0.0
		 */
		_escapeFields: function() {
	
			_.each( [ 'author', 'url', 'title' ], function( key ) {
				this.set( key + 'Escaped', _.escape( this.get( key ) ) );
			}, this );
	
		}//end _escapeFields()
	
	});//end class
	
	
	/**
	 * A list of editorial comments related to a certain post.
	 *
	 * @constructor
	 * @augments Backbone.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.References = Backbone.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.Reference,
	
		/**
		 * This variable holds information about the "post" that's linked to this
		 * social message.
		 */
		post: new NelioContent.models.Post(),
	
		/**
		 * Initializes a new instance of this collection.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'reset', this._onReset );
	
		},//end initialize()
	
		/**
		 * Adds the given reference as a suggestion in the post related to this collection.
		 *
		 * @param reference {object} The reference that has to be added as a collection.
		 *
		 * @since 1.0.0
		 */
		suggestReference: function( reference ) {
	
			// First of all, let's make sure that the collection doesn't contain this
			// reference already.
			if ( typeof this.get( reference.id ) !== 'undefined' ) {
				return;
			}//end if
	
			var user = NelioContent.users.current();
	
			// If it doesn't, we simply need to add the new suggestion. Before doing that,
			// though, we'll initialize the "advisor" information (if none was provided).
			if ( typeof reference.set === 'function' ) {
	
				if ( reference.get( 'suggestionAdvisorId' ) === -1 ) {
	
					reference.set( 'suggestionAdvisorDisplayName', user.get( 'name' ) );
					reference.set( 'suggestionAdvisorId', user.get( 'id' ) );
	
				}//end if
	
			} else {
	
				if ( typeof reference.suggestionAdvisorId === 'undefined' ||
						reference.suggestionAdvisorId === -1 ) {
	
					reference.suggestionAdvisorDisplayName = user.get( 'name' );
					reference.suggestionAdvisorId = user.get( 'id' );
	
				}//end if
	
			}//end if
	
			reference = this.add( reference );
			this.listenTo( reference, 'nc:discard', this.discardReference );
			var collection = this;
			$.ajax({
	
				url: ajaxurl,
				data: {
					action: 'nelio_content_suggest_post_reference',
					post:   this.post.get( 'id' ),
					url:    reference.get( 'url' )
				},
	
				success: function( data ) {
					reference.set( data );
				},//end success()
	
				error: function( xhr ) {
					var message = NelioContent.i18n.errors.reference.notSuggested + ' ' + xhr.responseJSON;
					NelioContent.helpers.openErrorDialog( message );
					collection.remove( reference );
				}//end error()
	
			});
	
		},//end suggestReference()
	
		/**
		 * Removes the given reference from the suggested list.
		 *
		 * @param reference {object} The suggested reference.
		 *
		 * @since 1.0.0
		 */
		discardReference: function( reference ) {
	
			// Update status
			var oldStatus = reference.get( 'status' );
			reference.set( 'status', '_discarding' );
	
			// Remove it from the list.
			var collection = this;
			$.ajax({
	
				url: ajaxurl,
				data: {
					action:    'nelio_content_discard_post_reference',
					post:      this.post.get( 'id' ),
					reference: reference.get( 'postId' )
				},
	
				success: function( data ) {
					collection.remove( reference );
				},//end success()
	
				error: function( xhr ) {
					var message = NelioContent.i18n.errors.reference.notDiscarded + ' ' + xhr.responseJSON;
					NelioContent.helpers.openErrorDialog( message );
					this.set( 'status', oldStatus );
				}//end error()
	
			});
	
		},//end discardReference()
	
		/**
		 * Callback function called when the list of models in this collection is
		 * reset. It stops listening previous models and listens to new ones, as well
		 * as trying to autoload their information (if the information is pending).
		 *
		 * @param models  {array}  The models to be included in this collection.
		 * @param options {object} Backbone options for having access to the previous models.
		 *
		 * @since 1.0.0
		 */
		_onReset: function( models, options ) {
	
			// Stop listening to previous references.
			_.each( options.previousModels, function( reference ) {
				this.stopListening( reference );
			}, this );
	
			// Listen to new references and autoload the pending information.
			this.each( function( reference ) {
				this.listenTo( reference, 'nc:discard', this.discardReference );
				if ( reference.get( 'status' ) === 'pending' ) {
					reference.autoload();
				}//end if
			}, this );
	
		},//end _onReset()
	
		/**
		 * Relates this list of references to the given post.
		 *
		 * @param post {object} the post which this list of references is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			this.post = post;
	
		}//end setPost()
	
	});//end class
	
	

	/**
	 * Backbone model of a Link in a post.
	 *
	 * @constructor
	 * @augments Backbone.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.LinkInPost = Backbone.Model.extend({
	
		/**
		 * Default values. These should be overwritten/extended by
		 * implementing subclasses.
		 */
		defaults: {
			id: '',
			urlFormatted: '',
			isBroken: false
		}
	
	});//end class
	
	
	/**
	 * The list of links that a post's content contains.
	 *
	 * @constructor
	 * @augments Backbone.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.LinksInPost = Backbone.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.LinkInPost,
	
		/**
		 * This variable holds information about the "post" that's linked to this
		 * social message.
		 */
		post: new NelioContent.models.Post(),
	
		/**
		 * Relates this list of links to the given post.
		 *
		 * @param post {object} The post which this list of links is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			this.post = post;
	
		}//end setPost()
	
	});//end class
	
	

	/**
	 * Backbone model of an Editorial Comment.
	 *
	 * @constructor
	 * @augments NelioContent.models.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.EditorialComment = NelioContent.models.Model.extend({
	
		/**
		 * URL root for accessing the API.
		 */
		urlRoot: NelioContent.apiUri + '/comment',
	
		/**
		 * Default values. These should be overwritten/extended by
		 * implementing subclasses.
		 */
		defaults: function() { return {
	
			comment: '',
			date: ncNewLocalMoment(),
			authorId: NelioContent.users.current().get( 'id' ),
			postId: 0,
			postType: NelioContent.postTypes[0].name,
	
		}; },
	
		/**
		 * Initializes this object.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'change:date', this._fixDateFormat );
			this._fixDateFormat();
	
		},//end initialize()
	
		/**
		 * Converts a string date to a moment instance.
		 *
		 * @since 1.0.0
		 */
		_fixDateFormat: function() {
	
			var date = this.get( 'date' );
	
			if ( typeof date === 'string' ) {
				this.set( 'date', ncNewLocalMoment( date ) );
			}//end if
	
		}//end _fixDateFormat()
	
	
	});//end class
	
	
	/**
	 * A list of editorial comments related to a certain post.
	 *
	 * @constructor
	 * @augments NelioContent.collections.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.EditorialComments = NelioContent.collections.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.EditorialComment,
	
		/**
		 * The post to which this collection is related.
		 */
		post: undefined,
	
		/**
		 * Initializes this collection.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'add', this._onAdd );
			this.listenTo( this, 'remove', this._onRemove );
			this.listenTo( this, 'reset', this._onReset );
	
		},//end initialize()
	
		/**
		 * Relates this list of comments to the given post.
		 *
		 * @param post {object} The post which this list of comments is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			this.post = post;
			this.each( function( comment ) {
				comment.set( 'postId', this.post.get( 'id' ) );
				comment.set( 'postType', this.post.get( 'type' ) );
			}, this );
	
		},//end setPost()
	
		/**
		 * Callback when adding a new model in the collection.
		 *
		 * @param comment {EditorialComment} the comment to add.
		 *
		 * @since 1.0.0
		 */
		_onAdd: function( comment ) {
	
			this.listenTo( comment, 'destroy', this.remove );
			comment.set( 'postId', this.post.get( 'id' ) );
			comment.set( 'postType', this.post.get( 'type' ) );
	
		},//end _onAdd()
	
		/**
		 * Callback when removing a model from the collection.
		 *
		 * @param comment {EditorialComment} the comment to remove.
		 *
		 * @since 1.0.0
		 */
		_onRemove: function( comment ) {
	
			this.stopListening( comment );
	
		},//end _onRemove()
	
		/**
		 * Callback when reseting this collection.
		 *
		 * @param models  {array}  The models to be included in this collection.
		 * @param options {object} Backbone options for having access to the previous models.
		 *
		 * @since 1.0.0
		 */
		_onReset: function( models, options ) {
	
			// Stop listening to previous social comment.
			_.each( options.previousModels, this._onRemove, this );
	
			// Listen to new comment and listen to the related post.
			this.each( this._onAdd, this );
	
		}//end _onReset()
	
	});//end class
	
	

	/**
	 * Backbone model of an editorial task.
	 *
	 * @constructor
	 * @augments NelioContent.models.Model
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.models.EditorialTask = NelioContent.models.Model.extend({
	
		/**
		 * URL root for accessing the API.
		 */
		urlRoot: NelioContent.apiUri + '/task',
	
		/**
		 * Default values. These should be overwritten/extended by
		 * implementing subclasses.
		 */
		defaults: function() { return {
	
			task: '',
			completed: false,
	
			calendarKind: 'task',
	
			postId: 0,
			postType: NelioContent.postTypes[0].name,
			baseDatetime: 'none',
	
			dateDue: ncNewLocalMoment(),
			dateType: 'predefined-offset',
			dateValue: '0',
			timezone: NelioContent.i18n.timezone,
	
			assignerId: NelioContent.users.current().get( 'id' ),
			assigneeId: NelioContent.users.current().get( 'id' )
	
		}; },
	
		/**
		 * This variable holds information about the "post" that's linked to this
		 * social message.
		 */
		post: new NelioContent.models.Post(),
	
		/**
		 * Initializes this object.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'change:dateDue', this._fixDateDueFormat );
			this._fixDateDueFormat();
	
		},//end initialize()
	
		/**
		 * Relates this task to the given post.
		 *
		 * @param post {object} The post which this task is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			// Stop listening to the previous post.
			this.stopListening( this.post );
	
			// Set the new post and update local variables.
			this.post = post;
			this.set( 'postId', this.post.get( 'id' ) );
			this.set( 'postType', this.post.get( 'type' ) );
	
			this._setBaseDatetime();
	
			// Listen to the new post.
			this.listenTo( this.post, 'change:dateType', this._setBaseDatetime );
	
		},//end setPost()
	
		/**
		 * Returns whether the current task is missing something and, therefore,
		 * can't be saved.
		 *
		 * A message cannot be saved if the task is empty or if its date is not
		 * properly set.
		 *
		 * @return {boolean} whether the task message can be saved or not.
		 *
		 * @since 1.0.0
		 */
		isSomethingMissing: function() {
	
			// Make sure the task is not empty.
			if ( NelioContent.helpers.trim( this.get( 'task' ) ) <= 0 ) {
				return NelioContent.i18n.errors.task.noTask;
			}//end if
	
			// Make sure there's a proper date.
			if ( NelioContent.helpers.trim( this.get( 'dateValue' ) ) === '' ) {
				return NelioContent.i18n.errors.datetime.noDate;
			}//end if
	
			// Make sure there's a proper date.
			if ( this.get( 'dateType' ) === 'exact' ) {
				if ( ! NelioContent.helpers.isDate( this.get( 'dateValue' ) ) ) {
					return NelioContent.i18n.errors.datetime.invalidDate;
				}
			}//end if
	
			return false;
	
		},//end isSomethingMissing()
	
		/**
		 * Returns a string for sorting editorial tasks. Essentially, this string
		 * contains the schedule date.
		 *
		 * @return {string} a string for sorting editorial tasks.
		 *
		 * @since 1.0.0
		 */
		getDateForSorting: function() {
	
			// The result variable.
			var result = '';
	
			if ( this.post.isPublished() || this.post.isScheduled() ) {
	
				// If we do have an exact datetime, because the related post is published, use it.
				var aux = this.get( 'dateDue' );
				if ( typeof aux === 'string' ) {
					aux = ncNewLocalMoment( aux );
				}//end if
				result += aux.toISOString();
	
			} else {
	
				// If we don't, add date information so that exact dates come after
				// offset dates.
				if ( this.get( 'dateType' ) === 'exact' ) {
					result += this.get( 'dateValue' );
				} else {
					var auxDate = 'Z0000000' + this.get( 'dateValue' );
					result += auxDate.substr( auxDate.length - 6 );
				}//end if
	
			}//end if
	
			return result;
	
		},//end getDateForSorting()
	
		/**
		 * Returns the due date of this editorial task.
		 *
		 * @return {string} the due date of this editorial task.
		 *
		 * @since 1.0.0
		 */
		getRelevantDay: function() {
	
			return this.get( 'dateDue' ).format( 'YYYY-MM-DD' );
	
		},//end getRelevantDay()
	
		/**
		 * Reschedules the editorial task to the given date.
		 *
		 * On success, the event `nc:reschedule` is triggered.
		 * Else, the event `nc:undo:reschedule` is triggered.
		 *
		 * @param localDate {string} New due date (local timezone) in which the editorial task has to be done.
		 *
		 * @since 1.0.0
		 */
		reschedule: function( localDate ) {
	
			if ( 'exact' === this.get( 'dateType' ) ) {
	
				if ( this.get( 'dateValue' ) === localDate ) {
					this.trigger( 'nc:undo:reschedule' );
					return;
				}//end if
	
				this.set( 'dateValue', localDate );
				this.set( 'dateDue', ncNewLocalMoment( localDate + 'T12:00:00.000' ) );
	
			} else {
	
				// Compute the difference in days between the old date and the new one.
				var oldSchedule = ncNewLocalMoment( this.get( 'dateDue' ).format( 'YYYY-MM-DD' ) + 'T12:00:00.000' );
				var newSchedule = ncNewLocalMoment( localDate + 'T12:00:00.000' );
	
				var diff = newSchedule.diff( oldSchedule, 'd' );
				if ( 0 === diff ) {
					this.trigger( 'nc:undo:reschedule' );
					return;
				}//end if
	
				// Recompute offsets.
				var oldOffset = parseInt( this.get( 'dateValue' ) );
				if ( 'negative-days' === this.get( 'dateType' ) ) {
					oldOffset = -oldOffset;
				}//end if
				var newOffset = oldOffset + diff;
				var newTime = oldSchedule.format( 'HH:mm' );
	
				// Update values and save.
				if ( newOffset > 0 ) {
					this.set( 'dateType', 'positive-days' );
					this.set( 'dateValue', '' + newOffset );
				} else if ( newOffset < 0 ) {
					this.set( 'dateType', 'negative-days' );
					this.set( 'dateValue', '' + Math.abs( newOffset ) );
				} else {
					this.set( 'dateType', 'predefined-offset' );
					this.set( 'dateValue', '0' );
				}//end if
	
				this.get( 'dateDue' ).add( diff, 'd' );
	
			}//end if
	
			this.set( 'baseDatetime', 'reschedule' );
			this.save( undefined, {
	
				/**
				 * This function updates the values of the given model to the ones
				 * returned by our cloud and re-renders the list of editorial tasks.
				 *
				 * @param model    {object} The model we're saving.
				 * @param response {object} The response from our cloud.
				 *
				 * @since 1.0.0
				 */
				success: function( model, response ) {
	
					model.set( response );
					model._setBaseDatetime();
					model.trigger( 'nc:reschedule' );
	
				},//end success()
	
				/**
				 * XXX.
				 *
				 * @since 1.0.0
				 */
				error: function( model ) {
	
					// TODO. Get the error.
					model.trigger( 'nc:error' );
	
				}//end success()
	
			});
	
		},//end reschedule()
	
		/**
		 * Callback to ensure that date due is an instance of moment (instead of a string).
		 *
		 * @since 1.0.0
		 */
		_fixDateDueFormat: function() {
	
			var dateDue = this.get( 'dateDue' );
	
			if ( typeof dateDue === 'string' ) {
				this.set( 'dateDue', ncNewLocalMoment( dateDue ) );
			}//end if
	
		},//end _fixDateDueFormat()
	
		/**
		 * Callback that sets the base datetime to the appropriate value.
		 *
		 * This is how the function works:
		 *
		 *  * If there's an exact date/time, `baseDatetime` is set to `none`.
		 *  * If the post is published, `baseDatetime` is set to `now`.
		 *  * If the post is scheduled, `baseDatetime` is set to post's schedule date.
		 *  * Otherwise, `baseDatetime` is set to `none`.
		 *
		 * @since 1.0.0
		 */
		_setBaseDatetime: function() {
	
			if ( 0 === this.post.get( 'id' ) || this.post.isPublished() ) {
	
				if ( this.get( 'dateType' ) === 'exact' ) {
					this.set( 'baseDatetime', 'none' );
				} else {
					this.set( 'baseDatetime', 'now' );
				}//end if
	
			} else if ( this.post.isScheduled() ) {
	
				if ( this.get( 'dateType' ) === 'exact' ) {
					this.set( 'baseDatetime', 'none' );
				} else {
					this.set( 'baseDatetime', this.post.get( 'date' ).clone() );
				}//end if
	
			} else {
	
				this.set( 'baseDatetime', 'none' );
	
			}//end if
	
		}//end _setBaseDatetime()
	
	});//end class
	
	
	/**
	 * A list of editorial tasks related to a certain post.
	 *
	 * @constructor
	 * @augments NelioContent.collections.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.EditorialTasks = NelioContent.collections.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.EditorialTask,
	
		/**
		 * The post to which this collection is related.
		 */
		post: undefined,
	
		/**
		 * Initializes this collection.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'add', this._onAdd );
			this.listenTo( this, 'remove', this._onRemove );
			this.listenTo( this, 'reset', this._onReset );
	
		},//end initialize()
	
		/**
		 * Relates this list of tasks to the given post.
		 *
		 * @param post {object} The post which this list of tasks is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			this.post = post;
			this.each( function( task ) {
				task.set( 'postId', this.post.get( 'id' ) );
				task.set( 'postType', this.post.get( 'type' ) );
			}, this );
	
		},//end setPost()
	
		/**
		 * Triggers the event `nc;change:model` when one of the models within this
		 * collection changes.
		 *
		 * @param model {EditorialTask} the model that changed.
		 *
		 * @since 1.0.0
		 */
		_triggerModelChange: function( model ) {
	
			this.trigger( 'nc:change:model', this, model );
	
		},//end _triggerModelChange()
	
		/**
		 * Callback when adding a new model in the collection.
		 *
		 * @param task {EditorialTask} the task to add.
		 *
		 * @since 1.0.0
		 */
		_onAdd: function( task ) {
	
			this.listenTo( task, 'change', this._triggerModelChange );
			this.listenTo( task, 'destroy', this.remove );
			task.set( 'postId', this.post.get( 'id' ) );
			task.set( 'postType', this.post.get( 'type' ) );
	
		},//end _onAdd()
	
		/**
		 * Callback when removing a model from the collection.
		 *
		 * @param task {EditorialTask} the task to remove.
		 *
		 * @since 1.0.0
		 */
		_onRemove: function( task ) {
	
			this.stopListening( task );
	
		},//end _onRemove()
	
		/**
		 * Callback when reseting this collection.
		 *
		 * @param models  {array}  The models to be included in this collection.
		 * @param options {object} Backbone options for having access to the previous models.
		 *
		 * @since 1.0.0
		 */
		_onReset: function( models, options ) {
	
			// Stop listening to previous social task.
			_.each( options.previousModels, this._onRemove, this );
	
			// Listen to new task and listen to the related post.
			this.each( this._onAdd, this );
	
		}//end _onReset()
	
	});//end class
	
	

	/**
	 * This class represents a set of calendar items in a given month.
	 *
	 * @constructor
	 * @augments NelioContent.collections.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.MonthlyCalendarItems = NelioContent.collections.Collection.extend({
	
		/**
		 * Whether stuff is being loaded or not.
		 */
		_isLoading: false,
	
		/**
		 * Moment variable holding the first visible day.
		 */
		_today: undefined,
	
		/**
		 * Moment variable holding the first visible day.
		 */
		_firstDayInCalendar: undefined,
	
		/**
		 * Moment variable holding the last visible day.
		 */
		_lastDayInCalendar: undefined,
	
		/**
		 * Moment variable holding the first day of the "current" month.
		 */
		_firstDayOfMonth: undefined,
	
		/**
		 * AJAX request for loading list of posts from WP server.
		 */
		_postAjaxRequest: undefined,
	
		/**
		 * AJAX request for loading calendar items from AWS server.
		 */
		_awsItemAjaxRequest: undefined,
	
		/**
		 * This function uses the appropriate backbone model, based on the calendar
		 * item we've loaded.
		 */
		model: function( model, options ) {
	
			switch ( model.calendarKind ) {
	
				case 'post':
					return new NelioContent.models.Post( model, options );
	
				case 'social':
					return new NelioContent.models.SocialMessage( model, options );
	
				case 'task':
					return new NelioContent.models.EditorialTask( model, options );
	
			}//end switch
	
		},//end model()
	
		/**
		 * Initializes this instance.
		 *
		 * @param models  {object} The models to be included in this collection..
		 * @param options {object} Additional options.
		 *
		 * @since 1.0.0
		 */
		initialize: function( models, options ) {
	
			// Create a debounced function for loading
			// multiple requests are made all at once.
			this._doLoadItemsDebounced = _.debounce( this._doLoadItems, 500 );
	
			// Let's initialize the calendar basic settings.
			this.refresh = _.bind( this.refresh, this );
	
			this._today = ncNewLocalMoment();
			this._firstDayOfMonth = this._today;
	
			var initialDate = this._firstDayOfMonth;
			if ( typeof options === 'object' && typeof options.date === 'string' ) {
				if ( /^[12][01][0-9][0-9]-[01][0-9]-[0123][0-9]$/.test( options.date ) ) {
					initialDate = options.date;
				} else if ( /^[2][01][0-9][0-9]-[0-1][0-9]$/.test( options.date ) ) {
					initialDate = options.date + '-10';
				}//end if
			}//end if
			this.gotoDate( initialDate );
	
			this.listenTo( this, 'nc:change:date', this._loadItems );
	
			this._isLoading = true;
			this._doLoadItems();
	
		},//end initialize()
	
		/**
		 * Returns the first day that's visible in the calendar.
		 *
		 * @return {moment} the first day that's visible in the calendar.
		 *
		 * @since 1.0.0
		 */
		getFirstDay: function() {
	
			return this._firstDayInCalendar.clone();
	
		},//end getFirstDay()
	
		/**
		 * Returns the last day that's visible in the calendar.
		 *
		 * @return {moment} the last day that's visible in the calendar.
		 *
		 * @since 1.0.0
		 */
		getLastDay: function() {
	
			return this._firstDayInCalendar.clone().add( 41, 'd' );
	
		},//end getLastDay()
	
		/**
		 * Returns today's date.
		 *
		 * @return {moment} today's date.
		 *
		 * @since 1.0.0
		 */
		getToday: function() {
	
			return this._today.clone();
	
		},//end getFirstDay()
	
		/**
		 * Returns the first day of the "current" month.
		 *
		 * @return {moment} the first day of the "current" month.
		 *
		 * @since 1.0.0
		 */
		getFirstDayOfMonth: function() {
	
			return this._firstDayOfMonth.clone();
	
		},//end getFirstDayOfMonth()
	
		/**
		 * Moves the calendar to the specified date.
		 *
		 * @param date {object|string} Optional. A moment date, or a string representing a local date.
		 *
		 * @since 1.0.0
		 */
		gotoDate: function( date ) {
	
			switch ( typeof date ) {
				case 'object':
					this._firstDayOfMonth = ncLocalizeMoment( date.clone() );
					break;
				case 'undefined':
					this._firstDayOfMonth = ncNewLocalMoment();
					break;
				default:
					this._firstDayOfMonth = ncNewLocalMoment( date );
			}// end switch
	
			// In order to generate the weeks, we have to "move back" to the first
			// day of the month, and then keep going back until the first day of the
			// week.
			var auxDate = this._firstDayOfMonth.clone();
			auxDate.date( 1 );
			auxDate.hours( 0 );
			auxDate.minutes( 0 );
			auxDate.seconds( 0 );
			auxDate.milliseconds( 0 );
			var firstDayOfWeek = this._firstDayOfMonth.clone().startOf( 'week' ).format( 'd' );
			while ( auxDate.format( 'd' ) != firstDayOfWeek ) {
				auxDate.add( -1, 'd' );
			}//end while
	
			this._firstDayInCalendar = auxDate.clone();
			auxDate.add( 6, 'w' );
			auxDate.add( -1, 'ms' );
			this._lastDayInCalendar = auxDate.clone();
	
			if ( typeof history !== 'undefined' && typeof history.replaceState === 'function' ) {
				var url = window.location.href;
				url = url.replace( /\bdate=([12][01][0-9][0-9]-[01][0-9](-[0123][0-9])?)\b/, '' );
				url = url.replace( /\?$/, '' );
				url = url.replace( /\&$/, '' );
				if ( url.indexOf( '?' ) === -1 ) {
					url += '?';
				} else {
					url += '&';
				}//end if
				url += 'date=' + this._firstDayOfMonth.format( 'YYYY-MM' );
				history.replaceState( null, null, url );
			}//end if
	
			this.reset( [] );
			this.trigger( 'nc:reset:empty' );
			this.trigger( 'nc:reset' );
	
			this.trigger( 'nc:change:date' );
	
		},//end gotoDate()
	
		/**
		 * Moves the calendar to the previous month.
		 *
		 * @since 1.0.0
		 */
		prevMonth: function() {
	
			this._firstDayInCalendar.add( -2, 'w' );
			this.gotoDate( this._firstDayInCalendar );
	
		},//end prevMonth()
	
		/**
		 * Moves the calendar to the next month.
		 *
		 * @since 1.0.0
		 */
		nextMonth: function() {
	
			this._firstDayInCalendar.add( 8, 'w' );
			this.gotoDate( this._firstDayInCalendar );
	
		},//end nextMonth()
	
		/**
		 * Returns whether the current visible month contains "Today" or not.
		 *
		 * @return {boolean} whether the current visible month contains "Today" or not.
		 *
		 * @since 1.0.0
		 */
		isTodayVisible: function() {
	
			return this._today.month() === this._firstDayOfMonth.month() &&
				this._today.year() === this._firstDayOfMonth.year();
	
		},//end isTodayVisible()
	
		/**
		 * Triggers the `nc:change:isLoading` event (using `true`) and loads the
		 * calendar items that should appear in the current "selection".
		 *
		 * @since 1.0.0
		 */
		refresh: function() {
	
			this._isLoading = true;
			this.trigger( 'nc:change:isLoading', true );
			this._doLoadItems();
	
		},//end refresh()
	
		/**
		 * Whether items are being loaded from the server or not.
		 *
		 * @return {boolean} Whether items are being loaded from the server or not.
		 *
		 * @since 1.0.0
		 */
		isLoading: function() {
	
			return this._isLoading;
	
		},//end refresh()
	
		/**
		 * This function cancels any previous AJAX requests and performs new requests
		 * for loading both posts (from WP server) and other calendar items (from
		 * AWS).
		 *
		 * @since 1.0.0
		 */
		_loadItems: function() {
	
			if ( typeof this._postAjaxRequest !== 'undefined' ) {
				this._postAjaxRequest.abort();
			}//end if
	
			if ( typeof this._awsItemAjaxRequest !== 'undefined' ) {
				this._awsItemAjaxRequest.abort();
			}//end if
	
			this._isLoading = true;
			this.trigger( 'nc:change:isLoading', true );
			this._doLoadItemsDebounced();
	
		},//end _loadItems()
	
		/**
		 * This function performs two requests:
		 *
		 * One for loading both posts (from WordPress).
		 * The other for retrieving calendar items (from AWS).
		 *
		 * @since 1.0.0
		 */
		_doLoadItems: function() {
	
			// Temporary data.
			var collection = this;
			var items = [];
			var arePostsLoaded = false;
			var areAwsItemsLoaded = false;
	
			// Load posts from WordPress.
			this._postAjaxRequest = $.ajax({
	
				url: ajaxurl,
	
				data: {
					action: 'nelio_content_get_monthly_posts',
					start: this.getFirstDay().format( 'YYYY-MM-DD' ),
					end: this.getLastDay().format( 'YYYY-MM-DD' )
				},
	
				success: function( result ) {
	
					this._postAjaxRequest = undefined;
	
					if ( areAwsItemsLoaded ) {
	
						arePostsLoaded = true;
						items = _.union( items, result );
						collection.reset( items );
						collection.trigger( 'nc:reset:items' );
						collection.trigger( 'nc:reset' );
	
						collection._isLoading = false;
						collection.trigger( 'nc:change:isLoading', false );
	
					} else {
	
						arePostsLoaded = true;
						items = result;
	
					}//end if
	
				},//end success()
	
				error: function( jqXhr ) {
	
					this._postAjaxRequest = undefined;
					if ( 0 === jqXhr.status && 'abort' === jqXhr.statusText ) {
						return;
					}//end if
	
					arePostsLoaded = true;
	
					if ( areAwsItemsLoaded ) {
	
						collection._isLoading = false;
						collection.trigger( 'nc:change:isLoading', false );
	
					}//end if
	
				}//end error();
	
			});
	
			// Load tasks and social messages from AWS.
			this._awsItemAjaxRequest = $.ajax({
	
				url: NelioContent.apiUri + '/calendar',
				method: 'GET',
				headers: { Authorization: 'Bearer ' + NelioContent.apiAuthToken },
	
				data: {
					from: this.getFirstDay().clone().add( -1, 'd' ).format( 'YYYY-MM-DD' ),
					to: this.getLastDay().clone().add( 1, 'd' ).format( 'YYYY-MM-DD' )
				},
	
				success: function( result ) {
	
					this._awsItemAjaxRequest = undefined;
	
					var aux = [];
					_.each( result.social, function( message ) {
						message.calendarKind = 'social';
						aux.push( message );
					});
					_.each( result.tasks, function( task ) {
						task.calendarKind = 'task';
						aux.push( task );
					});
	
					if ( arePostsLoaded ) {
	
						areAwsItemsLoaded = true;
						items = _.union( items, aux );
						collection.reset( items );
						collection.trigger( 'nc:reset:items' );
						collection.trigger( 'nc:reset' );
	
						collection._isLoading = false;
						collection.trigger( 'nc:change:isLoading', false );
	
					} else {
	
						areAwsItemsLoaded = true;
						items = aux;
	
					}//end if
	
				},//end success()
	
				error: function( jqXhr ) {
	
					this._awsItemAjaxRequest = undefined;
					if ( 0 === jqXhr.status && 'abort' === jqXhr.statusText ) {
						return;
					}//end if
	
					areAwsItemsLoaded = true;
	
					if ( arePostsLoaded ) {
	
						collection._isLoading = false;
						collection.trigger( 'nc:change:isLoading', false );
	
					}//end if
	
				}//end error();
	
			});
	
		}//end _doLoadItems()
	
	});//end class
	
	

	/**
	 * The list of scheduled social messages related to a certain post.
	 *
	 * @constructor
	 * @augments NelioContent.collections.Collection
	 *
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 * @since 1.0.0
	 */
	NelioContent.collections.SocialTimeline = NelioContent.collections.Collection.extend({
	
		/**
		 * The model we use.
		 */
		model: NelioContent.models.SocialMessage,
	
		/**
		 * The post to which this collection is related.
		 */
		post: undefined,
	
		/**
		 * Initializes this collection.
		 *
		 * @since 1.0.0
		 */
		initialize: function() {
	
			this.listenTo( this, 'add', this._onAdd );
			this.listenTo( this, 'remove', this._onRemove );
			this.listenTo( this, 'reset', this._onReset );
	
		},//end initialize()
	
		/**
		 * Returns the list of profiles that can't have any more social messages.
		 *
		 * @return array the list of profiles that can't have any more social messages.
		 *
		 * @since 1.0.0
		 */
		getDisabledProfileIds: function() {
	
			if ( 'none' !== NelioContent.subscriptionPlan ) {
				return [];
			}//end if
	
			return _.uniq( this.pluck( 'profileId' ) );
	
		},//end getDisabledProfileIds()
	
		/**
		 * Relates this social message timeline to the given post.
		 *
		 * @param post {object} The post which this timeline is related to.
		 *
		 * @since 1.0.0
		 */
		setPost: function( post ) {
	
			this.post = post;
			this.each( function( message ) {
				message.setPost( this.post );
			}, this );
	
		},//end setPost()
	
		/**
		 * Callback when adding a new model in the collection.
		 *
		 * @param message {SocialMessage} the message to add.
		 *
		 * @since 1.0.0
		 */
		_onAdd: function( message ) {
	
			this.listenTo( message, 'destroy', this.remove );
			message.setPost( this.post );
	
		},//end _onAdd()
	
		/**
		 * Callback when removing a model from the collection.
		 *
		 * @param message {SocialMessage} the message to remove.
		 *
		 * @since 1.0.0
		 */
		_onRemove: function( message ) {
	
			this.stopListening( message );
	
		},//end _onRemove()
	
		/**
		 * Callback when reseting this collection.
		 *
		 * @param models  {array}  The models to be included in this collection.
		 * @param options {object} Backbone options for having access to the previous models.
		 *
		 * @since 1.0.0
		 */
		_onReset: function( models, options ) {
	
			// Stop listening to previous social messages.
			_.each( options.previousModels, this._onRemove, this );
	
			// Listen to new messages and listen to the related post.
			this.each( this._onAdd, this );
	
		}//end _onReset()
	
	});//end class
	
	

	// --------------------------------------------------------------------------
	// Initialize latest published post (if any)
	// --------------------------------------------------------------------------
	if ( typeof NelioContent.lastPublishedPost === 'object' ) {
		NelioContent.lastPublishedPost = new NelioContent.models.Post( NelioContent.lastPublishedPost );
	}//end if

})( jQuery );
