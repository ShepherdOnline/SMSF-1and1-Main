/**
 * This script initializes the calendar view.
 *
 * @author David Aguilera <david.aguilera@neliosoftware.com>
 * @since  1.0.0
 */
(function( $ ) {
	'use strict';

	// --------------------------------------------------------------------------
	// Load relevant views required for this page.
	// --------------------------------------------------------------------------
	/**
	 * A dialog for editing some information of a post in the calendar page.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.PostEditor = Backbone.View.extend({
	
		/**
		 * The subviews managed by this parent view:
		 *
		 *  * `author`: A user selector view.
		 */
		_views: {
			author: undefined
		},
	
		/**
		 * The URL of a (first) suggested reference, if any.
		 */
		_suggestedReference: '',
	
		/**
		 * A (first) editorial comment for the post's author.
		 */
		_firstEditorialComment: '',
	
		/**
		 * This view may either use browser's native date picker (if available) or a
		 * jQuery-based date picker. To prevent creating a jQuery date picker
		 * multiple times, we use this boolean variable.
		 */
		_isDatePickerReady: false,
	
		/**
		 * An object with a reference to all dialog buttons.
		 */
		_buttons: undefined,
	
		/**
		 * Labels used in this dialog, which are based on the current post type.
		 */
		_labels: undefined,
	
		/**
		 *
		 */
		_regex: {
			url: /^(https?:\/\/)?([\da-z\.-]+)\.([a-z]{2,6})(\/[^\/\s]+)*\/?$/i,
			date: /[12][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]/,
			time: /[012][0-9]:[0-5][0-9]/
		},
	
		/**
		 * Original post values.
		 */
		_originalValues: undefined,
	
		/**
		 * The model used by this view.
		 */
		model: NelioContent.models.Post,
	
		/**
		 * The underscore template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-post-editor' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
	
			'change .nc-title': '_onTitleChange',
			'keyup .nc-title': '_onTitleChange',
	
			'click  .nc-date .nc-value': '_maybeInitDatePicker',
			'change .nc-date': '_onDateChange',
			'change .nc-time': '_onTimeChange',
	
			'change .nc-post-type': '_onPostTypeChange',
			'keyup .nc-post-type': '_onPostTypeChange',
	
			'click .nc-toggle-editor-visibility': '_toggleEditorInformationVisibility',
	
			'change .nc-suggested-reference input': '_onSuggestedReferenceChange',
			'keyup .nc-suggested-reference input': '_onSuggestedReferenceChange',
	
			'change .nc-initial-comment textarea': '_onFirstEditorialCommentChange',
			'keyup .nc-initial-comment textarea': '_onFirstEditorialCommentChange'
	
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @param options {object} Options that can be attached to the view.
		 *
		 * @since 1.0.0
		 */
		initialize: function( options ) {
	
			// Load default options.
			if ( typeof options !== 'object' ) {
				options = {};
			}//end if
	
			if ( typeof options.date !== 'string' ) {
				options.date = ncNewLocalMoment().format( 'YYYY-MM-DD' );
			}//end if
	
			// Add some bindings.
			this.render = _.bind( this.render, this );
			this._onDialogSave = _.bind( this._onDialogSave, this );
			this._onDialogCancel = _.bind( this._onDialogCancel, this );
			this._onDialogDelete = _.bind( this._onDialogDelete, this );
	
			this._onDialogViewPost = _.bind( this._onDialogViewPost, this );
			this._onDialogEditPost = _.bind( this._onDialogEditPost, this );
	
			// Listen to relevant events.
			this.listenTo( this, 'nc:render', this.render );
			this.listenTo( this.model, 'change:type', this._updateLabels );
			this._updateLabels();
	
			// Prepare the model.
			if ( 0 === this.model.get( 'id' ) ) {
	
				this.model.set( 'author', NelioContent.users.current().get( 'id' ) );
				this.model.set( 'localDate', options.date );
				this.model.set( 'localTime', store.get( 'nc-default-post-time', '10:00' ) );
	
				this.listenTo( this.model, 'change', this._maybeEnableSaveButton );
				this.listenTo( this, 'nc:change:suggestedReference', this._maybeEnableSaveButton );
				this.listenTo( this, 'nc:change:firstEditorialComment', this._maybeEnableSaveButton );
	
			} else {
	
				var date = this.model.get( 'date' );
				this.model.set( 'localDate', date.format( 'YYYY-MM-DD' ) );
				this.model.set( 'localTime', date.format( 'HH:mm' ) );
	
				this._originalValues = {
					title: this.model.get( 'title' ),
					author: this.model.get( 'author' ),
					date: this.model.get( 'localDate' ),
					time: this.model.get( 'localTime' )
				};
	
				this.listenTo( this.model, 'change', this._showProperButtonSet );
				this.listenTo( this.model, 'change', this._maybeEnableSaveButton );
	
			}//end if
	
			// Create child views.
			this._views.author = new NelioContent.views.UserSelector({
				defaultValue: this.model.get( 'author' )
			});
			this.listenTo( this._views.author, 'nc:change', this._onAuthorChange );
	
			this._convertToDialog();
	
		},//end initialize()
	
		/**
		 * Opens the dialog and renders this view just one time. If the function is
		 * called again and the view was already rendered, old HTML content is
		 * returned.
		 *
		 * @return {SocialMessageActualEditor} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			// Destroy old date picker (if any).
			var $datePicker = this.$( '.nc-date .nc-value' );
			if ( 'date' !== $datePicker.prop( 'type' ) ) {
				$datePicker.datepicker( 'destroy' );
				this._isDatePickerReady = false;
			}//end if
	
			var data = this.model.toJSON();
	
			data.isEditorInformationVisible = store.get( 'nc-is-calendar-editor-info-visible', false );
			data.suggestedReference = this._suggestedReference;
			data.editorialComment = this._firstEditorialComment;
	
			data.today = ncNewLocalMoment().format( 'YYYY-MM-DD' );
	
			// Detach old views.
			this._views.author.$el.detach();
	
			this.el.innerHTML = this.template( data );
			this.$( '.nc-post-type' ).val( data.type );
	
			this.$el.dialogS2( 'open' );
	
			this.$( '.nc-author .nc-field' ).html( this._views.author.render().$el );
			this._views.author.$el.trigger( 'change' );
	
			var userRole = NelioContent.users.current().get( 'role' );
			if ( 'administrator' === userRole || 'editor' === userRole ) {
				this._views.author.unlock();
			} else {
				this._views.author.lock();
			}//end if
	
			this._maybeEnableSaveButton();
	
			return this;
	
		},//end render()
	
		/**
		 * Locks all inputs, so that the user cannot interact with the view
		 * (presumably, whilst saving).
		 *
		 * @since 1.0.0
		 */
		_lock: function() {
	
			this.$( '*' ).attr( 'disabled', 'disabled' );
			this.$el.addClass( 'nc-locked' );
	
		},//end _lock()
	
		/**
		 * Unlocks all inputs, so that the user can interact with the view.
		 * Presumably, this function is called after and unsuccessful saving
		 * attempt.
		 *
		 * @since 1.0.0
		 */
		_unlock: function() {
	
			this.$( '*' ).removeAttr( 'disabled' );
			this.$el.removeClass( 'nc-locked' );
	
		},//end _unlock()
	
		/**
		 * Converts this view in a jQuery dialog.
		 *
		 * @since 1.0.0
		 */
		_convertToDialog: function() {
	
			// Create buttons.
			var buttons = [];
	
			if ( 0 === this.model.get( 'id' ) ) {
	
				buttons.push(
					NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.cancel )
				);
				buttons.push(
					NelioContent.helpers.makeDialogSaveButton( this, this._labels.addAction )
				);
	
			} else {
	
				buttons.push(
					NelioContent.helpers.makeDialogDeleteButton( this, NelioContent.i18n.actions.trash )
				);
	
				buttons.push(
					NelioContent.helpers.makeDialogButton( this, 'close', NelioContent.i18n.actions.close )
				);
				buttons.push(
					NelioContent.helpers.makeDialogButton( this, 'view', this._labels.viewAction )
				);
				buttons.push(
					NelioContent.helpers.makeDialogButton( this, 'edit', this._labels.editAction, true )
				);
	
				buttons.push(
					NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.cancel )
				);
				buttons.push(
					NelioContent.helpers.makeDialogSaveButton( this, NelioContent.i18n.actions.saveChanges )
				);
	
			}//end if
	
			// Prepare the dialog.
			var view = this;
			this.$el.dialogS2({
	
				title: ( this.model.get( 'id' ) > 0 ) ?
					this._labels.editTitle :
					this._labels.addTitle,
	
				autoOpen: false,
				buttons: buttons,
				dialogClass: 'nc-post-editor-dialog',
				draggable: false,
				modal: true,
				resizable: false,
				width: '95%',
	
				position: {
					my: 'center top',
					at: 'center top+60'
				},
	
				/**
				 * Opens the dialog and listens to the events triggered by its buttons.
				 *
				 * @since 1.0.0
				 */
				open: function() {
	
					// Listen to dialog button events.
					view.listenTo( view, 'nc:click:dialog:save', view._onDialogSave );
					view.listenTo( view, 'nc:click:dialog:cancel', view._onDialogCancel );
					view.listenTo( view, 'nc:click:dialog:delete', view._onDialogDelete );
	
					view.listenTo( view, 'nc:click:dialog:close', view._onDialogCancel );
					view.listenTo( view, 'nc:click:dialog:view', view._onDialogViewPost );
					view.listenTo( view, 'nc:click:dialog:edit', view._onDialogEditPost );
	
					// Prepare beautiful tooltips for save button.
					view._buttons = view._buttons || {};
	
					view._buttons.edit = view.$el.parent().find( 'button.nc-edit-button' );
					view._buttons.view = view.$el.parent().find( 'button.nc-view-button' );
					view._buttons.close = view.$el.parent().find( 'button.nc-close-button' );
	
					view._buttons.cancel = view.$el.parent().find( 'button.nc-cancel-button' );
					view._buttons.save = view.$el.parent().find( 'button.nc-save-button' );
	
					NelioContent.helpers.makeWarningTooltip( view._buttons.save );
	
					// If the post is not new, make sure the proper button set is visible.
					if ( view.model.get( 'id' ) > 0 ) {
						view._buttons.cancel.hide();
						view._buttons.save.hide();
					}//end if
	
					// Make sure the delete button is not focused by default.
					var $deleteButton = view.$el.parent().find( 'button.nc-delete-button' );
					if ( $deleteButton.length > 0 ) {
						$deleteButton.blur();
					}//end if
	
				},//end open()
	
				/**
				 * Destroys the dialog and triggers the `nc:close:dialog` event.
				 *
				 * @since 1.0.0
				 */
				close: function( event, ui ) {
	
					// Stop listening to dialog buttons, now that the dialog is about to be closed.
					view.stopListening( view, 'nc:click:dialog:save', view._onDialogSave );
					view.stopListening( view, 'nc:click:dialog:cancel', view._onDialogCancel );
					view.stopListening( view, 'nc:click:dialog:delete', view._onDialogDelete );
	
					// Remove beautiful tooltips for save button.
					view._buttons.save.tooltip( 'destroy' );
	
					// Destroy the dialog.
					view.$el.dialogS2( 'destroy' );
					view.trigger( 'nc:close:dialog' );
	
				}//end open()
	
			});
	
			this.listenTo( this, 'nc:change:labels', this._renderLabels );
	
		},//end _convertToDialog()
	
		/**
		 * A callback function that enables or disables the save post button,
		 * depending on whether the model can be saved or not.
		 *
		 * @since 1.0.5
		 */
		_showProperButtonSet: function() {
	
			var changed = false;
			changed = changed || this.model.get( 'author' ) !== this._originalValues.author;
			changed = changed || this.model.get( 'title' ) !== this._originalValues.title;
			changed = changed || this.model.get( 'author' ) !== this._originalValues.author;
			changed = changed || this.model.get( 'localDate' ) !== this._originalValues.date;
			changed = changed || this.model.get( 'localTime' ) !== this._originalValues.time;
	
			if ( changed ) {
	
				this._buttons.edit.hide();
				this._buttons.view.hide();
				this._buttons.close.hide();
	
				this._buttons.cancel.show();
				this._buttons.save.show();
	
			} else {
	
				this._buttons.edit.show();
				this._buttons.view.show();
				this._buttons.close.show();
	
				this._buttons.cancel.hide();
				this._buttons.save.hide();
	
			}//end if
	
		},//end _showProperButtonSet()
	
		/**
		 * A callback function that enables or disables the save post button,
		 * depending on whether the model can be saved or not.
		 *
		 * @since 1.0.0
		 */
		_maybeEnableSaveButton: function() {
	
			if ( typeof this._buttons.save === 'undefined' ) {
				return;
			}//end if
	
			this._buttons.save.tooltip( 'close' );
	
			if ( NelioContent.helpers.trim( this.model.get( 'title' ) ).length === 0 ) {
				this._buttons.save.addClass( 'button-disabled' );
				this._buttons.save.attr( 'title', NelioContent.i18n.errors.post.noTitle );
				return;
			}//end if
	
			if ( NelioContent.helpers.trim( this.model.get( 'localDate' ) ).length === 0 ) {
				this._buttons.save.addClass( 'button-disabled' );
				this._buttons.save.attr( 'title', NelioContent.i18n.errors.datetime.noDate );
				return;
			}//end if
	
			if ( ! this._regex.date.test( this.model.get( 'localDate' ) ) ) {
				this._buttons.save.addClass( 'button-disabled' );
				this._buttons.save.attr( 'title', NelioContent.i18n.errors.datetime.invalidDate );
				return;
			}//end if
	
			if ( NelioContent.helpers.trim( this.model.get( 'localTime' ) ).length === 0 ) {
				this._buttons.save.addClass( 'button-disabled' );
				this._buttons.save.attr( 'title', NelioContent.i18n.errors.datetime.noTime);
				return;
			}//end if
	
			if ( ! this._regex.time.test( this.model.get( 'localTime' ) ) ) {
				this._buttons.save.addClass( 'button-disabled' );
				this._buttons.save.attr( 'title', NelioContent.i18n.errors.datetime.invalidTime);
				return;
			}//end if
	
			if ( this._suggestedReference.length > 0 ) {
	
				if ( ! this._regex.url.test( this._suggestedReference ) ) {
					this._buttons.save.addClass( 'button-disabled' );
					this._buttons.save.attr( 'title', NelioContent.i18n.errors.post.invalidUrl );
					return;
				}//end if
	
			}//end if
	
			this._buttons.save.removeClass( 'button-disabled' );
			this._buttons.save.attr( 'title', '' );
	
		},//end _maybeEnableSaveButton()
	
		/**
		 * Modifies the labels in the dialog, so that they match the current post type.
		 *
		 * @since 1.1.0
		 */
		_updateLabels: function() {
	
			var ptName = this.model.get( 'type' );
			var postType = _.reduce( NelioContent.postTypes, function( result, postType ) {
				if ( ptName === postType.name ) {
					return postType;
				} else {
					return result;
				}//end if
			});
	
			this._labels = postType.labels;
			this.trigger( 'nc:change:labels' );
	
		},//end _updateLabels()
	
		/**
		 * Modifies the labels of the dialog and buttons, so that they match the
		 * current post type.
		 *
		 * @since 1.1.0
		 */
		_renderLabels: function() {
	
			// Post type can only be changed when creating the post, so there's no
			// need to update "Edit" buttons and the "Edit" title.
			var $dialog = this.$el.parent();
			$dialog.find( '.ui-dialog-buttonpane button.nc-save-button' ).html( this._labels.addAction );
			$dialog.find( '.ui-dialog-buttonpane button.nc-view-button' ).html( this._labels.viewAction );
			$dialog.find( '.ui-dialog-titlebar .ui-dialog-title' ).html(  this._labels.addTitle );
	
		},//end _renderLabels()
	
		/**
		 * Updates the title of the model using the new value.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onTitleChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this.model.set( 'title', NelioContent.helpers.trim( $el.val() ) );
	
		},//end _onTitleChange()
	
		/**
		 * Callback for updating the post type.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.1.0
		 */
		_onPostTypeChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
			this.model.set( 'type', $el.val() );
	
		},//end _onPostTypeChange()
	
		/**
		 * Updates the ID of the author using the new value.
		 *
		 * @param authorId {integer} The ID of the selected user.
		 *
		 * @since 1.0.0
		 */
		_onAuthorChange: function( authorId ) {
	
			this.model.set( 'author', parseInt( authorId ) );
	
		},//end _onAuthorChange()
	
		/**
		 * Updates the date in which the post was/has to be published.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onDateChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this.model.set( 'localDate', NelioContent.helpers.trim( $el.val() ) );
	
		},//end _onDateChange()
	
		/**
		 * Updates the time in which the post was/has to be published.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onTimeChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this.model.set( 'localTime', NelioContent.helpers.trim( $el.val() ) );
	
		},//end _onTimeChange()
	
		/**
		 * Updates the suggested reference value and triggers the event:
		 * `nc:change:suggestedReference`.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onSuggestedReferenceChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this._suggestedReference = $el.val();
			this.trigger( 'nc:change:suggestedReference', this._suggestedReference );
	
		},//end _onSuggestedReferenceChange()
	
		/**
		 * Updates the first editorial comment and triggers the event:
		 * `nc:change:firstEditorialComment`.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onFirstEditorialCommentChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this._firstEditorialComment = $el.val();
			this.trigger( 'nc:change:firstEditorialComment', this._firstEditorialComment );
	
		},//end _onFirstEditorialCommentChange()
	
		/**
		 * Callback function that toggles the visibility of the editorial information section.
		 *
		 * @since 1.0.0
		 */
		_toggleEditorInformationVisibility: function() {
	
			var isVisible = store.get( 'nc-is-calendar-editor-info-visible', false );
			store.set( 'nc-is-calendar-editor-info-visible', ! isVisible );
			this.trigger( 'nc:render' );
	
		},//end _toggleEditorInformationVisibility()
	
		/**
		 * Callback function that saves the post.
		 *
		 * @since 1.0.0
		 */
		_onDialogSave: function() {
	
			var $dialog = this.$el.parent();
			var $okButton = $dialog.find( '.ui-dialog-buttonpane button.nc-save-button' );
			var $otherButtons = $dialog.find( '.ui-dialog-titlebar button, .ui-dialog-buttonpane button:not( .nc-save-button )' );
	
			if ( $okButton.hasClass( 'button-disabled' ) ) {
				return;
			}//end if
	
			// Disable all input fields and buttons.
			this._lock();
			this.$el.dialogS2( 'option', 'closeOnEscape', false );
			$okButton.prop( 'disabled', true );
			$otherButtons.prop( 'disabled', true );
			if ( this.model.get( 'id' ) === 0 ) {
				$okButton.html( NelioContent.i18n.feedback.creating );
			} else {
				$okButton.html( NelioContent.i18n.feedback.saving );
			}//end if
	
			var data = {
				title: this.model.get( 'title' ),
				author: this.model.get( 'author' ),
				localDatetime: this.model.get( 'localDate' ) + ' ' + this.model.get( 'localTime' ),
				postType: this.model.get( 'type' )
			};
	
			if ( this.model.get( 'id' ) === 0 ) {
				data.action = 'nelio_content_create_post_in_calendar';
				data.reference = NelioContent.helpers.trim( this._suggestedReference );
				data.comment = NelioContent.helpers.trim( this._firstEditorialComment );
			} else {
				data.action = 'nelio_content_update_post_in_calendar';
				data.post = this.model.get( 'id' );
			}//end if
	
			// Update post in WordPress.
			var view = this;
			$.ajax({
	
				url: ajaxurl,
				method: 'POST',
				data: data,
	
				success: function( result ) {
	
					if ( typeof result === 'object' ) {
						view.model.set( result );
					}//end if
	
					// Save time for subsequent post creation.
					store.set( 'nc-default-post-time', view.model.get( 'localTime' ) );
	
					// Trigger post save event and close dialog.
					view.trigger( 'nc:save:post', view.model );
					view.$el.dialogS2( 'close' );
	
				},//end success()
	
				error: function( xhr ) {
	
					NelioContent.helpers.openErrorDialog( xhr.responseJSON );
	
					$okButton.prop( 'disabled', false );
					$otherButtons.prop( 'disabled', false );
					if ( view.model.get( 'id' ) === 0 ) {
						$okButton.html( this._labels.addAction );
					} else {
						$okButton.html( NelioContent.i18n.actions.save );
					}//end if
					view.$el.dialogS2( 'option', 'closeOnEscape', true );
					view._unlock();
	
				}//end error()
	
			});
	
		},//end _onDialogSave()
	
		/**
		 * Callback function that closes the dialog.
		 *
		 * @since 1.0.0
		 */
		_onDialogCancel: function() {
	
			this.$el.dialogS2( 'close' );
	
		},//end _onDialogCancel()
	
		/**
		 * Callback function that deletes the post.
		 *
		 * @since 1.0.0
		 */
		_onDialogDelete: function() {
	
			var view = this;
			var title = NelioContent.i18n.titles.trashPost;
			var action = NelioContent.i18n.dialogs.trashPost;
			var doAction = NelioContent.i18n.actions.doTrashPost;
	
			if ( 'post' !== this.model.get( 'type' ) ) {
				title = NelioContent.i18n.titles.trashElement;
				action = NelioContent.i18n.dialogs.trashElement;
				doAction = NelioContent.i18n.actions.doTrashElement;
			}//end if
	
			var $el = NelioContent.helpers.openDeletionConfirmationDialog(
				title, action, doAction,
				function() {
	
					var $dialog = $el.parent();
					$dialog.find( '.nc-super-delete-button' ).html( NelioContent.i18n.feedback.trashing );
					$dialog.find( 'button' ).prop( 'disabled', true );
	
					view.listenTo( view.model, 'nc:trash', function() {
						$el.dialog( 'destroy' );
						view.trigger( 'nc:trash:post' );
						view.$el.dialogS2( 'close' );
					});
	
					view.model.trash();
	
				}//end function() -- onConfirm
			);
	
		},//end _onDialogDelete()
	
		/**
		 * Callback function that opens (or previews) the current post.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.5
		 */
		_onDialogViewPost: function( ev ) {
	
			if ( ev.ctrlKey || 2 === ev.which ) {
				window.open( this.model.get( 'permalink' ) );
			} else {
				window.document.location.href = this.model.get( 'permalink' );
			}//end if
	
		},//end _onDialogViewPost()
	
		/**
		 * Callback function that opens the post editor.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.5
		 */
		_onDialogEditPost: function( ev ) {
	
			if ( ev.ctrlKey || 2 === ev.which ) {
				window.open( this.model.get( 'editLink' ) );
			} else {
				window.document.location.href = this.model.get( 'editLink' );
			}//end if
	
		},//end _onDialogEditPost()
	
		/**
		 * This callback checks whether the browser supports native date pickers and,
		 * if it doesn't, it creates a jQuery-based date picker.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_maybeInitDatePicker: function( ev ) {
	
			var $datePicker = this.$( '.nc-date .nc-value' );
	
			// Create date picker (if required).
			if ( ! this._isDatePickerReady && $datePicker.prop( 'type' ) !== 'date' ) {
	
				$datePicker.datepicker({
					dateFormat: 'yy-mm-dd',
					minDate: 0
				});
				$datePicker.datepicker( 'show' );
	
			}//end if
	
			this._isDatePickerReady = true;
	
		},//end _maybeInitDatePicker()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Remove child views.
			for ( var viewName in this._views ) {
	
				if ( this._views.hasOwnProperty( viewName ) ) {
	
					var view = this._views[ viewName ];
					if ( typeof view === 'object' ) {
						view.close();
					}//end if
	
				}//end if
	
			}//end for
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class PostEditor
	
	
	/**
	 * A dialog for creating an editorial task.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.TaskDialog = Backbone.View.extend({
	
		/**
		 * The subviews managed by this parent view:
		 *
		 *  * `assignee`: A user selector view.
		 */
		_views: {
			assignee: undefined
		},
	
		/**
		 * A reference to the save button in the dialog.
		 */
		_$saveButton: undefined,
	
		/**
		 *
		 */
		_regex: {
			date: /[12][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]/,
			number: /[0-9]+/,
		},
	
		/**
		 * The model used by this view.
		 */
		model: NelioContent.models.EditorialTask,
	
		/**
		 * The underscore template.
		 */
		template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-task-dialog' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
	
			'change .nc-task-description': '_onTaskChange',
			'keyup .nc-task-description': '_onTaskChange',
	
			'change .nc-date': '_onDateChange'
	
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @param options {object} Options that can be attached to the view.
		 *
		 * @since 1.0.0
		 */
		initialize: function( options ) {
	
			// Load default options.
			if ( typeof options !== 'object' ) {
				options = {};
			}//end if
	
			if ( typeof options.date !== 'string' ) {
				options.date = ncNewLocalMoment().format( 'YYYY-MM-DD' );
			}//end if
	
			// Add some bindings.
			this.render = _.bind( this.render, this );
			this._onDialogSave = _.bind( this._onDialogSave, this );
			this._onDialogCancel = _.bind( this._onDialogCancel, this );
	
			// Listen to relevant events.
			this.listenTo( this, 'nc:render', this.render );
			this.listenTo( this.model, 'change', this._maybeEnableSaveButton );
	
			// Prepare the model.
			this.model.set( 'dateType', 'exact' );
			this.model.set( 'dateValue', options.date );
	
			// Create child views.
			if ( 'team-plan' === NelioContent.subscriptionPlan ) {
	
				this._views.assignee = new NelioContent.views.UserSelector({
					defaultValue: this.model.get( 'assigneeId' )
				});
	
			} else {
	
				this._views.assignee = new NelioContent.views.UserSelector({
					single: true,
					defaultValue: this.model.get( 'assigneeId' )
				});
	
			}//end if
	
			this._views.date = new NelioContent.views.DateSelector({
				model : this.model
			});
			this.listenTo( this._views.assignee, 'nc:change', this._onAssigneeChange );
	
			this._convertToDialog();
	
		},//end initialize()
	
		/**
		 * Opens the dialog and renders this view just one time. If the function is
		 * called again and the view was already rendered, old HTML content is
		 * returned.
		 *
		 * @return {SocialMessageActualEditor} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			var data = this.model.toJSON();
			data.today = ncNewLocalMoment().format( 'YYYY-MM-DD' );
	
			// Detach old views.
			this._views.assignee.$el.detach();
	
			this.el.innerHTML = this.template( data );
			this.$el.dialogS2( 'open' );
	
			this.$( '.nc-assignee .nc-field' ).html( this._views.assignee.render().$el );
			this._views.assignee.$el.trigger( 'change' );
	
			this._maybeEnableSaveButton();
	
			return this;
	
		},//end render()
	
		/**
		 * Locks all inputs, so that the user cannot interact with the view
		 * (presumably, whilst saving).
		 *
		 * @since 1.0.0
		 */
		_lock: function() {
	
			this.$( '*' ).attr( 'disabled', 'disabled' );
			this.$el.addClass( 'nc-locked' );
	
		},//end _lock()
	
		/**
		 * Unlocks all inputs, so that the user can interact with the view.
		 * This should probably be used after a failed attempt to save the task.
		 *
		 * @since 1.0.0
		 */
		_unlock: function() {
	
			this.$( '*' ).removeAttr( 'disabled' );
			this.$el.removeClass( 'nc-locked' );
	
		},//end _unlock()
	
		/**
		 * Converts this view in a jQuery dialog.
		 *
		 * @since 1.0.0
		 */
		_convertToDialog: function() {
	
			// Create buttons.
			var buttons = [];
			buttons.push(
				NelioContent.helpers.makeDialogCancelButton( this, NelioContent.i18n.actions.cancel )
			);
			buttons.push(
				NelioContent.helpers.makeDialogSaveButton( this, NelioContent.i18n.actions.createTask )
			);
	
			// Prepare the dialog.
			var view = this;
			this.$el.dialogS2({
	
				title: NelioContent.i18n.titles.newTask,
	
				autoOpen: false,
				buttons: buttons,
				dialogClass: 'nc-new-task-dialog',
				draggable: false,
				modal: true,
				resizable: false,
				width: '95%',
	
				position: {
					my: 'center bottom',
					at: 'center center'
				},
	
				/**
				 * Opens the dialog and listens to the events triggered by its buttons.
				 *
				 * @since 1.0.0
				 */
				open: function() {
	
					// Listen to dialog button events.
					view.listenTo( view, 'nc:click:dialog:save', view._onDialogSave );
					view.listenTo( view, 'nc:click:dialog:cancel', view._onDialogCancel );
	
					// Prepare beautiful tooltips for save button.
					view._$saveButton = view.$el.parent().find( 'button.nc-save-button' );
					NelioContent.helpers.makeWarningTooltip( view._$saveButton );
	
				},//end open()
	
				/**
				 * Destroys the dialog and triggers the `nc:close:dialog` event.
				 *
				 * @since 1.0.0
				 */
				close: function( event, ui ) {
	
					// Stop listening to dialog buttons, now that the dialog is about to be closed.
					view.stopListening( view, 'nc:click:dialog:save', view._onDialogSave );
					view.stopListening( view, 'nc:click:dialog:cancel', view._onDialogCancel );
	
					// Remove beautiful tooltips for save button.
					view._$saveButton.tooltip( 'destroy' );
	
					// If necessary, destroy the dialog.
					view.$el.dialogS2( 'destroy' );
					view.trigger( 'nc:close:dialog' );
	
				}//end open()
	
			});
	
		},//end _convertToDialog()
	
		/**
		 * A callback function that enables or disables the save post button,
		 * depending on whether the model can be saved or not.
		 *
		 * @since 1.0.0
		 */
		_maybeEnableSaveButton: function() {
	
			if ( typeof this._$saveButton === 'undefined' ) {
				return;
			}//end if
	
			this._$saveButton.tooltip( 'close' );
	
			if ( NelioContent.helpers.trim( this.model.get( 'task' ) ).length === 0 ) {
				this._$saveButton.addClass( 'button-disabled' );
				this._$saveButton.attr( 'title', NelioContent.i18n.errors.task.noTask );
				return;
			}//end if
	
			if ( NelioContent.helpers.trim( this.model.get( 'dateValue' ) ).length === 0 ) {
				this._$saveButton.addClass( 'button-disabled' );
				this._$saveButton.attr( 'title', NelioContent.i18n.errors.datetime.noDate );
				return;
			}//end if
	
			if ( ! this._regex.date.test( this.model.get( 'dateValue' ) ) ) {
				this._$saveButton.addClass( 'button-disabled' );
				this._$saveButton.attr( 'title', NelioContent.i18n.errors.datetime.invalidDate );
				return;
			}//end if
	
			this._$saveButton.removeClass( 'button-disabled' );
			this._$saveButton.attr( 'title', '' );
	
		},//end _maybeEnableSaveButton()
	
		/**
		 * Updates the concrete task the user is supposed to do.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onTaskChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this.model.set( 'task', NelioContent.helpers.trim( $el.val() ) );
	
		},//end _onTaskChange()
	
		/**
		 * Modifies the assignee to the given value.
		 *
		 * @param assigneeId {integer} The ID of the selected user.
		 *
		 * @since 1.0.0
		 */
		_onAssigneeChange: function( assigneeId ) {
	
			this.model.set( 'assigneeId', assigneeId );
	
		},//end _onAssigneeChange()
	
		/**
		 * Updates the due date of the task.
		 *
		 * @param ev {object} The JavaScript event that triggered the callback.
		 *
		 * @since 1.0.0
		 */
		_onDateChange: function( ev ) {
	
			var target = ev.target || ev.srcElement;
			var $el = $( target );
	
			this.model.set( 'dateValue', NelioContent.helpers.trim( $el.val() ) );
	
		},//end _onDateChange()
	
		/**
		 * Callback function that creates the new task.
		 *
		 * @since 1.0.0
		 */
		_onDialogSave: function() {
	
			var $dialog = this.$el.parent();
			var $okButton = $dialog.find( '.ui-dialog-buttonpane button.button-primary' );
			var $otherButtons = $dialog.find( '.ui-dialog-titlebar button, .ui-dialog-buttonpane button:not( .button-primary )' );
	
			if ( $okButton.hasClass( 'button-disabled' ) ) {
				return;
			}//end if
	
			this._lock();
			this.$el.dialogS2( 'option', 'closeOnEscape', false );
			$okButton.prop( 'disabled', true );
			$otherButtons.prop( 'disabled', true );
			$okButton.html( NelioContent.i18n.feedback.creatingTask );
	
			var view = this;
			this.model.save( undefined, {
	
				/**
				 * This function updates the values of the given model to the ones
				 * returned by our cloud and re-renders the list of editorial tasks.
				 *
				 * @param model    {object} The model we're saving.
				 * @param response {object} The response from our cloud.
				 *
				 * @since 1.0.0
				 */
				success: function( model, response ) {
	
					view.trigger( 'nc:save:task', response );
					view.$el.dialogS2( 'close' );
	
				},//end success()
	
				/**
				 * Shows a dialog to tell the user what went wrong.
				 *
				 * @since 1.0.0
				 */
				error: function( xhr ) {
	
					NelioContent.helpers.openErrorDialog( xhr.responseJSON );
	
					$okButton.html( NelioContent.i18n.actions.createTask );
					$okButton.prop( 'disabled', false );
					$otherButtons.prop( 'disabled', false );
					view.$el.dialogS2( 'option', 'closeOnEscape', true );
					view._unlock();
	
				}//end error()
	
			});
	
		},//end _onDialogSave()
	
		/**
		 * Callback function that closes the current dialog and discards all changes.
		 *
		 * @since 1.0.0
		 */
		_onDialogCancel: function() {
	
			this.$el.dialogS2( 'close' );
	
		},//end _onDialogCancel()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// Remove child views.
			for ( var viewName in this._views ) {
	
				if ( this._views.hasOwnProperty( viewName ) ) {
	
					var view = this._views[ viewName ];
					if ( typeof view === 'object' ) {
						view.close();
					}//end if
	
				}//end if
	
			}//end for
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class TaskDialog
	
	
	/**
	 * This view represents an item in the calendar.
	 *
	 * @constructor
	 * @augments Backbone.View
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	NelioContent.views.CalendarItem = Backbone.View.extend({
	
		/**
		 * Whether the user can interact with the view or not.
		 */
		_isLocked: false,
	
		/**
		 * Whether the user might be able to drag it or not.
		 */
		_isDraggable: false,
	
		/**
		 * Whether the element can trigger a click event or not.
		 */
		_isClickable: false,
	
		/**
		 * An underscore template for rendering a post in the calendar.
		 */
		_postTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-post-item' ).innerHTML ) ),
	
		/**
		 * An underscore template for rendering a social message in the calendar.
		 */
		_socialTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-social-item' ).innerHTML ) ),
	
		/**
		 * An underscore template for rendering a task in the calendar.
		 */
		_taskTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-task-item' ).innerHTML ) ),
	
		/**
		 * List of events and their callbacks.
		 */
		events: {
			'mouseenter .nc-calendar-item:not( .nc-locked )': '_onMouseEnter',
			'mouseleave .nc-calendar-item:not( .nc-locked )': '_onMouseLeave',
	
			'click .nc-calendar-item:not( .nc-locked )': '_onClick'
		},
	
		/**
		 * Initializes a new instance of this view.
		 *
		 * @param options {object} Additional options.
		 *
		 * @since 1.0.0
		 */
		initialize: function( options ) {
	
			// Check whether the user can "interact" with the element.
			this._checkUserPermissions();
	
			// Add listeners.
			this.render = _.bind( this.render, this );
			this.listenTo( this, 'nc:render', this.render );
			this.listenTo( this.model, 'change', this.render );
	
			var view = this;
	
			if ( this._isDraggable ) {
	
				this.$el.addClass( 'nc-draggable-calendar-item' );
				this.$el.draggable({
	
					appendTo: options.$containment,
					containment: options.$containment,
					refreshPositions: true,
					scroll: false,
	
					start: function( ev, ui ) {
						$( this ).css( 'visibility', 'hidden' );
						view.trigger( 'nc:drag:start', view.model, view );
					},
	
					stop: function( ev, ui ) {
						$( this ).css( 'visibility', '' );
						view.trigger( 'nc:drag:stop', view.model, view );
					},
	
					helper: function() {
						var $helper = $( this ).clone();
						$helper.detach();
						options.$containment.append( $helper );
						$helper.css( 'z-index', '999' );
						$helper.width( $( this ).width() );
						$helper.height( $( this ).height() );
						return $helper;
					}
	
				});
	
			}//end if
	
		},//end initialize()
	
		/**
		 * Renders this view.
		 *
		 * @return {CalendarItem} this instance.
		 *
		 * @since 1.0.0
		 */
		render: function() {
	
			var data;
	
			switch ( this.model.get( 'calendarKind' ) ) {
	
				case 'post':
					data = this.model.toJSON();
	
					data.categories = _.reduce( data.categories, function( memo, i ) {
						return memo += i.name + ', ';
					}, '' ).slice( 0, -2 );
	
					var model = this.model;
					data.typeLabel = _.reduce( NelioContent.postTypes, function( memo, pt ) {
						if ( pt.name === model.get( 'type' ) ) {
							return pt.labels.singular;
						} else {
							return memo;
						}//end if
					}, NelioContent.i18n.postName );
	
					// Information about the author.
					var author = NelioContent.users.getUser( this.model.get( 'author' ) );
					if ( author.isLoading() ) {
						this.listenToOnce( author, 'nc:load', _.bind( function() {
							this.trigger( 'nc:render' );
						}, this ) );
					}//end if
	
					data.photo = author.get( 'photo' );
					data.displayNameEscaped = _.escape( author.get( 'name' ) );
					data.firstLetter = author.get( 'firstLetter' );
	
					// Render and break.
					this.el.innerHTML = this._postTemplate( data );
					break;
	
				case 'social':
					data = this.model.toJSON();
	
					// Information about the profile.
					var profile = NelioContent.profiles.get( this.model.get( 'profileId' ) );
					data.photo = profile.get( 'photo' );
					data.displayNameEscaped = _.escape( profile.get( 'displayNameEscaped' ) );
					data.firstLetter = profile.get( 'firstLetter' );
	
					// Render and break.
					this.el.innerHTML = this._socialTemplate( data );
					this.$( '.nc-calendar-item' ).addClass( 'nc-' + this.model.get( 'network' ) );
					break;
	
				case 'task':
					data = this.model.toJSON();
	
					// Information about the assignee.
					var assignee = NelioContent.users.getUser( this.model.get( 'assigneeId' ) );
					if ( assignee.isLoading() ) {
						this.listenToOnce( assignee, 'nc:load', _.bind( function() {
							this.trigger( 'nc:render' );
						}, this ) );
					}//end if
	
					data.photo = assignee.get( 'photo' );
					data.displayNameEscaped = _.escape( assignee.get( 'name' ) );
					data.firstLetter = assignee.get( 'firstLetter' );
	
					// Render and break.
					this.el.innerHTML = this._taskTemplate( data );
					break;
	
			}//end switch
	
			if ( this._isDraggable ) {
	
				if ( this._isLocked ) {
					this.$el.draggable( 'disable' );
				} else {
					this.$el.draggable( 'enable' );
				}//end if
	
			}//end if
	
			if ( this._isLocked ) {
				this.$el.find( '.nc-calendar-item' ).addClass( 'nc-locked' );
				this.$el.find( '.nc-calendar-item' ).addClass( 'nc-blurred' );
			}//end if
	
			return this;
	
		},//end render()
	
		/**
		 * Removes any highlighting or blurring the view might have had.
		 *
		 * @since 1.0.0
		 */
		homogenize: function() {
	
			this.$el.find( '.nc-calendar-item' ).removeClass( 'nc-highlight' );
			this.$el.find( '.nc-calendar-item' ).removeClass( 'nc-blurred' );
	
			if ( 'publish' === this.model.get( 'status' ) ) {
				this.$el.find( '.nc-calendar-item' ).addClass( 'nc-blurred' );
			}//end if
	
		},//end homogenize()
	
		/**
		 * Highlights the view.
		 *
		 * @since 1.0.0
		 */
		highlight: function() {
	
			if ( 'publish' === this.model.get( 'status' ) ) {
				this.$el.find( '.nc-calendar-item' ).addClass( 'nc-blurred' );
			}//end if
	
			if ( 'post' === this.model.get( 'calendarKind' ) ) {
				this.$el.find( '.nc-calendar-item' ).removeClass( 'nc-blurred' );
			}//end if
	
			this.$el.find( '.nc-calendar-item' ).addClass( 'nc-highlight' );
	
		},//end highlight()
	
		/**
		 * Blurs the view.
		 *
		 * @since 1.0.0
		 */
		blur: function() {
	
			if ( 'publish' === this.model.get( 'status' ) ) {
				return;
			}//end if
	
			this.$el.find( '.nc-calendar-item' ).addClass( 'nc-blurred' );
	
		},//end blur()
	
		/**
		 * Locks the view, so that the user can't interact with it.
		 *
		 * @since 1.0.0
		 */
		lock: function() {
	
			this._isLocked = true;
			this.trigger( 'nc:render' );
	
		},//end lock()
	
		/**
		 * Unlocks the view, so that the user can interact with it.
		 *
		 * @since 1.0.0
		 */
		unlock: function() {
	
			this._isLocked = false;
			this.trigger( 'nc:render' );
	
		},//end unlock()
	
		/**
		 * This helper function determines which interactions are possible between
		 * the user and the view, based on the former's role.
		 *
		 * @since 1.0.0
		 */
		_checkUserPermissions: function() {
	
			var userId = NelioContent.users.current().get( 'id' );
			var role = NelioContent.users.current().get( 'role' );
	
			switch ( this.model.get( 'calendarKind' ) ) {
	
				case 'post':
	
					this._isClickable = true;
	
					if ( 'publish' === this.model.get( 'status' ) ) {
	
						this._isDraggable = false;
	
					} else {
	
						if ( 'contributor' === role ) {
							this._isDraggable = false;
						} else if ( 'author' === role ) {
							this._isDraggable = userId === this.model.get( 'author' );
						} else {
							this._isDraggable = true;
						}//end if
	
					}//end if
	
					break;
	
				case 'social':
					this._isClickable = 'contributor' !== role;
					this._isDraggable = 'contributor' !== role;
					break;
	
				case 'task':
					if ( 'contributor' === role ) {
						this._isClickable = userId === this.model.get( 'assigneeId' );
						this._isDraggable = false;
					} else if ( 'author' === role ) {
						this._isClickable = userId === this.model.get( 'assigneeId' );
						this._isDraggable = userId === this.model.get( 'assigneeId' );
					} else {
						this._isClickable = true;
						this._isDraggable = true;
					}//end if
					break;
	
			}//end switch
	
		},//end _checkUserPermissions()
	
		/**
		 * Callback function that triggers the event `nc:enter:mouse` when the mouse enters the view.
		 *
		 * Event params:
		 *  * Model's ID.
		 *  * Related post's ID.
		 *
		 * @since 1.0.0
		 */
		_onMouseEnter: function() {
	
			switch ( this.model.get( 'calendarKind' ) ) {
	
				case 'post':
					this.trigger( 'nc:enter:mouse', this.model.get( 'id' ), this.model.get( 'id' ) );
					break;
	
				default:
					this.trigger( 'nc:enter:mouse', this.model.get( 'id' ), this.model.get( 'postId' ) );
	
			}//end switch
	
		},//end _onMouseEnter()
	
		/**
		 * Callback function that triggers the event `nc:leave:mouse` when the mouse leaves the view.
		 *
		 * Event params:
		 *  * Related post's ID.
		 *
		 * @since 1.0.0
		 */
		_onMouseLeave: function() {
	
			switch ( this.model.get( 'calendarKind' ) ) {
	
				case 'post':
					this.trigger( 'nc:leave:mouse', this.model.get( 'id' ) );
					break;
	
				default:
					this.trigger( 'nc:leave:mouse', this.model.get( 'postId' ) );
	
			}//end switch
	
		},//end _onMouseLeave()
	
		/**
		 * Callback function that triggers the event `nc:click` when the view is clicked.
		 *
		 * Event params:
		 *  * Related model.
		 *
		 * @since 1.0.0
		 */
		_onClick: function() {
	
			if ( this._isClickable ) {
				this.trigger( 'nc:click', this.model );
			}//end if
	
		},//end _onClick()
	
		/**
		 * This function disposes the view, unbinding all events and removing it from the DOM.
		 *
		 * If things work as expected, there should be no memory leaks.
		 *
		 * @since 1.0.0
		 */
		close: function() {
	
			// We remove the element from the DOM and unbind all events it was
			// attached to.
			this.stopListening();
			this.unbind();
			if ( typeof this.el !== 'undefined' ) {
				this.remove();
				this.el = undefined;
				this.$el = undefined;
			}//end if
	
		}//end close()
	
	});//class CalendarItem
	
	
	/**
	 * This file creates the view for rendering the whole calendar page.
	 *
	 * To make it more developer-friendly, the Backbone view has been splitted into
	 * several files. Each file deals with one functionality of the view. Thus, for
	 * example, there's a file with all the render-related functions and
	 * attributes, another file that deals with collection-changed callbacks, and
	 * another file that manages all the dialogs for adding/editing stuff.
	 *
	 * @since 1.0.0
	 * @author David Aguilera <david.aguilera@neliosoftware.com>
	 */
	(function() {
	
		'use strict';
	
		// This variable is used by each individual partial file. It's supposed to
		// contain all attributes and functions required by the Backbone View.
		var Calendar = {
			object: {},
			extend: function( object ) {
				this.object = _.extend( this.object, object );
			}
		};
	
		// Include all dependencies.
		// ===========================================================================
		/**
		 * This file contains the basic information of a View (events, init method, and
		 * so on).
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * A reference to the window object.
			 */
			_$window: undefined,
		
			/**
			 * Some elements added by WordPress in the Dashboard.
			 */
			_wp: {
				$adminbar: undefined,
				$adminmenuwrap: undefined,
				$collapseMenu: undefined,
				$collapseButton: undefined
			},
		
			/**
			 * List of events and their callbacks.
			 */
			events: {
		
				'change .nc-post-filter': '_onPostFilterChange',
				'change .nc-social-filter': '_onSocialFilterChange',
				'change .nc-task-filter': '_onTaskFilterChange',
		
				'click .nc-enabled .nc-action.nc-today': '_today',
				'click .nc-enabled .nc-action.nc-month.nc-prev': '_prevMonth',
				'click .nc-enabled .nc-action.nc-month.nc-next': '_nextMonth',
		
				'click .nc-enabled .nc-action.nc-add-post': '_addPost',
				'click .nc-enabled .nc-action.nc-add-social': '_addSocial',
				'click .nc-enabled .nc-action.nc-add-task': '_addTask'
		
			},
		
			/**
			 * Initializes a new instance of this view.
			 *
			 * @since 1.0.0
			 */
			initialize: function() {
		
				// Some generic variables.
				this._$window = $( window );
				this._wp.$adminbar = $( '#adminbar' );
				this._wp.$adminmenuwrap = $( '#adminmenuwrap' );
				this._wp.$collapseMenu = $( '#collapse-menu' );
				this._wp.$collapseButton = $( '#collapse-button' );
		
				// Create child views (assuming the collection is not empty).
				this._resetItemViews();
		
				// Debounce some functions.
				this._fixShadows = _.debounce( this._fixShadows, 150 );
				this._scrollToToday = _.debounce( this._scrollToToday, 250 );
		
				this.render = _.bind( this.render, this );
				this._renderDebounced = _.debounce( this.render, 100 );
				this._resizeDebounced = _.debounce( this._resize, 200 );
		
				// Add listeners.
				this.listenTo( this.collection, 'nc:reset:empty', this._resetItemViews );
				this.listenTo( this.collection, 'nc:reset:empty', this.render );
		
				this.listenTo( this.collection, 'nc:reset:items', this._resetItemViews );
				this.listenTo( this.collection, 'nc:reset:items', this.render );
				this.listenTo( this.collection, 'nc:reset:items', this._fixScroll );
		
				this.listenTo( this.collection, 'add', this._addItem );
				this.listenTo( this.collection, 'add', this.render );
		
				this.listenTo( this.collection, 'remove', this._removeItem );
				this.listenTo( this.collection, 'remove', this.render );
		
				this.listenTo( this.collection, 'nc:change:isLoading', this._onLoadingItems );
		
				this.listenTo( this, 'nc:render:debounced', this._renderDebounced );
				this.listenTo( this, 'nc:render:now', this.render );
		
				if ( ! NelioContent.profiles.isReady() ) {
					this.listenToOnce( NelioContent.profiles, 'nc:ready', this._renderDebounced );
				}//end if
		
				this._resize = _.bind( this._resize, this );
				this._onCalendarScroll = _.bind( this._onCalendarScroll, this );
				this._scrollCalendarUp = _.bind( this._scrollCalendarUp, this );
				this._scrollCalendarDown = _.bind( this._scrollCalendarDown, this );
		
			},//end initialize()
		
			/**
			 * This function disposes the view, unbinding all events and removing it from the DOM.
			 *
			 * If things work as expected, there should be no memory leaks.
			 *
			 * @since 1.0.0
			 */
			close: function() {
		
				// We remove the element from the DOM and unbind all events it was
				// attached to.
				this.stopListening();
				this.unbind();
				this._$window.off( 'resize', this._resize );
				this._wp.collapseMenu.off( 'click', this._resizeDebounced );
				this._wp.collapseButton.off( 'click', this._resizeDebounced );
				this._ui.$calendar.off( 'scroll', this._onCalendarScroll );
		
				if ( typeof this.el !== 'undefined' ) {
					this.remove();
					this.el = undefined;
					this.$el = undefined;
				}//end if
		
			}//end close()
		
		});//class Calendar
		
		
		/**
		 * This file defines all the callbacks related to changes in the collection.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * A callback function invoked when resetting this view's collection.
			 *
			 * It removes old child views and creates a new set of child views.
			 *
			 * @since 1.0.0
			 */
			_resetItemViews: function() {
		
				// Remove old views (if any).
				_.each( this._itemViews, function( view ) {
					this.stopListening( view );
					view.close();
				}, this );
				this._itemViews = [];
		
				// Create new views.
				this.collection.each( this._addItem, this );
		
			},//end _resetItemViews()
		
			/**
			 * A callback function invoked when adding a new item to this collection.
			 *
			 * @param item {object} A new item.
			 *
			 * @since 1.0.0
			 */
			_addItem: function( item ) {
		
				if ( this._dragging.active ) {
					if ( item.get( 'id' ) === this._dragging.view.model.get( 'id' ) ) {
						return;
					}//end if
				}//end if
		
				var view = new NelioContent.views.CalendarItem({
					model : item,
					$containment: this._ui.$calendarHolder
				});
				this._itemViews.push( view );
		
				this.listenTo( view, 'nc:drag:start', this._onDragStart );
				this.listenTo( view, 'nc:drag:stop', this._onDragStop );
		
				this.listenTo( view, 'nc:enter:mouse', this._highlightItems );
				this.listenTo( view, 'nc:leave:mouse', this._homogenizeItems );
		
				switch ( view.model.get( 'calendarKind' ) ) {
		
					case 'post':
						this.listenTo( view, 'nc:click', this._editPost );
						break;
		
					case 'social':
		
						if ( 'error' === view.model.get( 'status' ) ) {
							this.listenTo( view, 'nc:click', this._openSocialErrorDialog );
						} else {
							this.listenTo( view, 'nc:click', this._editSocial );
						}//end if
		
						break;
		
					case 'task':
						this.listenTo( view, 'nc:click', this._toggleTaskCompletion );
						break;
		
				}//end switch
		
				this._sortViews();
		
			},//end _addItem()
		
			/**
			 * This function sorts all views in calendar applying the following rules:
			 *
			 *  * Tasks always come first.
			 *  * Chronological order.
			 *  * If dates are the same, posts come before social messages.
			 *  * Twitter social messages come first.
			 *  * Network order.
			 *
			 * @since 1.0.0
			 */
			_sortViews: function() {
		
				// Sort views based on their type and date.
				this._itemViews = _.sortBy( this._itemViews, function( view ) {
		
					var item = view.model;
					var result;
					switch ( item.get( 'calendarKind' ) ) {
		
						case 'task':
							result = 'a' + item.get( 'dateDue' ).format( 'YYYY-MM-DDTHH:mm' ) + item.get( 'task' );
							break;
		
						case 'post':
							result = 'b' + item.get( 'date' ).format( 'YYYY-MM-DDTHH:mm' ) + 'a';
							break;
		
						case 'social':
							result = 'b' + item.get( 'schedule' ).format( 'YYYY-MM-DDTHH:mm' ) + 'b';
							if ( 'twitter' === item.get( 'network' ) ) {
								result += 'a';
							} else {
								result += 'b';
							}//end if
							result += item.get( 'network' ) + item.get( 'profileId' ) + item.get( 'text' );
							break;
		
						default:
							result = 'z';
		
					}//end switch
		
					return result;
		
				});
		
			},//end _sortViews()
		
			/**
			 * A callback function invoked when removing an item from the collection.
			 *
			 * @param item {object} A new item.
			 *
			 * @since 1.0.0
			 */
			_removeItem: function( item ) {
		
				// Look for the view associated with the given item.
				var view = _.find( this._itemViews, function( view ) {
					return view.model.get( 'id' ) === item.get( 'id' );
				});
		
				// If we found it, remove it from the list and close it.
				if ( typeof view !== 'undefined' ) {
					this._itemViews = _.without( this._itemViews, view );
					this.stopListening( view );
					view.close();
				}//end if
		
			}//end _removeItem()
		
		});//class Calendar
		
		
		/**
		 * This file includes methods for creating new items in the calendar.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * Callback function that opens the dialog for creating a new post.
			 *
			 * @param ev {object} The JavaScript event that triggered the callback.
			 *
			 * @since 1.0.0
			 */
			_addPost: function( ev ) {
		
				var target = ev.target || ev.srcElement;
				var $el = $( target ).closest( '.nc-add-post' );
		
				var dialog = new NelioContent.views.PostEditor({
					model: new NelioContent.models.Post(),
					date: $el.data( 'date' )
				});
		
				// Listen to dialog events.
				var view = this;
				this.listenTo( dialog, 'nc:save:post', function( post ) {
					view.collection.add( post );
				});
		
				this.listenTo( dialog, 'nc:close:dialog', function( post ) {
					view.stopListening( dialog );
				});
		
				// Open the dialog.
				dialog.render();
		
			},//end _addPost()
		
			/**
			 * Callback function that opens the dialog for creating a new social message.
			 *
			 * @param ev {object} The JavaScript event that triggered the callback.
			 *
			 * @since 1.0.0
			 */
			_addSocial: function( ev ) {
		
				if ( 'none' === NelioContent.subscriptionPlan ) {
					ev.preventDefault();
					return;
				}//end if
		
				if ( 0 === NelioContent.profiles.length ) {
					this._openNoProfilesDialog();
					return;
				}//end if
		
				var target = ev.target || ev.srcElement;
				var $el = $( target ).closest( '.nc-add-social' );
		
				var message = new NelioContent.models.SocialMessage();
				message.set( 'profileId', NelioContent.profiles.at( 0 ).get( 'id' ) );
		
				var date = ncNewLocalMoment( $el.data( 'date' ) );
				var today = ncNewLocalMoment();
				if ( date.format( 'YYYYMMDD' ) === today.format( 'YYYYMMDD' ) ) {
					message.set( 'dateType', 'predefined-offset' );
					message.set( 'dateValue', '0' );
					message.set( 'timeType', 'predefined-offset' );
					message.set( 'timeValue', '0' );
				} else {
					message.set( 'dateType', 'exact' );
					message.set( 'dateValue', $el.data( 'date' ) );
					message.set( 'timeType', 'time-interval' );
					message.set( 'timeValue', 'morning' );
				}//end if
		
				var dialog = new NelioContent.views.SocialMessageEditor({
					model: message
				});
		
				// Listen to dialog events.
				var view = this;
				this.listenTo( dialog, 'nc:add:messages', function( messages ) {
					for ( var i = 0; i < messages.length; ++i ) {
						messages[i].calendarKind = 'social';
					}//end for
					view.collection.add( messages );
				});
		
				this.listenTo( dialog, 'nc:close:dialog', function( post ) {
					view.stopListening( dialog );
				});
		
				// Open the dialog.
				dialog.render();
		
			},//end _addSocial()
		
			/**
			 * Callback function that opens the dialog for creating a new task.
			 *
			 * @param ev {object} The JavaScript event that triggered the callback.
			 *
			 * @since 1.0.0
			 */
			_addTask: function( ev ) {
		
				if ( 'none' === NelioContent.subscriptionPlan ) {
					ev.preventDefault();
					return;
				}//end if
		
				var target = ev.target || ev.srcElement;
				var $el = $( target ).closest( '.nc-add-task' );
		
				var dialog = new NelioContent.views.TaskDialog({
					model: new NelioContent.models.EditorialTask(),
					date: $el.data( 'date' )
				});
		
				// Listen to dialog events.
				var view = this;
				this.listenTo( dialog, 'nc:save:task', function( task ) {
					task.calendarKind = 'task';
					view.collection.add( task );
				});
		
				this.listenTo( dialog, 'nc:close:dialog', function( task ) {
					view.stopListening( dialog );
				});
		
				// Open the dialog.
				dialog.render();
		
			},//end _addTask()
		
			/**
			 * Helper function that opens a dialog telling the user that no social
			 * profiles are available.
			 *
			 * @since 1.0.0
			 */
			_openNoProfilesDialog: function() {
		
				var $el = $( '<div></div>' ).html( document.getElementById( '_nc-no-profile-available' ).innerHTML );
		
				$el.dialog({
		
					title: NelioContent.i18n.titles.addSocialProfiles,
					modal: true,
					width: 450,
		
					open: function() {
						$el.find( 'a' ).blur();
					},//end open()
		
					buttons: [
						{
							text: NelioContent.i18n.actions.addSocialProfile,
							'class': 'button button-primary',
							click: function() {
								document.location.href = NelioContent.pages.settings;
							}//end click()
						}//end button
					]//end buttons
		
				});
		
			}//end _openNoProfilesDialog()
		
		});//class Calendar
		
		
		/**
		 * This file contains all the functions and attributes required for rendering
		 * the view.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * This variable holds a reference to the interval that applies an autoscroll
			 * whilst hovering near calendar's top and bottom sides.
			 *
			 * @since 1.0.0
			 */
			_autoscrollInterval: 0,
		
			/**
			 * Some dragging-related information,
			 *
			 *  * `active`: whether we're dragging something or not.
			 *  * `dropArea`: the type of area in which we dropped the element, if any.
			 *  * `view`: the view (calendar item) we're dragging.
			 *
			 * @since 1.0.0
			 */
			_dragging: {
				active: false,
				dropArea: 'none',
				view: undefined
			},
		
			/**
			 * A callback function invoked when an item is about to be dragged.
			 *
			 * @param item {object} the item we're dragging.
			 * @param view {object} the view we're dragging.
			 *
			 * @since 1.0.0
			 */
			_onDragStart: function( item, view ) {
		
				this.$( '.nc-context-actions' ).addClass( 'nc-dragging' );
		
				this._dragging.active = true;
				this._dragging.view = view;
				this._itemViews = _.without( this._itemViews, view );
		
				_.each( this._itemViews, function( iv ) {
					iv.blur();
				});
		
			},//end _onDragStart()
		
			/**
			 * A callback function invoked when an element is dropped.
			 *
			 * @param item {object} the item we were dragging.
			 * @param view {object} the view we were dragging.
			 *
			 * @since 1.0.0
			 */
			_onDragStop: function( item, view ) {
		
				if ( 'none' === this._dragging.dropArea ) {
		
					var that = this;
					_.each( this._itemViews, function( iv ) {
						iv.homogenize();
					});
		
				}//end if
		
				if ( ! this._dragging.active ) {
					return;
				}//end if
		
				// If we didn't drop the view in trash, we can place it wherever it's
				// supposed to be.
				if ( 'trash' !== this._dragging.dropArea ) {
					this._dragging.view = undefined;
					this._itemViews.push( view );
					this._sortViews();
				}//end if
		
				this._dragging.active = false;
				this._dragging.dropArea = 'none';
		
				this.$( '.nc-context-actions' ).removeClass( 'nc-dragging' );
		
			},//end _onDragStop()
		
			/**
			 * Helper function for specify, using jQuery's droppable functionality, the
			 * areas in the calendar in which we may drop a calendar item.
			 *
			 * These areas are:
			 *
			 *  * A day, so that we can reschedule staff.
			 *  * The prev/next month areas, so that we can change the current month
			 *    while dragging a calendar item.
			 *  * The trash area, so that we can remove calendar items.
			 *
			 * @since 1.0.0
			 */
			_buildDroppableAreas: function() {
		
				var that = this;
				var collection = this.collection;
		
				// Prepare scroll up/down areas.
				this._ui.$scrollUpArea.droppable({
		
					accept: '.nc-draggable-calendar-item',
					hoverClass: 'hovering',
					tolerance: 'touch',
		
					over: function() {
						clearInterval( that._autoscrollInterval );
						that._autoscrollInterval = setInterval( that._scrollCalendarUp, 50 );
					},//end over()
		
					out: function() {
						clearInterval( that._autoscrollInterval );
					},//end out()
		
					drop: function() {
						clearInterval( that._autoscrollInterval );
					}//end drop()
		
				});
		
				this._ui.$scrollDownArea.droppable({
		
					accept: '.nc-draggable-calendar-item',
					hoverClass: 'hovering',
					tolerance: 'touch',
		
					over: function() {
						clearInterval( that._autoscrollInterval );
						that._autoscrollInterval = setInterval( that._scrollCalendarDown, 50 );
					},//end over()
		
					out: function() {
						clearInterval( that._autoscrollInterval );
					},//end out()
		
					drop: function() {
						clearInterval( that._autoscrollInterval );
					}//end drop()
		
				});
		
				// Make days droppable elements, so that we can drag events and drop them
				// on the day.
				this.$( '.nc-day' ).droppable({
		
					accept: '.nc-draggable-calendar-item',
					hoverClass: 'nc-highlight',
					tolerance: 'pointer',
		
					/**
					 * Reschedules an event to the new day in which it's been dropped.
					 *
					 * @param ev {object} The JavaScript event that triggered the callback.
					 * @param ui {object} Information about the element we were dragging.
					 *
					 * @since 1.0.0
					 */
					drop: function( ev, ui ) {
		
						that.lock();
						that._dragging.dropArea = 'day';
		
						var $item = $( ui.draggable );
						$( this ).find( '.nc-items' ).append( $item );
		
						// Reset item "dragging" options.
						$item.css( 'position', '' );
						$item.css( 'left', '' );
						$item.css( 'right', '' );
		
						var model = that._dragging.view.model;
		
						// Prepare to act when the model has been rescheduled.
						if ( 'post' === model.get( 'calendarKind' ) ) {
		
							that.listenToOnce( model, 'nc:reschedule', that.collection.refresh );
		
						} else {
		
							that.listenToOnce( model, 'nc:reschedule', function() {
		
								that.stopListening( model, 'nc:undo:reschedule' );
								that.stopListening( model, 'nc:error' );
								that.unlock();
		
							});
		
						}//end if
		
						// Abort rescheduling properly.
						that.listenToOnce( model, 'nc:undo:reschedule', function( dialog ) {
		
							if ( typeof dialog === 'object' ) {
								NelioContent.helpers.openWarningDialog( dialog.title, dialog.content );
							}//end if
		
							that._onDragStop( model, that._dragging.view );
							that.stopListening( model, 'nc:reschedule' );
							that.stopListening( model, 'nc:error' );
							that.unlock();
		
						});
		
						// Warn the user when things go wrong.
						that.listenToOnce( model, 'nc:error', function() {
		
							// TODO. Do we have a message to show?
							var error = NelioContent.i18n.errors.generic.unableToRescheduleItem;
							NelioContent.helpers.openErrorDialog( error );
		
							that.collection.refresh();
		
						});
		
						// And re-schedule.
						model.reschedule( $( this ).data( 'date' ) );
		
					}//end drop()
		
				});//end droppable()
		
				// Make the trash a droppable element too.
				this.$( '.nc-action.nc-trash' ).droppable({
		
					/**
					 * Deletes the event.
					 *
					 * @param ev {object} The JavaScript event that triggered the callback.
					 *
					 * @since 1.0.0
					 */
					drop: function( ev, ui ) {
		
						that.lock();
		
						var model = that._dragging.view.model;
						that._dragging.dropArea = 'trash';
						that._dragging.view.$el.detach();
		
						// Delete or trash the current model.
						if ( 'post' === model.get( 'calendarKind' ) ) {
		
							// If the model is a post, trash it.
							that.listenToOnce( model, 'nc:trash', that.collection.refresh );
		
							// But be ready to let the user know when things went wrong.
							that.listenToOnce( model, 'nc:error', function( message ) {
		
								// Tell the user something went wrong.
								var error = NelioContent.i18n.errors.post.unableToTrash;
								error = error.replace( '{error}', message.replace( /\.$/, '' ) );
								NelioContent.helpers.openErrorDialog( error );
		
								// Refresh the collection.
								that.collection.refresh();
		
							});
		
							// And re-schedule.
							model.trash();
		
						} else {
		
							// If it's anything else, directly destroy it.
							model.destroy({
		
								/**
								 * After destroy the model successful, remove its view and unlock the calendar.
								 *
								 * @since 1.0.0
								 */
								success: function() {
									that._dragging.view.close();
									that._dragging.view = undefined;
									that.unlock();
								},//end success()
		
								/**
								 * If we couldn't destroy the model, let the user know.
								 *
								 * @since 1.0.0
								 */
								error: function() {
		
									// Tell the user something went wrong.
									// TODO. Maybe add a more detailed error?
									var error = NelioContent.i18n.errors.generic.unableToDeleteItem;
									NelioContent.helpers.openErrorDialog( error );
		
									// Refresh the collection.
									that.collection.refresh();
		
								}//end error()
		
							});
		
						}//end if
		
					},//end drop()
		
					tolerance: 'pointer',
					hoverClass: 'nc-hover'
		
				});//end droppable()
		
				// Make the trash a droppable element too.
				var monthDroppableSettings = {
		
					/**
					 * Clears the interval that changes the current month.
					 *
					 * @param ev {object} The JavaScript event that triggered the callback.
					 *
					 * @since 1.0.0
					 */
					drop: function( ev, ui ) {
		
						clearInterval( this.__interval );
						this.__interval = undefined;
		
					},//end drop()
		
					/**
					 * Clears the interval that changes the current month.
					 *
					 * @param ev {object} The JavaScript event that triggered the callback.
					 *
					 * @since 1.0.0
					 */
					out: function( ev, ui ) {
		
						clearInterval( this.__interval );
						this.__interval = undefined;
		
					},//end out()
		
					tolerance: 'pointer',
					hoverClass: 'nc-hover'
		
				};
		
				/**
				 * Defines a 1-second interval that changes the current month to the
				 * previous one.
				 *
				 * @param ev {object} The JavaScript event that triggered the callback.
				 *
				 * @since 1.0.0
				 */
				monthDroppableSettings.over = function( ev, ui ) {
		
					if ( typeof this.__interval === 'undefined' ) {
		
						this.__interval = setInterval( function() {
							collection.prevMonth();
						}, 1000 );
		
					}//end if
		
				};//end drop()
		
				this.$( '.nc-area.nc-month.nc-prev' ).droppable( monthDroppableSettings );
		
				/**
				 * Defines a 1-second interval that changes the current month to the next
				 * one.
				 *
				 * @param ev {object} The JavaScript event that triggered the callback.
				 *
				 * @since 1.0.0
				 */
				monthDroppableSettings.over = function( ev, ui ) {
		
					if ( typeof this.__interval === 'undefined' ) {
		
						this.__interval = setInterval( function() {
							collection.nextMonth();
						}, 1000 );
		
					}//end if
		
				};//end drop()
		
				this.$( '.nc-area.nc-month.nc-next' ).droppable( monthDroppableSettings );
		
			},//end _buildDroppableAreas()
		
			/**
			 * Scrolls the calendar 20px up.
			 *
			 * @since 1.0.0
			 */
			_scrollCalendarUp: function() {
		
				this._ui.$calendar[0].scrollTop -= 20;
		
			},//end _scrollCalendarUp()
		
			/**
			 * Scrolls the calendar 20px down.
			 *
			 * @since 1.0.0
			 */
			_scrollCalendarDown: function() {
		
				this._ui.$calendar[0].scrollTop += 20;
		
			},//end _scrollCalendarDown()
		
		});//end class
		
		
		/**
		 * This file defines some methods for editing calendar items.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * Callback function that opens the dialog for editing the post.
			 *
			 * @param post {Post} the post we want to edit.
			 *
			 * @since 1.0.0
			 */
			_editPost: function( post ) {
		
				var dialog = new NelioContent.views.PostEditor({
					model: new NelioContent.models.Post( post.toJSON() ),
					date: post.get( 'date' ).format( 'YYYY-MM-DD' )
				});
		
				// Listen to dialog events.
				var view = this;
				this.listenTo( dialog, 'nc:save:post', function( newPost ) {
					view.lock();
					view.collection.refresh();
				});
		
				this.listenTo( dialog, 'nc:trash:post', function() {
					view.collection.remove( post );
					view.lock();
					view.collection.refresh();
				});
		
				this.listenTo( dialog, 'nc:close:dialog', function( post ) {
					view.stopListening( dialog );
				});
		
				// Open the dialog.
				dialog.render();
		
			},//end _editPost()
		
			/**
			 * Callback function that opens the dialog for editing the social message.
			 *
			 * @param message {SocialMessage} the social message we want to edit.
			 *
			 * @since 1.0.0
			 */
			_editSocial: function( message ) {
		
				var messageToEdit = new NelioContent.models.SocialMessage( message.toJSON() );
				var dialog = new NelioContent.views.SocialMessageEditor({
					model: messageToEdit
				});
		
				// Listen to dialog events.
				var view = this;
				this.listenTo( dialog, 'nc:update:message', function( newMessage ) {
					newMessage.calendarKind = 'social';
					view.collection.remove( message );
					view.collection.add( newMessage );
				});
		
				this.listenTo( dialog, 'nc:delete:message', function( message ) {
					view.collection.remove( message );
				});
		
				this.listenTo( dialog, 'nc:close:dialog', function() {
					view.stopListening( dialog );
				});
		
				// Open the dialog.
				dialog.render();
		
			},//end _editSocial()
		
			/**
			 * Callback function that opens a dialog explaining the user why things
			 * went wrong.
			 *
			 * @param message {SocialMessage} the social message that couldn't be sent.
			 *
			 * @since 1.0.0
			 */
			_openSocialErrorDialog: function( message ) {
		
				var view = this;
				var failureDescription = message.get( 'failureDescription' );
				var explanation;
				if ( 0 === NelioContent.helpers.trim( failureDescription ) ) {
					explanation = NelioContent.i18n.dialogs.socialNotSentUnknown;
				} else {
					explanation = NelioContent.i18n.dialogs.socialNotSent.replace( '{error}', _.escape( message.get( 'failureDescription' ) ) );
				}//end if
		
				var $el = $( '<div class="nc-error-dialog">' + explanation + '</div>' );
				$el.dialog({
		
					title: NelioContent.i18n.titles.socialNotSent,
					modal: true,
					width: Math.min( 500, $( window ).width() - 20 ),
		
					buttons: [
		
						{
							'class': 'button',
							text: NelioContent.i18n.actions.editSocial,
							click: function() {
								view._editSocial( message );
								$el.dialog( 'close' );
								$el.dialog( 'destroy' );
							}//end click()
						},
		
						{
							'class': 'button button-primary',
							text: NelioContent.i18n.actions.sendSocialNow,
							click: function() {
								message.shareNow();
								$el.dialog( 'close' );
								$el.dialog( 'destroy' );
							}//end click()
						}
		
					]
		
				});
		
			},//end _openSocialErrorDialog()
		
			/**
			 * Callback function to complete a task.
			 *
			 * @param task {EditorialTask} the editorial task we want to complete.
			 *
			 * @since 1.0.0
			 */
			_toggleTaskCompletion: function( task ) {
		
				// Create the task to be saved.
				var taskToEdit = new NelioContent.models.EditorialTask( task.toJSON() );
				taskToEdit.set( 'completed', ! task.get( 'completed' ) );
		
				// And save the model.
				this.lock();
				var view = this;
				taskToEdit.save( undefined, {
		
					/**
					 * This function updates the values of the given model to the ones
					 * returned by our cloud and re-renders the list of editorial tasks.
					 *
					 * @param model    {object} The model we're saving.
					 * @param response {object} The response from our cloud.
					 *
					 * @since 1.0.0
					 */
					success: function( model, response ) {
		
						task.set( 'completed', response.completed );
						view.unlock();
		
					}//end success()
		
				});
		
			}//end _toggleTaskCompletion()
		
		});//class Calendar
		
		
		/**
		 * This file contains all the functions and attributes required for filtering
		 * which items are visible in the calendar.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * List of possible filters (filter by post, social message, or task) and
			 * their values.
			 */
			_filters: {
				post: 'all',
				social: 'all',
				task: 'all'
			},
		
			/**
			 * This variable contains the templates used in the social filter.
			 */
			_socialFilterTemplates: {
				profile: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-profile' ).innerHTML ) ),
				network: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-network-option' ).innerHTML ) ),
				selectedProfile: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-single-profile-selector-selected-profile' ).innerHTML ) ),
				selectedNetwork: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-network-option' ).innerHTML ) ),
				userOption: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-user-selector-option' ).innerHTML ) )
			},
		
			/**
			 * Given a certain model, this function returns whether it's visible or not,
			 * based on the current filters.
			 *
			 * @param model {object} the model whose visibility has to be checked.
			 *
			 * @return {boolean} whether the given model is visible or not, based on the current filter setup.
			 *
			 * @since 1.0.0
			 */
			filter: function( model ) {
		
				switch ( model.get( 'calendarKind' ) ) {
		
					case 'post':
						if ( 'all' === this._filters.post ) {
							return true;
						} else if ( 'none' === this._filters.post ) {
							return false;
						}//end if
		
						if ( NelioContent.postTypes.length > 1 ) {
							return model.get( 'type' ) === this._filters.post;
						} else if ( 'post' === NelioContent.postTypes[0].name ) {
							return _.contains(
								_.pluck( model.get( 'categories' ), 'id' ),
								this._filters.post
							);
						} else {
							return true;
						}//end if
		
					case 'social':
						if ( 'all' === this._filters.social ) {
							return true;
						} else if ( 'none' === this._filters.social ) {
							return false;
						}//end if
		
						if ( 0 === this._filters.social.indexOf( 'nc:network:' ) ) {
							return model.get( 'network' ) === this._filters.social.substring( 11 );
						}//end if
		
						return model.get( 'profileId' ) === this._filters.social;
		
					case 'task':
						if ( 'all' === this._filters.task ) {
							return true;
						} else if ( 'none' === this._filters.task ) {
							return false;
						}//end if
		
						return model.get( 'assigneeId' ) === this._filters.task;
		
					default:
						console.log( 'Unknown calendar kind.' );
						return false;
		
				}//end switch
		
			},//end _onTaskFilterChange()
		
			/**
			 * Creates Select2 objects for all filters.
			 *
			 * @since 1.0.0
			 */
			_buildFilters: function() {
		
				this._buildPostFilter();
				this._buildSocialFilter();
				this._buildTaskFilter();
		
			},//end _buildFilters()
		
			/**
			 * Create a Select2 object for the Post filter.
			 *
			 * @since 1.0.0
			 */
			_buildPostFilter: function() {
		
				this.$( '.nc-post-filter' ).ncselect2({
					width: '15em',
		
					templateSelection: function( selection ) {
		
						switch ( selection.id ) {
		
							case 'all':
								if ( NelioContent.postTypes.length > 1 ) {
									return NelioContent.i18n.filters.selection.allPostTypes;
								} else {
									return NelioContent.postTypes[0].labels.allItems;
								}//end if
		
							case 'none':
								if ( 1 === NelioContent.postTypes.length && 'post' === NelioContent.postTypes[0].name ) {
									return NelioContent.i18n.filters.selection.noPosts;
								} else {
									return NelioContent.i18n.filters.selection.noPostTypes;
								}//end if
		
							default:
								return selection.text;
		
						}//end switch
		
					}//end templateSelection()
		
				});
		
			},//end _buildPostFilter()
		
			/**
			 * Create a Select2 object for the Social Message filter.
			 *
			 * @since 1.0.0
			 */
			_buildSocialFilter: function() {
		
				// Items in the selector.
				var data = [
					{
						id: 'all',
						text: NelioContent.i18n.filters.actions.showSocialMessages
					}, {
						id: 'none',
						text: NelioContent.i18n.filters.actions.hideSocialMessages
					}
				];
		
				this.stopListening( NelioContent.profiles, 'nc:ready', this._buildSocialFilter );
				if ( ! NelioContent.profiles.isReady() ) {
					this.listenToOnce( NelioContent.profiles, 'nc:ready', this._buildSocialFilter );
				}//end if
		
				if ( NelioContent.profiles.length > 0 ) {
		
					// Prepare the list of profiles.
					var profiles = NelioContent.profiles.toJSON();
					_.each( profiles, function( p ) {
						p.text = p.displayName;
						p.ncselect2Type = 'profile';
					});
		
					// And the list of networks.
					var networkNames = _.uniq( _.pluck( profiles, 'network' ) ).sort();
					var networks = [];
					_.each( networkNames, function( name ) {
		
						var network = _.findWhere( NelioContent.networkMetas, { id:name } );
						if ( typeof network === 'undefined' ) {
							return;
						}//end if
		
						// We use the single profile selector for rendering, so we add
						// all required fields.
						networks.push({
							id: 'nc:network:' + network.id,
							displayName: network.name,
							network: network.id,
							ncselect2Type: 'network',
							text: network.name
						});
		
					});
		
					// And add both sets in ncselect2's data.
					data.push({
						text: NelioContent.i18n.filters.groups.network,
						children: networks
					});
		
					data.push({
						text: NelioContent.i18n.filters.groups.profile,
						children: profiles
					});
		
				}//end if
		
				var dropdownCssClass = 'nc-social-filter';
		
				// Templates for rendering.
				var profileOptionTemplate = this._socialFilterTemplates.profile;
				var networkOptionTemplate = this._socialFilterTemplates.network;
				var selectedProfileTemplate = this._socialFilterTemplates.selectedProfile;
				var selectedNetworkTemplate = this._socialFilterTemplates.selectedNetwork;
		
				// Build the selector.
				this.$( '.nc-social-filter' ).ncselect2({
		
					data: data,
					dropdownCssClass: dropdownCssClass,
					width: '15em',
		
					templateResult: function( option ) {
		
						switch ( option.ncselect2Type ) {
		
							case 'profile':
								return $( profileOptionTemplate( option ) );
		
							case 'network':
								return $( networkOptionTemplate( option ) );
		
							default:
								return option.text;
		
						}//end switch
		
					},//end templateResult()
		
					templateSelection: function( selection ) {
		
						switch ( selection.id ) {
		
							case 'all':
								return NelioContent.i18n.filters.selection.allSocialMessages;
		
							case 'none':
								return NelioContent.i18n.filters.selection.noSocialMessages;
		
							default:
		
								if ( 'profile' === selection.ncselect2Type ) {
									return $( selectedProfileTemplate( selection ) );
								} else {
									return $( selectedNetworkTemplate( selection ) );
								}//end if
		
						}//end switch
		
					}//end templateSelection()
		
				});
		
			},//end _buildSocialFilter()
		
			/**
			 * Create a Select2 object for the Tasks filter.
			 *
			 * @since 1.0.0
			 */
			_buildTaskFilter: function() {
		
				var $select = this.$( '.nc-task-filter' );
		
				if ( $select.length === 0 ) {
					return;
				}//end if
		
				// Items in the selector.
				var allTasks = {
					id: 'all',
					text: NelioContent.i18n.filters.actions.showTasks
				};
		
				var noTasks = {
					id: 'none',
					text: NelioContent.i18n.filters.actions.hideTasks
				};
		
				var assignees = {
					text: NelioContent.i18n.filters.groups.assignee,
					children: _.filter( NelioContent.users.toJSON(), function( user ) {
						user.text = user.name;
						return user.role !== 'subscriber';
					})
				};
		
				// Template for rendering a single user.
				var userOptionTemplate = this._socialFilterTemplates.userOption;
		
				// Build selet 2 component
				$select.ncselect2({
		
					data: [ allTasks, noTasks, assignees ],
					dropdownCssClass: 'nc-task-filter',
					width: '15em',
		
					templateResult: function( user ) {
		
						if ( typeof user.name === 'undefined' ) {
							return user.text;
						}
						return $( userOptionTemplate( user ) );
		
					},//end templateResult()
		
					templateSelection: function( selection ) {
		
						switch ( selection.id ) {
		
							case 'all':
								return NelioContent.i18n.filters.selection.allTasks;
		
							case 'none':
								return NelioContent.i18n.filters.selection.noTasks;
		
							default:
								return NelioContent.i18n.filters.selection.tasksOf.replace( '%s', selection.name );
		
						}//end switch
		
					}//end templateSelection()
		
				});
		
			},//end _buildTaskFilter()
		
			/**
			 * Updates post's filter value and re-renders the view.
			 *
			 * @since 1.0.0
			 */
			_onPostFilterChange: function() {
		
				var aux = this.$( '.nc-post-filter' ).val();
				if ( isNaN( parseInt( aux ) ) ) {
					this._filters.post = aux;
				} else {
					this._filters.post = parseInt( aux );
				}//end if
		
				this.trigger( 'nc:render:debounced' );
		
			},//end _onPostFilterChange()
		
			/**
			 * Updates social messages's filter value and re-renders the view.
			 *
			 * @since 1.0.0
			 */
			_onSocialFilterChange: function() {
		
				this._filters.social = this.$( '.nc-social-filter' ).val();
				this.trigger( 'nc:render:debounced' );
		
			},//end _onSocialFilterChange()
		
			/**
			 * Updates task's filter value and re-renders the view.
			 *
			 * @since 1.0.0
			 */
			_onTaskFilterChange: function() {
		
				var aux = this.$( '.nc-task-filter' ).val();
				if ( isNaN( parseInt( aux ) ) ) {
					this._filters.task = aux;
				} else {
					this._filters.task = parseInt( aux );
				}//end if
		
				this.trigger( 'nc:render:debounced' );
		
			}//end _onTaskFilterChange()
		
		});//class Calendar
		
		
		/**
		 * This file contains all the functions and attributes required for rendering
		 * the view.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * A callback function automatically called whenever the window is resized.
			 *
			 * @since 1.0.0
			 */
			_resize: function() {
		
				// Prepare some variables.
				var scrollbarWidth = NelioContent.helpers.getScrollbarWidth();
				var height = this._getAvailableHeight();
				var calWidth = this._ui.$helperDivForCalendarWidth.width();
		
				// Define container's height and header's size.
				this._ui.$container.height( height );
				this._ui.$header.width( calWidth );
		
				// Based on header's size, fix context actions and grid.
				height = height - this._ui.$header.height();
		
				this._ui.$calendarHolder.width( calWidth );
				this._ui.$calendarHolder.height( height );
		
				this._ui.$actions.height( height );
				this._ui.$calendar.css( 'height', height );
		
				// Fix next/prev month actions size.
				var containerBCR = this._ui.$container[0].getBoundingClientRect();
				var monthActionBCR = this._ui.$monthActionAreas[0].getBoundingClientRect();
				var monthActionHeight = Math.floor( containerBCR.bottom - monthActionBCR.top - 10 );
		
				var padding = Math.max( Math.floor( monthActionHeight - Math.floor( height / 2 ) - 20 ), 0 );
				this._ui.$monthActionAreas.css( 'padding-top', padding );
				this._ui.$monthActionAreas.height( monthActionHeight - padding );
		
				// Fix scroll areas width.
				var scrollAreasWidth = calWidth - 2 * this._ui.$actions.width();
				this._ui.$scrollUpArea.width( scrollAreasWidth );
				this._ui.$scrollDownArea.width( scrollAreasWidth );
		
				// Fix week size.
				this.$( '.nc-week' ).css( 'min-height', '' );
				if ( this._ui.$grid.height() <= height ) {
					var weekHeight = Math.floor( height / 6 ); // TODO. Make this "dynamic".
					this.$( '.nc-week' ).css( 'min-height', weekHeight );
					this.$( '.nc-week' ).first().css( 'min-height', weekHeight );
				}//end if
		
				// And make sure calendar's scrollbar is not visible.
				if ( 'ltr' === this._ui.textDirection ) {
					this._ui.$calendar.css( 'padding-left', this._ui.$actions.width() + scrollbarWidth );
					this._ui.$calendar.css( 'padding-right', this._ui.$actions.width() );
				} else {
					this._ui.$calendar.css( 'padding-left', this._ui.$actions.width() );
					this._ui.$calendar.css( 'padding-right', this._ui.$actions.width() + scrollbarWidth );
				}//end if
		
				this._ui.$calendar.css( 'margin-left', -scrollbarWidth );
				this._ui.$calendar.width( this._ui.$container.width() - 2 * this._ui.$actions.width() + scrollbarWidth );
		
				// Finally, fix shadows, so that the user can know whether there's stuff
				// below or above the current view.
				this._fixShadows();
		
			},//end _resize()
		
			/**
			 * Callback function called when scrolling up or down the calendar.
			 *
			 * @since 1.0.0
			 */
			_onCalendarScroll: function() {
		
				this._fixShadows();
				if ( ! this._isLocked ) {
					this._scroll.position = this._ui.$calendar.scrollTop();
				}//end if
		
			},//end _onCalendarScroll()
		
			/**
			 * Prepares the code to auto-locate "Today".
			 *
			 * @since 1.0.4
			 */
			_resetScroll: function() {
		
				this._scroll.seekToday = true;
				this._scroll.position = 0;
				this._ui.$calendar.scrollTop( this._scroll.position );
		
			},//end _resetScroll()
		
			/**
			 * Auto-scroll to the last location or locate "today".
			 *
			 * @since 1.0.0
			 */
			_fixScroll: function() {
		
				// Scroll to last known scroll.
				if ( ! this._scroll.seekToday ) {
					this._ui.$calendar.scrollTop( this._scroll.position );
					return;
				}//end if
		
				this._scrollToToday();
		
			},//end _fixScroll();
		
			/**
			 * Locates where "Today" is and auto-scrolls.
			 *
			 * @since 1.0.4
			 */
			_scrollToToday: function() {
		
				this._scroll.seekToday = false;
		
				// If such scroll doesn't exist, try to scroll to today.
				var $today = this.$( '.nc-day.nc-today' );
				if ( 0 === $today.length ) {
					return;
				}//end if
		
				var todayBCR = $today[0].getBoundingClientRect();
				var headerBCR = this._ui.$header[0].getBoundingClientRect();
		
				// If today is not in the top, try to put it there.
				if ( headerBCR.bottom + 100 !== todayBCR.top ) {
					var requiredScroll = todayBCR.top - headerBCR.bottom - 100;
					this._scroll.position = this._ui.$calendar.scrollTop() + requiredScroll;
					this._ui.$calendar.animate({ scrollTop: this._scroll.position }, 500 );
				}//end if
		
			},//end _scrollToToday()
		
		
			/**
			 * Helper function that adds/removes shadows in the calendar, so that the user
			 * can "see" whether there's more stuff above or down the fold.
			 *
			 * @since 1.0.0
			 */
			_fixShadows: function() {
		
				if ( this._ui.$calendar[0].scrollTop <= 0 ) {
					this._ui.$calendarHolder.removeClass( 'nc-top-shadow' );
				} else {
					this._ui.$calendarHolder.addClass( 'nc-top-shadow' );
				}//end if
		
				// Add bottom scroll mark when needed.
				if ( this._isScrollAtTheBottom() ) {
					this._ui.$calendarHolder.removeClass( 'nc-bottom-shadow' );
				} else {
					this._ui.$calendarHolder.addClass( 'nc-bottom-shadow' );
				}//end if
		
				// Disable horizontal scrolling.
				if ( this._ui.$calendar.scrollLeft() !== 0 ) {
					this._ui.$calendar.scrollLeft( 0 );
				}//end if
		
			},//end fixShadows()
		
			/**
			 * Whether calendar's scroll is at the bottom or not.
			 *
			 * @return {boolean} Whether calendar's scroll is at the bottom or not.
			 *
			 * @since 1.0.0
			 */
			_isScrollAtTheBottom: function() {
		
				return this._ui.$calendar[0].scrollHeight - this._ui.$calendar.scrollTop() <= this._ui.$calendar.outerHeight();
		
			},//end _isScrollAtTheBottom()
		
			/**
			 * A helper function that computes the total height available for creating the calendar.
			 *
			 * @since 1.0.0
			 */
			_getAvailableHeight: function() {
		
				var height = window.innerHeight;
				return height - this._wp.$adminbar.height() - 100;
		
			}//end getAvailableHeight()
		
		});//class Calendar
		
		
		/**
		 * This file contains navigation callbacks.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * Callback function that sets the visible month to "today".
			 *
			 * @since 1.0.0
			 */
			_today: function() {
		
				this._resetScroll();
				this.collection.gotoDate( ncNewLocalMoment() );
				return false;
		
			},//end _today()
		
			/**
			 * Callback function that changes the current month to the previous month.
			 *
			 * @since 1.0.0
			 */
			_prevMonth: function() {
		
				this._resetScroll();
				this.collection.prevMonth();
				return false;
		
			},//end _prevMonth()
		
			/**
			 * Callback function that changes the current month to the next month.
			 *
			 * @since 1.0.0
			 */
			_nextMonth: function() {
		
				this._resetScroll();
				this.collection.nextMonth();
				return false;
		
			}//end _nextMonth()
		
		});//class Calendar
		
		
		/**
		 * This file contains all the functions and attributes required for rendering
		 * the view.
		 *
		 * @since 1.0.0
		 * @author David Aguilera <david.aguilera@neliosoftware.com>
		 */
		Calendar.extend({
		
			/**
			 * Whether this view is being rendered or not.
			 */
			_rendering: false,
		
			/**
			 * Whether this view has already been rendered or not.
			 */
			_rendered: false,
		
			/**
			 * Whether this view is locked or not.
			 */
			_isLocked: false,
		
			/**
			 * Whether information is synching with AWS or not.
			 */
			_isSynching: false,
		
			/**
			 * A Post ID that specifies which elements should be highlighted in the calendar.
			 */
			_highlightedPostId: 0,
		
			/**
			 * An array where the keys are dates formatted as `YYYY-MM-DD` and the values
			 * are the DOM element that renders the given date in the calendar.
			 */
			_daysInGrid: {},
		
			/**
			 * A list of child views for rendering each calendar item.
			 */
			_itemViews: [],
		
			/**
			 * Last scroll location.
			 */
			_scroll: {
				position: 0,
				seekToday: true
			},
		
			/**
			 * References to some elements in the current view.
			 *
			 * NOTE: This object can be replaced by `this.$()` searches, but having them
			 * cached makes things faster.
			 */
			_ui: {
				textDirection: 'ltr',
				$actions: undefined,
				$calendar: undefined,
				$calendarHolder: undefined,
				$container: undefined,
				$grid: undefined,
				$header: undefined,
				$helperDivForCalendarWidth: undefined,
				$monthActionAreas: undefined,
				$scrollDownArea: undefined,
				$scrollUpArea: undefined
			},
		
			/**
			 * The underscore template for this view.
			 */
			template: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-calendar' ).innerHTML ) ),
		
			/**
			 * An underscore template for rendering individual days.
			 */
			_dayTemplate: _.template( NelioContent.helpers.trim( document.getElementById( '_nc-day' ).innerHTML ) ),
		
			/**
			 * Renders this view.
			 *
			 * @return {Calendar} this instance.
			 *
			 * @since 1.0.0
			 */
			render: function() {
		
				if ( this._rendering ) {
					return this;
				}//end if
				this._rendering = true;
		
				// Get some important variables.
				var today = this.collection.getToday();
				var firstDayOfMonth = this.collection.getFirstDayOfMonth();
		
				// Configure the default date for creating new items and
				// enable/disable TODAY button accordingly.
				var newItemDate = today;
				if ( ! this.collection.isTodayVisible() ) {
					newItemDate = ncNewLocalMoment( firstDayOfMonth.format( 'YYYY-MM-' ) + '01' + ' 12:00' );
				}//end if
		
				// Render the whole view.
				if ( ! this._rendered ) {
		
					if ( this.collection.isLoading() ) {
						this._isSynching = true;
						this._isLocked = true;
					}//end if
		
					this.el.innerHTML = this.template({
						newItemDate: newItemDate.format( 'YYYY-MM-DD' )
					});
		
					// Save all elements in my own variables.
					this._ui.$actions = this.$( '.nc-context-actions' );
					this._ui.$monthActionAreas = this.$( '.nc-permanent-actions .nc-area.nc-month' );
					this._ui.$calendar = this.$( '.nc-calendar' );
					this._ui.$calendar = this.$( '.nc-calendar' );
					this._ui.$calendarHolder = this.$( '.nc-calendar-holder' );
					this._ui.$container = this.$( '.nc-calendar-and-header-container' );
					this._ui.$grid = this.$( '.nc-grid' );
					this._ui.$header = this.$( '.nc-calendar-header' );
					this._ui.$helperDivForCalendarWidth = this.$( '.nc-helper-div' );
					this._ui.$scrollDownArea = this.$( '.nc-scroll-down-area' );
					this._ui.$scrollUpArea = this.$( '.nc-scroll-up-area' );
		
					this._ui.textDirection = window.getComputedStyle( this._ui.$calendar[0], null )
						.getPropertyValue( 'direction' );
		
					// And build filters
					this._buildFilters();
		
					// Add some listeners.
					this._$window.on( 'resize', this._resize );
					this._wp.$collapseMenu.on( 'click', this._resizeDebounced );
					this._wp.$collapseButton.on( 'click', this._resizeDebounced );
					this._ui.$calendar.on( 'scroll', this._onCalendarScroll );
		
				}//end if
		
				var monthName = NelioContent.helpers.capitalizeFirstLetter( firstDayOfMonth.format( 'MMMM' ) );
				this.$( '.nc-current-month .nc-month' ).text( monthName );
				this.$( '.nc-current-month .nc-year' ).text( firstDayOfMonth.year() );
				this.el.className = 'nc-' + firstDayOfMonth.locale( 'en' ).format( 'MMMM' ).toLowerCase();
				this._renderWeekDays();
				this._renderGrid();
		
				// Complete render and fix some stuff.
				if ( ! this._rendered ) {
					this._buildDroppableAreas();
				}//end if
				this.$( '.nc-day' ).droppable( 'disable' );
				this.$( '.nc-day.nc-today, .nc-day.nc-future' ).droppable( 'enable' );
		
				this._resize();
		
				// Render events.
				if ( NelioContent.profiles.isReady() ) {
		
					_.each( this._itemViews, function( iv ) {
		
						if ( ! this.filter( iv.model ) ) {
							iv.render().$el.detach();
							return;
						}//end if
		
						var date = iv.model.getRelevantDay();
						$( this._daysInGrid[ date ] ).find( '.nc-items' ).append( iv.render().el );
		
						if ( this._isLocked ) {
							iv.lock();
						} else {
							iv.unlock();
						}//end if
		
					}, this );
		
				}//end if
		
				if ( this._dragging.active ) {
		
					if ( this._isLocked ) {
						this._dragging.view.lock();
					} else {
						this._dragging.view.unlock();
					}//end if
		
				}//end if
		
				// Show the loader when required.
				if ( this._isSynching || this._isLocked ) {
					this.$( '.nc-cal-sync' ).addClass( 'is-active' );
				} else {
					this.$( '.nc-cal-sync' ).removeClass( 'is-active' );
				}//end if
		
				// Controls should be enabled or disabled based on the status...
				if ( this._isLocked ) {
		
					this.$( '.button' ).prop( 'disabled', true );
					this.$( '.nc-day .nc-actions' ).removeClass( 'nc-enabled' );
					this.$( '.nc-regular-actions' ).removeClass( 'nc-enabled' );
					this.$( '.nc-context-actions' ).removeClass( 'nc-enabled' );
					this.$( '.nc-calendar-actions' ).removeClass( 'nc-enabled' );
					this.$( '.nc-post-filter' ).prop( 'disabled', true );
					this.$( '.nc-social-filter' ).prop( 'disabled', true );
					this.$( '.nc-task-filter' ).prop( 'disabled', true );
		
				} else {
		
					this.$( '.button' ).prop( 'disabled', false );
					this.$( '.nc-day .nc-actions' ).addClass( 'nc-enabled' );
					this.$( '.nc-regular-actions' ).addClass( 'nc-enabled' );
					this.$( '.nc-context-actions' ).addClass( 'nc-enabled' );
					this.$( '.nc-calendar-actions' ).addClass( 'nc-enabled' );
					this.$( '.nc-post-filter' ).prop( 'disabled', false );
					this.$( '.nc-social-filter' ).prop( 'disabled', false );
					this.$( '.nc-task-filter' ).prop( 'disabled', false );
		
					// Enable/disable TODAY depending on the currently-visible month
					this.$( '.button.nc-action.nc-today' ).prop( 'disabled', this.collection.isTodayVisible() );
		
				}//end if
		
				// Mark the view as rendered.
				this._rendered = true;
				this._rendering = false;
		
				return this;
		
			},//end render()
		
			/**
			 * This function re-renders the view so that (a) a loader is visible and (b)
			 * all controls are disabled.
			 *
			 * @since 1.0.0
			 */
			lock: function() {
		
				this._isSynching = true;
				this._isLocked = true;
				this.trigger( 'nc:render:now' );
		
			},//end lock()
		
			/**
			 * This function re-renders the view so that (a) a loader is no longer
			 * visible and (b) all controls are enabled again (if they were supposed to
			 * be).
			 *
			 * @since 1.0.0
			 */
			unlock: function() {
		
				this._isSynching = false;
				this._isLocked = false;
				this.trigger( 'nc:render:debounced' );
		
			},//end unlock()
		
			/**
			 * This function re-renders the view so that it shows a "loader".
			 *
			 * @since 1.0.0
			 */
			showLoader: function() {
		
				if ( this._isLocked ) {
					return;
				}//end if
		
				this._isSynching = true;
				this.trigger( 'nc:render:debounced' );
		
			},//end showLoader()
		
			/**
			 * This function re-renders the view so that the "loader" is no longer visible.
			 *
			 * @since 1.0.0
			 */
			hideLoader: function() {
		
				this._isSynching = false;
				this.trigger( 'nc:render:debounced' );
		
			},//end hideLoader()
		
			/**
			 * Callback function that adds/removes visual clues when the calendar's
			 * collection is loading new data.
			 *
			 * @param isLoading {boolean} Whether new data is being loaded or not.
			 *
			 * @since 1.0.0
			 */
			_onLoadingItems: function( isLoading ) {
		
				if ( isLoading ) {
					this.showLoader();
				} else {
					this.unlock();
				}//end if
		
			},//end _onLoadingItems()
		
			/**
			 * Helper function for rendering calendar's top bar with day names.
			 *
			 * @since 1.0.0
			 */
			_renderWeekDays: function() {
		
				var day = this.collection.getFirstDay();
		
				var topbar = this.$( '.nc-days-of-week' )[0];
				var weekDays = '';
				day = this.collection.getFirstDay();
				for ( var d = 0; d < 7; ++d ) {
					weekDays += '<span>' + day.format( 'ddd' ) + '</span>';
					day.add( 1, 'd' );
				}//end for
				day.add( -7, 'd' );
		
				topbar.innerHTML = weekDays;
		
			},//end _renderWeekDays()
		
			/**
			 * A helper function rendering the grid (that is, six weeks with seven days each).
			 *
			 * @since 1.0.0
			 */
			_renderGrid: function() {
		
				// Render the calendar itself.
				var currentDay = this.collection.getFirstDay();
				var today = this.collection.getToday();
		
				if ( ! this._rendered ) {
		
					var grid = this.$( '.nc-grid' )[0];
					var gridContent = '';
					for ( var i = 0; i < 6; ++i ) {
						gridContent += '<div class="nc-week">';
		
						for ( var j = 0; j < 7; ++j ) {
							gridContent += this._dayTemplate();
							currentDay.add( 1, 'd' );
						}//end for
		
						gridContent += '</div>';
		
					}//end for
					grid.innerHTML = gridContent;
		
				}//end if
		
				var daysInGrid = {};
				currentDay = this.collection.getFirstDay();
				var aDayInCurrentMonth = currentDay.clone().add( 14, 'd' );
		
				var view = this;
				this.$( '.nc-day' ).each( function() {
		
					var $day = $( this );
					$day.data( 'date', currentDay.format( 'YYYY-MM-DD' ) );
					$day.attr( 'class', 'nc-day ' + view._getDayClasses( currentDay, aDayInCurrentMonth, today ) );
					$day.find( '.nc-action' ).data( 'date', currentDay.format( 'YYYY-MM-DD' ) );
					$day.find( '.nc-day-number' ).text( currentDay.format( 'DD' ) );
		
					daysInGrid[ currentDay.format( 'YYYY-MM-DD' ) ] = this;
					currentDay.add( 1, 'd' );
		
				});//end each()
		
				this._daysInGrid = daysInGrid;
		
			},//end _renderGrid()
		
			/**
			 * This function returns the list of classes that apply to a certain day,
			 * depending on its relation with today.
			 *
			 * For example, a certain day may be in the past, in the future, or it may be
			 * today.
			 *
			 * @since 1.0.0
			 */
			_getDayClasses: function( day, referenceDay, today ) {
		
				var classes = '';
		
				if ( day.year() < referenceDay.year() || day.month() < referenceDay.month() ) {
					classes = 'nc-other-month ';
				}//end if
		
				if ( day.year() > referenceDay.year() || day.month() > referenceDay.month() ) {
					classes = 'nc-other-month ';
				}//end if
		
				if ( day.year() < today.year() ) {
					classes += 'nc-past';
				} else if ( day.year() > today.year() ) {
					classes += 'nc-future';
				} else if ( day.dayOfYear() < today.dayOfYear() ) {
					classes += 'nc-past';
				} else if ( day.dayOfYear() > today.dayOfYear() ) {
					classes += 'nc-future';
				} else {
					classes += 'nc-today';
				}//end if
		
				return classes;
		
			},//end _getDayClasses()
		
			/**
			 * Callback function that highlights all the items related to the given post ID.
			 *
			 * @param modelId {integer} The element the user was hovering.
			 * @param postId  {integer} The post ID that has to be highlighted.
			 *
			 * @since 1.0.0
			 */
			_highlightItems: function( modelId, postId ) {
		
				// If we're dragging
				if ( this._dragging.active ) {
					return;
				}//end if
		
				if ( this._highlightedPostId > 0 ) {
					this._homogenizeItems( this._highlightedPostId );
				}//end if
		
				this._highlightedPostId = postId;
				_.each( this._itemViews, function( iv ) {
		
					switch ( iv.model.get( 'calendarKind' ) ) {
		
						case 'post':
							if ( postId > 0 && iv.model.get( 'id' ) === postId ) {
								iv.highlight();
							} else {
								iv.blur();
							}//end if
							break;
		
						default:
							if ( postId > 0 && iv.model.get( 'postId' ) === postId ) {
								iv.highlight();
							} else if ( iv.model.get( 'id' ) === modelId ) {
								iv.highlight();
							} else {
								iv.blur();
							}//end if
							break;
		
					}//end switch
		
				});
		
		
			},//end _highlightItems()
		
			/**
			 * Makes all items in the calenadr look the same, without any highlighs or
			 * blurrings.
			 *
			 * @since 1.0.0
			 */
			_homogenizeItems: function() {
		
				if ( this._dragging.active ) {
					_.each( this._itemViews, function( iv ) {
						iv.blur();
					});
				} else {
					_.each( this._itemViews, function( iv ) {
						iv.homogenize();
					});
				}//end if
		
				this._highlightedPostId = 0;
		
			}//end _homogenizeItems()
		
		});//end class
		
		
	
		/**
		 * This view is used for rendering the whole calendar page.
		 *
		 * @constructor
		 * @augments Backbone.View
		 *
		 * @since 1.0.0
		 */
		NelioContent.views.Calendar = Backbone.View.extend( Calendar.object );
	
	})();
	
	

	var monthlyCalendarItems;

	// Look for the first date to load.
	var matches;
	matches = location.search.match( /\bdate=([12][01][0-9][0-9]-[01][0-9](-[0123][0-9])?)$/ );
	if ( matches && matches.length < 2 ) {
		matches = location.search.match( /\bdate=([12][01][0-9][0-9]-[01][0-9](-[0123][0-9])?)&/ );
	}//end if

	var dateInUrl;
	if ( matches && matches.length >= 2 ) {
		dateInUrl = matches[1];
	} else {
		dateInUrl = '';
	}//end if

	if ( dateInUrl.length > 0 ) {
		monthlyCalendarItems = new NelioContent.collections.MonthlyCalendarItems( null, {
				date: dateInUrl
		});
	} else {
		monthlyCalendarItems = new NelioContent.collections.MonthlyCalendarItems();
	}//end if

	var view = new NelioContent.views.Calendar({
		el: $( '#nelio-content-calendar' ),
		collection: monthlyCalendarItems
	});
	view.render();

})( jQuery );
